<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Presentation</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        :root {
            --bg-color: #f0f0f0;
            --pane-bg-left: #e9e9e9;
            --pane-bg-right: #e9e9e9;
            --main-text-color: #333;
            --sub-text-color: #555;
            --accent-color: #007bff;
            --hover-bg: #dcdcdc;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--font-family);
            color: var(--main-text-color);
        }

        #background-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            overflow: hidden;
        }

        #background-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .presentation-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 2fr 1fr;
            grid-template-areas:
                "left top-right"
                "left .";
            height: 100vh;
            gap: 20px;
            padding: 20px;
            box-sizing: border-box;
        }

        .pane {
            background-color: rgba(233, 233, 233, 0.5);
            backdrop-filter: blur(5px);
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        #left-pane {
            grid-area: left;
            display: flex;
            flex-direction: column;
        }

        #left-pane h1 {
            margin-top: 0;
            color: var(--main-text-color);
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 15px;
        }
        
        #left-pane .scrollable-content {
            overflow-y: auto;
            flex-grow: 1;
            position: relative; 
        }

        #left-pane ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        #left-pane li {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            border-left: 4px solid transparent;
            font-size: 20px;
        }

        #left-pane li:hover {
            background-color: var(--hover-bg);
            border-left: 4px solid var(--accent-color);
        }
        
        #left-pane li.active {
            background-color: #e0e0e0;
            border-left: 4px solid var(--accent-color);
            font-weight: bold;
        }

        .subheading-category {
            font-weight: bold;
            margin-top: 20px !important;
            font-size: 22px !important;
            cursor: default !important;
            background-color: transparent !important;
        }
        .subheading-category:hover {
             border-left: 4px solid transparent !important;
        }
        .indented-subheading {
            padding-left: 40px !important;
        }


        #tooltip {
            display: none;
            position: fixed; 
            background: #333;
            color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            white-space: pre-wrap;
            max-width: 300px;
            z-index: 9999; 
            pointer-events: none; 
            font-size: 20px;
        }

        #top-right-pane {
            grid-area: top-right;
            display: flex;
            position: relative;
        }
        
        #media-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-around;
            gap: 15px;
            overflow: hidden;
            border-radius: 5px;
        }
        
        #media-container > *:not(.multi-chart-wrapper):not(.info-graphic) {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            border: none;
        }
        
        .multi-chart-wrapper, .info-graphic {
            position: relative;
            flex: 1;
            height: 100%;
            min-width: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 10px;
        }
        .info-graphic {
            font-size: 1.1em;
            color: var(--main-text-color);
        }
        .info-graphic p { margin: 5px; font-weight: bold; }
        .info-graphic .speed-box { border: 2px solid #ccc; border-radius: 8px; padding: 10px; margin-top: 10px; background: rgba(255,255,255,0.2)}
        .info-graphic .speed-title { font-weight: bold; font-size: 1.2em; margin-bottom: 5px;}
        .info-graphic .speed-row { display: flex; justify-content: space-between; width: 100%; padding: 0 5px; margin-top: 5px;}


        .video-background { opacity: 0.08; z-index: 1; pointer-events: none; }
        .chart-foreground, .svg-foreground { z-index: 2; backdrop-filter: blur(5px); }
        .video-foreground { opacity: 1; z-index: 3; }
        .chart-hidden, .svg-hidden { display: none; }
        
        #media-switcher { position: absolute; bottom: 15px; left: 20px; z-index: 10; }
        .dot { height: 12px; width: 12px; background-color: rgba(255, 255, 255, 0.5); border: 1px solid #333; border-radius: 50%; display: inline-block; margin-right: 8px; cursor: pointer; transition: background-color 0.3s; }
        .dot.active { background-color: var(--accent-color); }

        #page-switcher { position: fixed; bottom: 20px; left: 20px; z-index: 100; }
        #page-switcher .page-dot { height: 16px; width: 16px; background-color: rgba(0, 0, 0, 0.2); border: 2px solid white; }
        #page-switcher .page-dot.active { background-color: white; }

    </style>
</head>
<body>
    <div id="tooltip"></div>
    <div id="page-switcher"></div>
    
    <div id="background-container"></div>

    <div class="presentation-grid">
        <div id="left-pane" class="pane">
            <h1 id="main-title"></h1>
            <div class="scrollable-content">
                <ul id="subheading-list"></ul>
            </div>
        </div>

        <div id="top-right-pane" class="pane">
            <div id="media-container"></div>
            <div id="media-switcher"></div>
        </div>
        
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        const mainTitle = document.getElementById('main-title');
        const subheadingList = document.getElementById('subheading-list');
        const mediaContainer = document.getElementById('media-container');
        const mediaSwitcher = document.getElementById('media-switcher');
        const pageSwitcher = document.getElementById('page-switcher');
        const tooltip = document.getElementById('tooltip');
        
        let currentCharts = [];
        let currentPageIndex = 0;
       let contentP5 = null; // Track the active P5 instance 
        // --- Updated global variables for background management ---
        let bgContainer;
        let p5Sketch = null;
        let vanillaWaveArt = null;
        let originalAnimationId = null;


        const presentationData = [
          {
    title: "2.1 The Jacquard Loom: The First Binary Machine",
    subheadings: {
        'binaryCode': { 
            text: "<b>The Binary Abstraction:</b> Design encoded as 1s (Hole) and 0s (Solid) on pasteboard cards.", 
            tooltip: "Click holes to edit the binary code. Press 'WEAVE' to commit data to fabric.", 
            content: [ { type: 'p5', generator: 'jacquardBinary' } ] 
        },
        'mechanism': { 
            text: "<b>The Mechanism:</b> How a card physically controls the loom's hardware.", 
            tooltip: "Watch how the spring-loaded rods pass through holes to lift warp threads.", 
            content: [ { type: 'p5', generator: 'jacquardMechanism' } ] 
        },
        'hardwareSoftware': { 
            text: "<b>Hardware vs. Software:</b> The separation of the machine (loom) from the data (cards).", 
            tooltip: "Change the 'Software' (Card Deck) to instantly change the 'Hardware' output.", 
            content: [ { type: 'p5', generator: 'jacquardSoftware' } ] 
        },
        'videoExplanation': {
            text: "<b>Video Explanation:</b> The Jacquard Loom - History of Computer Science.",
            tooltip: "Watch a short documentary clip on how the loom inspired modern computing.",
            content: [ 
                { 
                    type: 'video', 
                    // Note: We use the 'embed' URL format here
                    url: 'https://www.youtube.com/embed/MQzpLLhN0fY' 
                } 
            ]
        }
    }
},
      {
    title: "2.2 The Analytical Engine: The Design of Thought",
    subheadings: {
        'architecture': { 
            text: "<b>The Great Separation:</b> The first machine to distinguish between 'The Store' (Memory) and 'The Mill' (CPU).", 
            tooltip: "<b>Concept: The Architecture of Thought</b><br><br>Babbage’s most profound insight was not mechanical, but architectural. He realized that for a machine to be truly general-purpose, it must separate the <i>passive retention</i> of numbers from the <i>active processing</i> of them.<br><br><b>The Store (Memory):</b> This consisted of columns of gear wheels, each holding a number. It is the direct ancestor of modern RAM and hard drives.<br><br><b>The Mill (CPU):</b> This was the central processing unit where arithmetic operations occurred. Data would be 'fetched' from the Store, brought to the Mill to be added or multiplied, and then sent back. This separation is still the foundation of all modern computer architecture (Von Neumann architecture).", 
            content: [ { type: 'p5', generator: 'analyticalArchitecture' } ] 
        },
        'mechanicalMath': { 
            text: "<b>The Mill:</b> Calculating with Gears. How physical rotation translates to arithmetic addition.", 
            tooltip: "<b>Concept: Arithmetic as Motion</b><br><br>In the Analytical Engine, numbers were not abstract electrical signals but physical states of matter. A gear rotated 36 degrees represented the number '1'; 72 degrees was '2'.<br><br><b>The Process:</b> To add two numbers, the machine would mechanically couple the gear representing the first number to the gear representing the sum. By rotating the first gear back to zero, its value was physically transferred to the sum gear. The interactive model here simplifies this to show how rotation equals value.", 
            content: [ { type: 'p5', generator: 'analyticalGears' } ] 
        },
        'loops': { 
            text: "<b>The Cycle:</b> Input, Process, Output. The looping architecture that defined modern computing.", 
            tooltip: "<b>Concept: The Cycle of Operation</b><br><br>The Analytical Engine was not just a calculator; it was a programmable system. It utilized three types of Jacquard cards: Number Cards (Data), Variable Cards (Location), and Operation Cards (Instructions).<br><br><b>The Flow:</b><br>1. <b>Input:</b> Data is read from cards.<br>2. <b>Process:</b> The 'Barrel' reads the instruction and configures the Mill.<br>3. <b>Output:</b> The result is printed.<br><br>Crucially, the engine could 'loop' back to repeat instructions, allowing for iterative calculations—the birth of the algorithm.", 
            content: [ { type: 'p5', generator: 'analyticalCycle' } ] 
        },
        'videoExplanation': {
            text: "<b>Video Explainer:</b> The Greatest Machine That Never Was (Computerphile).",
            tooltip: "<b>Context: The Lost Engine</b><br><br>This video provides a visual and historical deep-dive into the Analytical Engine. Unlike the Difference Engine, which was strictly a calculator, the Analytical Engine was a Turing-complete computer designed a century before the microchip.<br><br>The video illustrates the sheer scale of the brass-and-steam contraption Babbage envisioned—a cathedral of calculation that would have stood as large as a locomotive and required a steam engine to power its thousands of gears.",
            content: [ 
                { 
                    type: 'video', 
                    url: 'https://www.youtube.com/embed/uBbVbqRvqTM?si=K5RRd4QeZtuaJJuW' 
                } 
            ]
        }
    }
},
           {
    title: "2.3 The Vacuum Tube: Computing at the Speed of Light",
    subheadings: {
        'diodePhysics': { 
            text: "<b>The Electronic Valve:</b> Replacing mechanical gears with a stream of electrons (The Vacuum Tube).", 
            tooltip: "<b>Concept: The Edison Effect</b><br><br>Mechanical computers were limited by the physical weight of gears and friction. To calculate faster, we needed a part with no moving mass. Enter the Vacuum Tube.<br><br><b>How it Works:</b> By heating a filament (cathode) inside a glass vacuum bulb, electrons 'boil' off and fly toward a positively charged plate. Crucially, by adding a third element (the grid), we can control this flow instantly. It acts just like a water valve, but for electricity—creating the first high-speed 'On/Off' switch.", 
            content: [ { type: 'p5', generator: 'tubePhysics' } ] 
        },
        'logicGates': { 
            text: "<b>Logic Gates:</b> Arranging switches to make decisions (AND, OR, XOR).", 
            tooltip: "<b>Concept: Boolean Logic</b><br><br>A single switch isn't very smart. But if you connect two switches in a specific pattern, they can make simple logical decisions. These arrangements are called 'Gates'.<br><br><b>AND Gate:</b> Only turns ON if Input A <i>AND</i> Input B are both ON.<br><b>OR Gate:</b> Turns ON if Input A <i>OR</i> Input B (or both) are ON.<br><br>This is the alphabet of computer reasoning. Complex thoughts are built from these simple sentences.", 
            content: [ { type: 'p5', generator: 'logicGateVis' } ] 
        },
        'binaryAdder': { 
            text: "<b>The Half Adder:</b> Connecting gates to perform binary addition (1 + 1 = 10).", 
            tooltip: "<b>Concept: The Birth of Calculation</b><br><br>This is the most critical concept in hardware: How do dumb switches do math?<br><br>By combining an <b>XOR Gate</b> and an <b>AND Gate</b>, we create a circuit called a 'Half Adder'.<br><br>1. If you add <b>0 + 0</b>, you get <b>0</b>.<br>2. If you add <b>1 + 0</b>, you get <b>1</b>.<br>3. But if you add <b>1 + 1</b>, the result is <b>2</b>. In binary, '2' is written as '10'.<br><br>The interactive diagram shows exactly how the current splits to create this 'Carry' digit.", 
            content: [ { type: 'p5', generator: 'binaryAdder' } ] 
        },
        'fullAdderChain': { 
            text: "<b>Scaling Up:</b> Chaining adders to calculate larger numbers (The Ripple Carry).", 
            tooltip: "<b>Concept: The Bucket Brigade</b><br><br>A Half Adder is great, but it has a fatal flaw: it can't accept a 'carry' digit from a neighbor. To count past 2, we need a <b>Full Adder</b>.<br><br>By chaining these blocks together, the 'Carry Out' of one position becomes the 'Carry In' of the next. This creates a chain reaction (a ripple) allowing us to add 4-bit, 8-bit, or 64-bit numbers. The interactive diagram allows you to perform 4-bit addition (0-15).", 
            content: [ { type: 'p5', generator: 'rippleAdder' } ] 
        },
        'binaryConversion': { 
            text: "<b>The 8-Bit Byte:</b> Understanding binary place values and converting to decimal.", 
            tooltip: "<b>Concept: Powers of Two</b><br><br>In the decimal system (Base 10), columns represent 1, 10, 100, 1000.<br>In the binary system (Base 2), columns represent <b>1, 2, 4, 8, 16, 32, 64, 128</b>.<br><br>An 8-bit 'Byte' is just a row of these 8 switches. If a switch is ON (1), you add that number to the total. If it is OFF (0), you ignore it.<br>Example: 00000101 is 4 + 1 = 5.", 
            content: [ { type: 'p5', generator: 'byteConverter' } ] 
        },
        'videoExplanation': {
            text: "<b>Video Explainer:</b> Electronic Computing (Crash Course).",
            tooltip: "<b>Context: The Speed of Light</b><br><br>This video covers the pivotal moment when humanity moved from mechanical computing (gears and steam) to electronic computing (vacuum tubes and circuits), increasing calculation speed exponentially.",
            content: [ 
                { 
                    type: 'video', 
                    url: 'https://www.youtube.com/embed/FU_YFpfDqqA?si=6sslVRe-lru48uS_' 
                } 
            ]
        }
    }
},
            {
    title: "3 The Anatomy of Decision: Logic in Art",
    subheadings: {
        'gateAND': { 
            text: "<b>The AND Gate:</b> Strict Conditionality (The Kinetic Sculpture).", 
            tooltip: "<b>Concept: The Safety Mechanism</b><br><br>The AND gate represents strict rules. It requires <i>every</i> condition to be met before acting.<br><br><b>The Installation:</b> Consider a dangerous kinetic sculpture with spinning blades.<br>Input A: Motion Sensor (Is someone watching?)<br>Input B: Safety Barrier (Is the gate locked?)<br><br>The sculpture will ONLY activate if (A) The sensor is triggered <b>AND</b> (B) The barrier is closed. If even one condition is missing, the machine remains safe (Off).", 
            content: [ { type: 'p5', generator: 'gateAND' } ] 
        },
        'gateOR': { 
            text: "<b>The OR Gate:</b> Possibilities (The Lighting Installation).", 
            tooltip: "<b>Concept: The Permissive System</b><br><br>The OR gate represents options. It activates if <i>any</i> of the inputs are true.<br><br><b>The Installation:</b> An interactive stage light system designed for two users.<br>Input A: Left Pressure Pad.<br>Input B: Right Pressure Pad.<br><br>The lights turn ON if User 1 steps on the left pad <b>OR</b> User 2 steps on the right pad (or both). It encourages participation from anyone.", 
            content: [ { type: 'p5', generator: 'gateOR' } ] 
        },
        'gateNOT': { 
            text: "<b>The NOT Gate:</b> Inversion (The Reactive Sound Piece).", 
            tooltip: "<b>Concept: The Contrarial Switch</b><br><br>The NOT gate (Inverter) flips reality. It turns Yes into No, and On into Off.<br><br><b>The Installation:</b> A sound art piece that demands silence.<br>Input: Microphone Level (Room Noise).<br><br>When the room is noisy (1), the installation goes silent (0).<br>When the room is silent (0), the installation begins to sing (1).<br>It forces the audience to quiet down to experience the work.", 
            content: [ { type: 'p5', generator: 'gateNOT' } ] 
        }
    }
},
 {
    title: "4.1 Sampling: The Grid",
    subheadings: {
        'spatialSampling': { 
            text: "<b>Spatial Sampling:</b> Breaking reality into a grid of pixels (Resolution).", 
            tooltip: "<b>Concept: The Window Screen</b><br><br>Imagine looking at a landscape through a mesh screen. You cannot paint the infinite curve of a hill; you can only record the dominant color inside each square of the mesh. [cite: 86, 87][cite_start]<br><br><b>Resolution:</b> The density of this mesh is the 'Resolution'. [cite: 88][cite_start]<br><b>Low Resolution:</b> A coarse mesh creates a blocky, pixelated image (Aliasing) where fine details are lost. [cite: 89][cite_start]<br><b>High Resolution:</b> A fine mesh captures enough detail that the human eye is tricked into seeing a continuous image. [cite: 90]", 
            content: [ { type: 'p5', generator: 'spatialSampling' } ] 
        },
        'temporalSampling': { 
            text: "<b>Temporal Sampling:</b> Slicing time into still frames (Frame Rate).", 
            tooltip: "<b>Concept: The Illusion of Motion</b><br><br>Time is continuous, but digital video is discrete. [cite_start]A camera captures reality as a sequence of frozen images (frames). [cite: 91, 92][cite_start]<br><br><b>Frame Rate (FPS):</b> This is the frequency of capture.<br><b>Low FPS:</b> If the sample rate is too low (e.g., 5 fps), the brain perceives individual images, and the illusion of movement breaks down. [cite: 93]<br><b>High FPS:</b> At 24-60 fps, the gaps between frames are small enough that our brain smoothes them out.", 
            content: [ { type: 'p5', generator: 'temporalSampling' } ] 
        },
        'nyquistLimit': { 
            text: "<b>The Nyquist Limit:</b> The mathematical speed limit of digital capture.", 
            tooltip: "<b>Concept: The Nyquist-Shannon Theorem</b><br><br>To perfectly reconstruct a continuous signal (like a sound wave), you must sample it at least <b>twice as fast</b> as its highest frequency. [cite: 94]<br><br><b>Example:</b> Human hearing goes up to 20kHz. [cite_start]Therefore, standard digital audio (CDs) samples at 44.1kHz—just over double the limit—to ensure every pitch is captured accurately. [cite: 95] The interactive diagram shows what happens to a wave when you don't sample fast enough.", 
            content: [ { type: 'p5', generator: 'nyquistVis' } ] 
        }
    }
},
 
{
    title: "4.2 Color Theory: Light vs. Pigment",
    dotColor: 'rgb(255, 255, 160)', // Custom background particle color
    subheadings: {
        'colorMixing': { 
            text: "<b>The Physics of Mixing:</b> Additive (Light) vs. Subtractive (Pigment).", 
            tooltip: "<b>Concept: How Computers vs. Printers See Color</b><br><br><b>Additive (RGB):</b> Used by screens. Mixing Red, Green, and Blue light creates White. Black is the absence of light.<br><br><b>Subtractive (CMY):</b> Used by printers/paints. Mixing Cyan, Magenta, and Yellow absorbs light, creating Black (mud). White is the canvas.<br><br><b>Average:</b> How digital paint often behaves, blending values together mathematically.", 
            content: [ { type: 'p5', generator: 'colorMixer' } ] 
        },
        'digitalPainter': { 
            text: "<b>Digital Painting:</b> A full HSV engine with data inspection.", 
            tooltip: "<b>Concept: The HSV Model</b><br><br>While computers process RGB, artists think in <b>HSV</b>:<br><b>Hue:</b> The color family (Red vs Blue).<br><b>Saturation:</b> The intensity (Vibrant vs Dull).<br><b>Value:</b> The brightness (Light vs Dark).<br><br>Use the <b>Eyedropper Tool</b> to see the underlying RGB (Screen) and CMY (Print) numbers for any pixel you paint.", 
            content: [ { type: 'p5', generator: 'digitalPainter' } ] 
        }
    }
},
{
    title: "5.1 Sketchpad: The Birth of Interactive Graphics",
    dotColor: 'rgb(255, 210, 160)', 
    subheadings: {
        'directManipulation': { 
            text: "<b>The Light Pen:</b> The first time humans drew directly on a screen (1963). [cite: 120, 121]", 
            tooltip: "<b>Concept: The First GUI</b><br><br>Before Ivan Sutherland's <i>Sketchpad</i>, computing was text-based batch processing. Sutherland used a 'Light Pen' to draw directly on the CRT monitor.<br><br><b>Interaction:</b> The computer tracked the pen's position and drew glowing vector lines in real-time. [cite_start]This interactive loop—user moves, screen updates—is the ancestor of every mouse cursor and touchscreen used today. [cite: 121]", 
            content: [ { type: 'p5', generator: 'sketchpadDraw' } ] 
        },
        'masterInstance': { 
            text: "<b>Object-Oriented Logic:</b> Defining a 'Master' object to control many 'Instances'. [cite: 122, 123]", 
            tooltip: "<b>Concept: The Master and the Instance</b><br><br>Sketchpad introduced a powerful idea: you can draw an object once (The Master) and create infinite copies (Instances).<br><br><b>The Power:</b> Unlike a photocopier, these copies remain linked to the original. If you modify the Master (e.g., change its shape), <i>every single instance</i> updates instantly. [cite_start]This is the foundation of modern computer graphics and coding classes. [cite: 124, 125]", 
            content: [ { type: 'p5', generator: 'masterInstance' } ] 
        },
        'constraints': { 
            text: "<b>Constraints:</b> Telling the computer to 'perfect' your rough drawing. [cite: 126]", 
            tooltip: "<b>Concept: Computational Geometry</b><br><br>In Sketchpad, you didn't just draw; you defined rules. You could draw a rough wobbly box and tell the computer: 'Make these lines parallel' or 'Make this corner 90 degrees.'<br><br><b>Automation:</b> The computer acts as a mathematical partner, snapping your rough input into perfect geometric precision. [cite_start]This logic underpins all CAD (Computer-Aided Design) software used to build airplanes and architecture. [cite: 127]", 
            content: [ { type: 'p5', generator: 'geometricConstraints' } ] 
        }
    }
},
{
    title: "5.2 The Third Dimension: Polygons and Perspective",
    dotColor: 'rgb(255, 210, 160)', 
    subheadings: {
        'wireframeLogic': { 
            text: "<b>The Wireframe:</b> Vertices, Edges, and Faces.", 
            tooltip: "<b>History: The Volkswagen Wireframe</b><br><br>In the early days of 3D, computers could not render solid objects in real-time. Sutherland and his peers (like the group at the University of Utah) developed the <b>Wireframe</b> method.<br><br>By storing only the corners (Vertices) and connecting lines (Edges), they could represent complex 3D shapes—like the famous 'Volkswagen Beetle' dataset from 1971—using very little memory. The computer calculates the perspective math to project these 3D points onto your 2D screen.", 
            content: [ { type: 'p5', generator: 'wireframeModel' } ] 
        },
        'renderingPipeline': { 
            text: "<b>The Rendering Pipeline:</b> Rasterization and Shading.", 
            tooltip: "<b>Concept: Filling the Void</b><br><br>Once the wireframe is built, the computer must 'Render' it to look solid. This happens in a strict pipeline:<br><br>1. <b>Rasterization:</b> The computer calculates which pixels on your screen fall inside the triangle's edges.<br>2. <b>Flat Shading:</b> It calculates the angle of the face relative to a light source. If a face points toward the light, it is painted a brighter color; if away, darker. This creates the illusion of depth on a flat screen.", 
            content: [ { type: 'p5', generator: 'renderingPipeline' } ] 
        },
        'textureMapping': { 
            text: "<b>Texture Mapping:</b> Wrapping 2D images onto 3D geometry.", 
            tooltip: "<b>Concept: Ed Catmull's Breakthrough (1974)</b><br><br>Early 3D objects looked like plastic toys. To solve this, Ed Catmull (founder of Pixar) invented <b>Texture Mapping</b>.<br><br>He realized you could take a 2D image (like a photo of wood or skin) and mathematically 'wrap' it around a 3D wireframe, effectively painting pixels onto polygons. This allowed low-polygon models to look incredibly realistic.", 
            content: [ { type: 'p5', generator: 'textureCube' } ] 
        }
    }
},
{
    title: "5.3 Procedural Generation: The Artist as Gardener",
    dotColor: 'rgb(255, 160, 160)', 
    subheadings: {
        'lSystems': { 
            text: "<b>L-Systems:</b> Growing complexity from simple rules (The Fractal Tree).", 
            tooltip: "<b>Concept: Algorithmic Botany</b><br><br>Instead of modeling a tree branch by branch, an artist writes a genetic rule: 'Start with a trunk. At the end of the trunk, split into two shorter branches. Repeat.'<br><br><b>The Power of Recursion:</b> This simple rule, repeated just 5 or 6 times, creates a structure of immense complexity. This is how video games generate infinite forests without an artist drawing a single leaf.", 
            content: [ { type: 'p5', generator: 'lSystemTree' } ] 
        },
        'perlinNoise': { 
            text: "<b>Perlin Noise:</b> The math of controlled randomness (Terrain Generation).", 
            tooltip: "<b>Concept: Controlled Chaos</b><br><br>True randomness (TV static) looks like garbage. Nature is random but <i>coherent</i>—hills roll gently, clouds drift smoothly.<br><br><b>Ken Perlin's Algorithm:</b> In the 1980s, Ken Perlin invented a type of 'smooth' randomness. This interactive terrain generator uses Perlin Noise to create mountains and valleys that look organic, not chaotic.", 
            content: [ { type: 'p5', generator: 'perlinTerrain' } ] 
        },
        'cellularAutomata': { 
            text: "<b>Cellular Automata:</b> Emergent behavior from local interactions (The Game of Life).", 
            tooltip: "<b>Concept: Emergence</b><br><br>Complex behavior can emerge from dumb agents following simple rules. In this grid, each cell lives or dies based on its neighbors.<br><br><b>The result:</b> Static patterns, moving 'gliders,' and chaotic explosions emerge automatically. This logic is used to simulate fluid dynamics, fire spreads, and flocking birds.", 
            content: [ { type: 'p5', generator: 'gameOfLife' } ] 
        }
    }
},
{
    title: "6.0 Video & Interactive Art: The Mirror",
    dotColor: 'rgb(130, 120, 255)', // Red for "Recording/Live" light
    subheadings: {
        'signalProcessing': { 
            text: "<b>6.1 The Signal:</b> Video as an electronic voltage (Nam June Paik).", 
            tooltip: "<b>Concept: The Prepared TV</b><br><br>Before computers, video art was analog. Artists like Nam June Paik used magnets and synthesizers to distort the electron beam of CRT TVs.<br><br><b>The Interaction:</b> This demo takes your live webcam feed and treats it as a raw electrical signal. Move your mouse to simulate a 'magnet' warping the broadcast signal, creating the classic analog distortion aesthetic.", 
            content: [ { type: 'p5', generator: 'videoSignal' } ] 
        },
        'computerVision': { 
            text: "<b>6.2 The Machine Gaze:</b> How computers 'see' (Edge Detection).", 
            tooltip: "<b>Concept: Computer Vision</b><br><br>A camera is just a sensor; the <i>computer</i> does the seeing. To understand an image, the computer looks for high-contrast changes between pixels to identify boundaries.<br><br><b>The Interaction:</b> This demo strips away the color of your webcam feed and visualizes only the 'Edges'—the math the computer uses to distinguish your silhouette from the background.", 
            content: [ { type: 'p5', generator: 'videoVision' } ] 
        },
        'timeDelay': { 
            text: "<b>6.3 The Time Loop:</b> Displacing the viewer in time (Video Feedback).", 
            tooltip: "<b>Concept: The Digital Mirror</b><br><br>Interactive art (like Myron Krueger's <i>Videoplace</i>) often plays with time. By delaying the video feed, the mirror stops reflecting the 'Now' and starts reflecting the 'Just Then.'<br><br><b>The Interaction:</b> Move your body quickly. The visual follows you like a ghost (Slit-Scan effect), painting time across the screen.", 
            content: [ { type: 'p5', generator: 'videoTime' } ] 
        }
    }
},
            { // Page '11'
                title: "AI-Powered Churn Prediction & Prevention Solution",
                dotColor: 'rgb(130, 130, 255)',
                subheadings: {
                    'churnSystemOverview': { text: "Proactive <b>AI-driven churn prediction system</b> that identifies at-risk customers before they leave.", tooltip: "T-Nor's churn prediction system uses machine learning to analyze customer behavior patterns, network usage, billing history, and service interactions to predict churn risk 30-60 days in advance.", content: [{type: 'svg', generator: 'churn_overview'}]},
                    'agenticWorkflow': { text: "The Churn Prevention Agentic Workflow:", isCategory: true, content: [{type: 'empty'}] },
                    'churnDetection': { text: "<b>1.</b> <b>Churn Detection Agent</b> - Continuously monitors customer behavior signals.", tooltip: "The Churn Detection Agent analyzes real-time data including call patterns, data usage, billing irregularities, and service complaints to calculate a churn risk score for each customer.", isIndented: true, content: [{type: 'chart', generator: 'churn_detection'}] },
                    'riskAssessment': { text: "<b>2.</b> <b>Risk Assessment Agent</b> - Prioritizes customers by churn probability and value.", tooltip: "The Risk Assessment Agent evaluates customer lifetime value, churn probability, and retention cost to prioritize intervention efforts on high-value, high-risk customers first.", isIndented: true, content: [{type: 'chart', generator: 'churn_risk_assessment'}] },
                    'interventionAgent': { text: "<b>3.</b> <b>Intervention Agent</b> - Triggers personalized retention campaigns via multiple channels.", tooltip: "When high churn risk is detected, the Intervention Agent automatically initiates contact through SMS, voice calls, app notifications, or email with personalized offers and retention strategies.", isIndented: true, content: [{type: 'svg', generator: 'churn_intervention'}] },
                    'conversationAgent': { text: "<b>4.</b> <b>Conversation Agent</b> - Engages customers through voice, text, and chat.", tooltip: "The Conversation Agent conducts natural language interactions via voice calls, SMS, WhatsApp, and app chat to understand customer issues, offer solutions, and negotiate retention deals in real-time.", isIndented: true, content: [{type: 'svg', generator: 'churn_conversation'}] },
                    'offerEngine': { text: "<b>5.</b> <b>Dynamic Offer Engine</b> - Generates personalized retention offers in real-time.", tooltip: "Based on customer profile, usage patterns, and conversation context, the Offer Engine creates tailored packages including discounted plans, bonus data, free minutes, or premium services to maximize retention probability.", isIndented: true, content: [{type: 'chart', generator: 'churn_offers'}] },
                    'outcomeTracking': { text: "<b>6.</b> <b>Outcome Tracking Agent</b> - Monitors retention success and updates models.", tooltip: "The Outcome Tracking Agent follows up on intervention results, tracks customer behavior changes, and feeds success/failure data back to improve churn prediction accuracy and intervention strategies.", isIndented: true, content: [{type: 'chart', generator: 'churn_outcomes'}] },
                    'businessResults': { text: "Churn Prevention Results:", isCategory: true, content: [{type: 'empty'}] },
                    'churnReduction': { text: "<b>34%</b> reduction in monthly churn rate from <b>8.2%</b> to <b>5.4%</b>.", tooltip: "The AI-powered churn prevention system successfully reduced T-Nor's monthly churn rate from 8.2% to 5.4%, representing a 34% improvement in customer retention.", isIndented: true, content: [{type: 'chart', generator: 'churn_reduction_chart'}] },
                    'revenueImpact': { text: "Increased customer lifetime value by <b>$187</b> per customer through targeted retention.", tooltip: "By retaining high-value customers who would have churned, T-Nor increased average customer lifetime value by $187, resulting in millions in additional revenue annually.", isIndented: true, content: [{type: 'chart', generator: 'churn_revenue_impact'}] },
                    'campaignROI': { text: "Retention campaign ROI of <b>420%</b> with <b>67%</b> success rate.", tooltip: "The targeted retention campaigns achieved a 420% return on investment with a 67% success rate in preventing churn, significantly outperforming traditional mass marketing approaches.", isIndented: true, content: [{type: 'chart', generator: 'churn_campaign_roi'}] }
                }
            },
            { // Page '12'
                title: "Proactive Churn Intervention Agent",
                dotColor: 'rgb(130, 140, 255)',
                subheadings: {
                    'interventionSystemOverview': { text: "Autonomous system that <b>prevents churn in real-time</b> through personalized retention actions.", tooltip: "The Proactive Churn Intervention Agent transforms churn prediction from reports into automated, revenue-saving workflows by immediately contacting at-risk customers with optimized retention offers.", content: [{type: 'svg', generator: 'intervention_overview'}]},
                    'interventionWorkflow': { text: "The Proactive Intervention Workflow:", isCategory: true, content: [{type: 'empty'}] },
                    'triggerDetection': { text: "<b>1.</b> <b>Churn Trigger Agent</b> - Monitors churn scores and activates intervention protocols.", tooltip: "Continuously monitors output from churn prediction models and automatically triggers intervention when customer churn probability exceeds 85% threshold, ensuring immediate action on high-risk cases.", isIndented: true, content: [{type: 'chart', generator: 'intervention_trigger'}] },
                    'offerSelection': { text: "<b>2.</b> <b>Next-Best-Offer Agent</b> - Selects optimal retention offers for each customer.", tooltip: "Queries the personalized offers engine to select the most effective retention strategy for each at-risk customer, considering their usage patterns, value tier, and previous offer responses.", isIndented: true, content: [{type: 'chart', generator: 'intervention_offer_selection'}] },
                    'automatedOutreach': { text: "<b>3.</b> <b>Automated Outreach Agent</b> - Initiates personalized contact via voice, SMS, and app.", tooltip: "Automatically initiates contact through conversational voice calls, rich SMS, or app notifications with personalized scripts: 'Hi [Name], we noticed you haven't used your data pack recently. As a valued customer, we'd like to offer you [Personalized Offer].'", isIndented: true, content: [{type: 'svg', generator: 'intervention_outreach'}] },
                    'conversationManagement': { text: "<b>4.</b> <b>Conversation Management Agent</b> - Handles customer interactions and negotiations.", tooltip: "Manages real-time conversations with customers, understands their concerns, negotiates retention terms, and can escalate to human agents when needed while maintaining context throughout the interaction.", isIndented: true, content: [{type: 'svg', generator: 'intervention_conversation'}] },
                    'provisioningAgent': { text: "<b>5.</b> <b>Automated Provisioning Agent</b> - Instantly applies accepted offers to customer accounts.", tooltip: "When customers accept retention offers via voice command, SMS reply, or app interaction, automatically triggers API calls to T-Nor's billing system to provision discounts, bonuses, or new bundles immediately.", isIndented: true, content: [{type: 'svg', generator: 'intervention_provisioning'}] },
                    'outcomeTracking': { text: "<b>6.</b> <b>Intervention Tracking Agent</b> - Monitors success rates and optimizes future interventions.", tooltip: "Tracks intervention outcomes, analyzes success patterns, and feeds learnings back to improve churn prediction accuracy and intervention strategies for better future performance.", isIndented: true, content: [{type: 'chart', generator: 'intervention_tracking'}] },
                    'interventionResults': { text: "Proactive Intervention Results:", isCategory: true, content: [{type: 'empty'}] },
                    'churnPrevention': { text: "<b>30%</b> reduction in customer churn within pilot regions.", tooltip: "The proactive intervention system achieved a 30% reduction in customer churn within pilot regions, directly preventing revenue loss and improving customer retention metrics.", isIndented: true, content: [{type: 'chart', generator: 'intervention_churn_reduction'}] },
                    'retentionROI': { text: "Retention intervention ROI of <b>380%</b> with <b>72%</b> offer acceptance rate.", tooltip: "The automated intervention system achieved 380% return on investment with 72% of contacted customers accepting retention offers, significantly outperforming manual retention efforts.", isIndented: true, content: [{type: 'chart', generator: 'intervention_roi'}] },
                    'customerSatisfaction': { text: "Intervention customer satisfaction score of <b>4.6/5</b> with <b>89%</b> positive feedback.", tooltip: "Customers responded positively to proactive interventions, with 4.6/5 satisfaction scores and 89% providing positive feedback about the personalized, timely nature of the retention offers.", isIndented: true, content: [{type: 'chart', generator: 'intervention_satisfaction'}] }
                }
            },
            { // Page '13'
                title: "Hyper-Personalized Marketing & Loyalty Agent",
                dotColor: 'rgb(130, 150, 255)',
                subheadings: {
                    'marketingSystemOverview': { text: "AI-driven system that creates <b>individualized customer experiences</b> to increase ARPU and loyalty.", tooltip: "The Hyper-Personalized Marketing & Loyalty Agent uses machine learning to analyze 360-degree customer profiles and deliver truly personalized offers, content, and loyalty rewards based on real-time behavioral insights.", content: [{type: 'svg', generator: 'marketing_overview'}]},
                    'personalizedWorkflow': { text: "The Hyper-Personalization Workflow:", isCategory: true, content: [{type: 'empty'}] },
                    'dataUnification': { text: "<b>1.</b> <b>Data Unification Agent</b> - Creates unified 360-degree customer profiles.", tooltip: "The Data Unification Agent aggregates data from CDRs, usage history, app interactions, billing records, and customer support logs to create comprehensive customer profiles for deep behavioral analysis.", isIndented: true, content: [{type: 'chart', generator: 'marketing_data_unification'}] },
                    'behavioralSegmentation': { text: "<b>2.</b> <b>Behavioral Segmentation Agent</b> - Identifies micro-segments using unsupervised ML.", tooltip: "Uses clustering algorithms to identify behavior-based micro-segments like 'Night-time Data Users,' 'Weekend Callers,' 'Roaming Professionals,' enabling hyper-targeted marketing strategies.", isIndented: true, content: [{type: 'chart', generator: 'marketing_segmentation'}] },
                    'offerPersonalization': { text: "<b>3.</b> <b>Offer Personalization Engine</b> - Matches users with most relevant products and bundles.", tooltip: "Employs advanced recommender algorithms to match individual customers with the most relevant data bundles, services, and content offers based on their unique usage patterns and preferences.", isIndented: true, content: [{type: 'svg', generator: 'marketing_personalization'}] },
                    'loyaltyAutomation': { text: "<b>4.</b> <b>Dynamic Loyalty Agent</b> - Automates tier assignments and rewards based on engagement.", tooltip: "Creates a gamified loyalty experience by automatically assigning tiers and rewards based on customer tenure, spend (ARPU), engagement levels, and behavioral milestones.", isIndented: true, content: [{type: 'chart', generator: 'marketing_loyalty'}] },
                    'deliveryOptimization': { text: "<b>5.</b> <b>Delivery Optimization Agent</b> - Determines optimal timing and channels for engagement.", tooltip: "Analyzes customer interaction patterns to determine the best time, channel, and message format for maximum engagement and conversion rates across SMS, app, email, and voice.", isIndented: true, content: [{type: 'svg', generator: 'marketing_delivery'}] },
                    'continuousLearning': { text: "<b>6.</b> <b>Performance Learning Agent</b> - Continuously optimizes campaigns based on results.", tooltip: "Monitors campaign performance, A/B tests different approaches, and continuously refines personalization models to improve conversion rates and customer satisfaction.", isIndented: true, content: [{type: 'chart', generator: 'marketing_learning'}] },
                    'marketingResults': { text: "Hyper-Personalization Results:", isCategory: true, content: [{type: 'empty'}] },
                    'arpuIncrease': { text: "<b>23%</b> increase in ARPU through effective cross-selling and upselling.", tooltip: "The hyper-personalized marketing system increased average revenue per user by 23% through targeted cross-selling of relevant data bundles, premium services, and add-on products.", isIndented: true, content: [{type: 'chart', generator: 'marketing_arpu'}] },
                    'campaignEfficiency': { text: "Campaign conversion rates improved by <b>15%</b> with <b>40%</b> higher engagement.", tooltip: "Personalized campaigns achieved 15% higher conversion rates and 40% higher engagement compared to traditional mass marketing approaches, with customers actively participating in loyalty programs.", isIndented: true, content: [{type: 'chart', generator: 'marketing_conversion'}] },
                    'loyaltyImpact': { text: "Customer loyalty scores increased to <b>8.2/10</b> with <b>65%</b> program participation.", tooltip: "The dynamic loyalty program achieved 8.2/10 average loyalty scores with 65% of customers actively participating in tier-based rewards and gamified experiences.", isIndented: true, content: [{type: 'chart', generator: 'marketing_loyalty_scores'}] }
                }
            },
            { // Page '14'
                title: "Social Media Sentiment & Escalation Agent",
                dotColor: 'rgb(130, 160, 255)',
                subheadings: {
                    'sentimentSystemOverview': { text: "AI system that <b>monitors public sentiment</b> and proactively manages brand reputation.", tooltip: "The Social Media Sentiment & Escalation Agent continuously monitors public mentions, analyzes sentiment in real-time, and automatically escalates or responds to protect T-Nor's brand reputation before issues escalate.", content: [{type: 'svg', generator: 'sentiment_overview'}]},
                    'sentimentWorkflow': { text: "The Sentiment Monitoring Workflow:", isCategory: true, content: [{type: 'empty'}] },
                    'dataIngestion': { text: "<b>1.</b> <b>Social Data Ingestion Agent</b> - Continuously scrapes public social media feeds and reviews.", tooltip: "Continuously monitors Twitter/X, Facebook, Instagram, app store reviews, and forums for mentions of 'T-Nor' and related keywords, ensuring comprehensive coverage of public sentiment.", isIndented: true, content: [{type: 'chart', generator: 'sentiment_ingestion'}] },
                    'sentimentAnalysis': { text: "<b>2.</b> <b>NLP Sentiment Analysis Agent</b> - Classifies sentiment and identifies topics using advanced models.", tooltip: "Applies fine-tuned Natural Language Processing models to classify mentions as positive, neutral, or negative, while identifying topics like 'Network,' 'Billing,' 'Customer Service,' or 'Advertising' for targeted responses.", isIndented: true, content: [{type: 'chart', generator: 'sentiment_analysis'}] },
                    'triageEscalation': { text: "<b>3.</b> <b>Intelligent Triage Agent</b> - Automatically prioritizes and escalates critical issues.", tooltip: "Negative sentiment + urgent topics (network outage) create high-priority NOC tickets. Individual billing issues generate CRM tickets. The system ensures appropriate team notification and response priority.", isIndented: true, content: [{type: 'svg', generator: 'sentiment_triage'}] },
                    'responseGeneration': { text: "<b>4.</b> <b>Automated Response Agent</b> - Generates contextual public replies and follow-ups.", tooltip: "Automatically posts appropriate public replies like 'We're sorry to hear about your issue. Please DM us your number so we can investigate.' while maintaining brand voice and escalating complex issues to human teams.", isIndented: true, content: [{type: 'svg', generator: 'sentiment_response'}] },
                    'insightAggregation': { text: "<b>5.</b> <b>Sentiment Intelligence Agent</b> - Creates real-time sentiment dashboards and trend analysis.", tooltip: "Aggregates sentiment data into live dashboards showing public opinion trends, emerging issues, topic popularity, and comparative sentiment analysis for strategic brand management.", isIndented: true, content: [{type: 'chart', generator: 'sentiment_insights'}] },
                    'proactiveMonitoring': { text: "<b>6.</b> <b>Early Warning Agent</b> - Detects emerging issues before they become widespread.", tooltip: "Identifies patterns in negative sentiment that could indicate widespread service issues, allowing T-Nor to address problems proactively before they impact large customer segments.", isIndented: true, content: [{type: 'chart', generator: 'sentiment_early_warning'}] },
                    'sentimentResults': { text: "Sentiment Management Results:", isCategory: true, content: [{type: 'empty'}] },
                    'responseTime': { text: "<b>75%</b> reduction in mean time to resolution for publicly reported issues.", tooltip: "The automated sentiment monitoring and escalation system reduced mean time to resolution for publicly reported issues by 75%, enabling faster response to customer complaints and network problems.", isIndented: true, content: [{type: 'chart', generator: 'sentiment_response_time'}] },
                    'brandSentiment': { text: "Overall brand sentiment improved from <b>-12%</b> to <b>+18%</b> positive.", tooltip: "Proactive sentiment management and rapid issue resolution improved T-Nor's overall brand sentiment from -12% (net negative) to +18% (net positive) across social media platforms.", isIndented: true, content: [{type: 'chart', generator: 'sentiment_brand_improvement'}] },
                    'issueDetection': { text: "Early detection of <b>94%</b> of network issues through social mentions before internal reporting.", tooltip: "The system detected 94% of significant network issues through social media mentions before they were reported through internal channels, enabling proactive network management and customer communication.", isIndented: true, content: [{type: 'chart', generator: 'sentiment_issue_detection'}] }
                }
            },
            { // Page '15'
                title: "AI-Powered Network Optimization & Predictive Maintenance Agent",
                dotColor: 'rgb(130, 170, 255)',
                subheadings: {
                    'networkSystemOverview': { text: "Autonomous system that <b>predicts and prevents network failures</b> before they impact customers.", tooltip: "The AI-Powered Network Optimization Agent uses machine learning to analyze network performance data, predict equipment failures, and automatically optimize network resources to maintain 99.99% uptime.", content: [{type: 'svg', generator: 'network_overview'}]},
                    'networkWorkflow': { text: "The Network Intelligence Workflow:", isCategory: true, content: [{type: 'empty'}] },
                    'dataCollection': { text: "<b>1.</b> <b>Network Data Collection Agent</b> - Continuously monitors all network infrastructure components.", tooltip: "Collects real-time data from cell towers, base stations, switches, routers, and fiber infrastructure, monitoring performance metrics, traffic patterns, and equipment health indicators.", isIndented: true, content: [{type: 'chart', generator: 'network_data_collection'}] },
                    'anomalyDetection': { text: "<b>2.</b> <b>Anomaly Detection Agent</b> - Identifies patterns that indicate potential network issues.", tooltip: "Uses unsupervised learning to detect unusual patterns in network behavior, traffic anomalies, equipment degradation signals, and early warning signs of potential failures.", isIndented: true, content: [{type: 'chart', generator: 'network_anomaly_detection'}] },
                    'predictiveMaintenance': { text: "<b>3.</b> <b>Predictive Maintenance Agent</b> - Forecasts equipment failures and schedules maintenance.", tooltip: "Analyzes equipment lifecycle data, performance trends, and environmental factors to predict when components will fail, automatically scheduling preventive maintenance before issues occur.", isIndented: true, content: [{type: 'svg', generator: 'network_predictive_maintenance'}] },
                    'capacityOptimization': { text: "<b>4.</b> <b>Capacity Optimization Agent</b> - Dynamically allocates network resources based on demand.", tooltip: "Analyzes traffic patterns and usage forecasts to automatically redistribute bandwidth, optimize cell tower loads, and ensure optimal network performance during peak hours.", isIndented: true, content: [{type: 'chart', generator: 'network_capacity_optimization'}] },
                    'selfHealing': { text: "<b>5.</b> <b>Self-Healing Network Agent</b> - Automatically resolves network issues without human intervention.", tooltip: "When problems are detected, automatically reroutes traffic, activates backup systems, adjusts power levels, and implements fixes to maintain service continuity.", isIndented: true, content: [{type: 'svg', generator: 'network_self_healing'}] },
                    'performanceMonitoring': { text: "<b>6.</b> <b>Performance Analytics Agent</b> - Provides real-time network insights and optimization recommendations.", tooltip: "Continuously analyzes network performance metrics, customer experience indicators, and service quality to provide actionable insights for network improvements.", isIndented: true, content: [{type: 'chart', generator: 'network_performance_monitoring'}] },
                    'networkResults': { text: "Network Optimization Results:", isCategory: true, content: [{type: 'empty'}] },
                    'uptimeImprovement': { text: "Network uptime increased to <b>99.97%</b> with <b>85%</b> reduction in unplanned outages.", tooltip: "The AI-powered network optimization system achieved 99.97% uptime, exceeding the 99.99% target during pilot phase, with an 85% reduction in unplanned network outages.", isIndented: true, content: [{type: 'chart', generator: 'network_uptime_improvement'}] },
                    'maintenanceCost': { text: "Maintenance costs reduced by <b>42%</b> through predictive maintenance strategies.", tooltip: "Predictive maintenance reduced overall network maintenance costs by 42% by preventing emergency repairs, optimizing maintenance schedules, and extending equipment lifecycles.", isIndented: true, content: [{type: 'chart', generator: 'network_maintenance_cost'}] },
                    'customerExperience': { text: "Customer network satisfaction improved to <b>9.1/10</b> with <b>68%</b> faster issue resolution.", tooltip: "Network optimization resulted in 9.1/10 customer satisfaction scores for network quality, with 68% faster resolution of network-related issues through automated problem-solving.", isIndented: true, content: [{type: 'chart', generator: 'network_customer_experience'}] }
                }
            },
            { // Page '16'
                title: "Revenue Assurance & Fraud Detection Agent",
                dotColor: 'rgb(130, 180, 255)',
                subheadings: {
                    'revenueSystemOverview': { text: "AI system that <b>protects revenue streams</b> and detects fraudulent activities in real-time.", tooltip: "The Revenue Assurance & Fraud Detection Agent uses advanced machine learning to monitor all revenue touchpoints, detect anomalies, prevent fraud, and ensure accurate billing to protect T-Nor's financial integrity.", content: [{type: 'svg', generator: 'revenue_overview'}]},
                    'revenueWorkflow': { text: "The Revenue Protection Workflow:", isCategory: true, content: [{type: 'empty'}] },
                    'transactionMonitoring': { text: "<b>1.</b> <b>Transaction Monitoring Agent</b> - Analyzes all billing and payment transactions in real-time.", tooltip: "Monitors every billing cycle, payment transaction, service activation, and usage record to identify discrepancies, unusual patterns, and potential revenue leakage points.", isIndented: true, content: [{type: 'chart', generator: 'revenue_transaction_monitoring'}] },
                    'fraudDetection': { text: "<b>2.</b> <b>Fraud Detection Agent</b> - Identifies suspicious activities and fraudulent behaviors.", tooltip: "Uses machine learning models to detect SIM box fraud, subscription fraud, premium rate service abuse, identity theft, and other fraudulent activities affecting revenue.", isIndented: true, content: [{type: 'chart', generator: 'revenue_fraud_detection'}] },
                    'revenueAssurance': { text: "<b>3.</b> <b>Revenue Assurance Agent</b> - Ensures accurate billing and prevents revenue leakage.", tooltip: "Continuously audits billing systems, validates usage records, checks pricing accuracy, and identifies configuration errors that could lead to revenue loss.", isIndented: true, content: [{type: 'svg', generator: 'revenue_assurance'}] },
                    'riskScoring': { text: "<b>4.</b> <b>Risk Scoring Agent</b> - Assigns risk scores to customers and transactions.", tooltip: "Evaluates customer behavior patterns, payment history, usage anomalies, and other factors to assign dynamic risk scores for targeted monitoring and fraud prevention.", isIndented: true, content: [{type: 'chart', generator: 'revenue_risk_scoring'}] },
                    'automaticActions': { text: "<b>5.</b> <b>Automated Response Agent</b> - Takes immediate action on detected threats.", tooltip: "Automatically blocks suspicious transactions, suspends fraudulent accounts, alerts security teams, and implements protective measures to minimize revenue impact.", isIndented: true, content: [{type: 'svg', generator: 'revenue_automatic_actions'}] },
                    'recoveryTracking': { text: "<b>6.</b> <b>Recovery & Reporting Agent</b> - Tracks fraud recovery and generates compliance reports.", tooltip: "Manages fraud case investigations, tracks recovery efforts, generates regulatory compliance reports, and provides detailed analytics on fraud trends and prevention effectiveness.", isIndented: true, content: [{type: 'chart', generator: 'revenue_recovery_tracking'}] },
                    'revenueResults': { text: "Revenue Protection Results:", isCategory: true, content: [{type: 'empty'}] },
                    'fraudPrevention': { text: "Prevented <b>$12.3M</b> in potential fraud losses with <b>96%</b> detection accuracy.", tooltip: "The AI fraud detection system prevented $12.3 million in potential fraud losses over 12 months, achieving 96% accuracy in fraud detection with minimal false positives.", isIndented: true, content: [{type: 'chart', generator: 'revenue_fraud_prevention'}] },
                    'revenueRecovery': { text: "Recovered <b>$3.8M</b> in revenue leakage and improved billing accuracy by <b>99.7%</b>.", tooltip: "Revenue assurance processes recovered $3.8 million in previously undetected revenue leakage and improved overall billing accuracy to 99.7% through automated error detection and correction.", isIndented: true, content: [{type: 'chart', generator: 'revenue_recovery'}] },
                    'investigationTime': { text: "Fraud investigation time reduced by <b>78%</b> with automated case management.", tooltip: "Automated fraud detection and case management reduced average fraud investigation time by 78%, enabling faster response to threats and more efficient security operations.", isIndented: true, content: [{type: 'chart', generator: 'revenue_investigation_time'}] }
                }
            },
            { // Page '17'
                title: "Dynamic Pricing & Promotion Optimization Agent",
                dotColor: 'rgb(130, 195, 255)',
                subheadings: {
                    'pricingSystemOverview': { text: "AI system that <b>optimizes pricing strategies</b> and promotions in real-time for maximum profitability.", tooltip: "The Dynamic Pricing & Promotion Agent uses machine learning to analyze market conditions, competitor pricing, customer behavior, and demand patterns to optimize pricing and promotional strategies for maximum revenue and market share.", content: [{type: 'svg', generator: 'pricing_overview'}]},
                    'pricingWorkflow': { text: "The Dynamic Pricing Workflow:", isCategory: true, content: [{type: 'empty'}] },
                    'marketAnalysis': { text: "<b>1.</b> <b>Market Intelligence Agent</b> - Continuously monitors competitor pricing and market conditions.", tooltip: "Analyzes competitor pricing strategies, market trends, economic indicators, and customer price sensitivity to provide real-time market intelligence for pricing decisions.", isIndented: true, content: [{type: 'chart', generator: 'pricing_market_analysis'}] },
                    'demandForecasting': { text: "<b>2.</b> <b>Demand Forecasting Agent</b> - Predicts customer demand for different pricing scenarios.", tooltip: "Uses historical data, seasonal patterns, and external factors to forecast customer demand at various price points, enabling data-driven pricing optimization.", isIndented: true, content: [{type: 'chart', generator: 'pricing_demand_forecasting'}] },
                    'priceOptimization': { text: "<b>3.</b> <b>Price Optimization Agent</b> - Determines optimal prices for maximum revenue and market share.", tooltip: "Employs advanced algorithms to calculate optimal pricing strategies that balance revenue maximization, market share goals, customer acquisition, and competitive positioning.", isIndented: true, content: [{type: 'svg', generator: 'pricing_optimization'}] },
                    'promotionEngine': { text: "<b>4.</b> <b>Promotion Engine Agent</b> - Creates and manages targeted promotional campaigns.", tooltip: "Automatically designs personalized promotions, determines optimal discount levels, sets campaign durations, and targets specific customer segments for maximum campaign effectiveness.", isIndented: true, content: [{type: 'chart', generator: 'pricing_promotion_engine'}] },
                    'abTesting': { text: "<b>5.</b> <b>A/B Testing Agent</b> - Continuously tests pricing strategies and measures impact.", tooltip: "Implements controlled A/B tests for different pricing strategies, measures customer response, conversion rates, and revenue impact to validate and refine pricing decisions.", isIndented: true, content: [{type: 'chart', generator: 'pricing_ab_testing'}] },
                    'elasticityAnalysis': { text: "<b>6.</b> <b>Price Elasticity Agent</b> - Analyzes customer price sensitivity and response patterns.", tooltip: "Continuously analyzes how price changes affect customer behavior, identifies price-sensitive segments, and calculates price elasticity to optimize pricing strategies.", isIndented: true, content: [{type: 'chart', generator: 'pricing_elasticity_analysis'}] },
                    'pricingResults': { text: "Dynamic Pricing Results:", isCategory: true, content: [{type: 'empty'}] },
                    'revenueGrowth': { text: "Revenue increased by <b>18%</b> through optimized pricing strategies and targeted promotions.", tooltip: "Dynamic pricing optimization and targeted promotions resulted in an 18% increase in overall revenue while maintaining competitive market positioning and customer satisfaction.", isIndented: true, content: [{type: 'chart', generator: 'pricing_revenue_growth'}] },
                    'promotionEffectiveness': { text: "Promotion effectiveness improved by <b>45%</b> with <b>73%</b> higher conversion rates.", tooltip: "AI-driven promotional campaigns achieved 45% better effectiveness with 73% higher conversion rates compared to traditional promotional strategies, maximizing promotional ROI.", isIndented: true, content: [{type: 'chart', generator: 'pricing_promotion_effectiveness'}] },
                    'competitivePosition': { text: "Market share increased by <b>12%</b> while maintaining optimal profit margins.", tooltip: "Strategic pricing optimization enabled T-Nor to gain 12% market share while maintaining optimal profit margins through intelligent competitive positioning and value-based pricing.", isIndented: true, content: [{type: 'chart', generator: 'pricing_competitive_position'}] }
                }
            },
            { // Page '18'
                title: "Voice of Customer (VoC) Intelligence Agent",
                dotColor: 'rgb(130, 210, 255)',
                subheadings: {
                    'vocSystemOverview': { text: "AI system that <b>analyzes customer feedback</b> across all touchpoints to drive business improvements.", tooltip: "The Voice of Customer Intelligence Agent aggregates and analyzes customer feedback from calls, surveys, social media, app reviews, and support interactions to provide actionable insights for service improvement and strategic decision-making.", content: [{type: 'svg', generator: 'voc_overview'}]},
                    'vocWorkflow': { text: "The VoC Intelligence Workflow:", isCategory: true, content: [{type: 'empty'}] },
                    'feedbackAggregation': { text: "<b>1.</b> <b>Feedback Aggregation Agent</b> - Collects customer feedback from all touchpoints.", tooltip: "Continuously gathers customer feedback from call recordings, chat transcripts, surveys, app store reviews, social media, and support tickets to create a comprehensive voice of customer dataset.", isIndented: true, content: [{type: 'chart', generator: 'voc_feedback_aggregation'}] },
                    'sentimentMining': { text: "<b>2.</b> <b>Advanced Sentiment Mining Agent</b> - Analyzes emotions and opinions in customer feedback.", tooltip: "Uses advanced NLP and emotion AI to analyze customer sentiment, identify emotional drivers, extract specific pain points, and understand customer satisfaction levels across different touchpoints.", isIndented: true, content: [{type: 'chart', generator: 'voc_sentiment_mining'}] },
                    'themeExtraction': { text: "<b>3.</b> <b>Theme Extraction Agent</b> - Identifies key topics and trends in customer feedback.", tooltip: "Automatically identifies recurring themes, emerging issues, feature requests, and trending topics in customer feedback to highlight areas requiring attention or improvement.", isIndented: true, content: [{type: 'svg', generator: 'voc_theme_extraction'}] },
                    'impactAnalysis': { text: "<b>4.</b> <b>Business Impact Agent</b> - Correlates feedback with business metrics and outcomes.", tooltip: "Analyzes the relationship between customer feedback themes and business metrics like churn, revenue, satisfaction scores, and operational KPIs to prioritize improvement initiatives.", isIndented: true, content: [{type: 'chart', generator: 'voc_impact_analysis'}] },
                    'actionRecommendation': { text: "<b>5.</b> <b>Action Recommendation Agent</b> - Generates specific improvement recommendations.", tooltip: "Provides data-driven recommendations for service improvements, product enhancements, process changes, and strategic initiatives based on customer feedback analysis and business impact assessment.", isIndented: true, content: [{type: 'svg', generator: 'voc_action_recommendation'}] },
                    'closedLoopFeedback': { text: "<b>6.</b> <b>Closed-Loop Feedback Agent</b> - Tracks implementation and measures impact of changes.", tooltip: "Monitors the implementation of recommended improvements, measures their impact on customer satisfaction and business metrics, and provides continuous feedback on the effectiveness of changes.", isIndented: true, content: [{type: 'chart', generator: 'voc_closed_loop_feedback'}] },
                    'vocResults': { text: "VoC Intelligence Results:", isCategory: true, content: [{type: 'empty'}] },
                    'satisfactionImprovement': { text: "Customer satisfaction increased by <b>28%</b> through targeted service improvements.", tooltip: "VoC-driven service improvements resulted in a 28% increase in overall customer satisfaction scores, with significant improvements in network quality, customer service, and billing accuracy.", isIndented: true, content: [{type: 'chart', generator: 'voc_satisfaction_improvement'}] },
                    'issueResolution': { text: "Proactive issue resolution improved by <b>65%</b> with faster identification of problems.", tooltip: "Early detection of customer issues through VoC analysis enabled 65% faster issue resolution, allowing T-Nor to address problems before they escalate and impact large customer segments.", isIndented: true, content: [{type: 'chart', generator: 'voc_issue_resolution'}] },
                    'productInnovation': { text: "Product innovation accelerated with <b>89%</b> of customer-requested features successfully implemented.", tooltip: "VoC insights drove product innovation, with 89% of customer-requested features successfully implemented, resulting in higher customer engagement and competitive differentiation.", isIndented: true, content: [{type: 'chart', generator: 'voc_product_innovation'}] }
                }
            },
{ // Page 19
    title: "AI Adoption Plan for T-Nor",
     dotColor: 'rgb(130, 225, 160)',
    subheadings: {
        'adoption_overview_goal': { 
            text: "The goal is to foster trust, reduce resistance, and build a collaborative future where AI augments human roles.", 
            tooltip: "The AI Adoption Plan for T-Nor focuses on Churn management, employee training, inclusion, and change management. The goal is to foster trust, reduce resistance, and build a collaborative future where AI augments human roles.",
            content: [{type: 'svg', generator: 'adoption_goal_diagram'}] 
        }
    }
},
{ // Page 20
    title: "AI Adoption Plan: Phase 1 & 2",
    dotColor: 'rgb(130, 225, 160)',
    subheadings: {
        'category_phase1': { text: "<b>Phase 1: Awareness and Communication</b>", isCategory: true, content: [{type: 'empty'}] },
        'item_webinars': { 
            text: "• Webinars, and interactive Q&A sessions to explain the purpose of AI integration.", 
            tooltip: "Webinars, and interactive Q&A sessions to explain the purpose of AI integration.",
            isIndented: true, 
            content: [{type: 'svg', generator: 'adoption_comms_diagram'}] 
        },
        'item_message': {
            text: "• <b>Message:</b> AI will not be used to cut headcount but to enhance roles and skill development.",
            tooltip: "Message: AI will not be used to cut headcount but to enhance roles and skill development.",
            isIndented: true,
            content: [{type: 'svg', generator: 'adoption_message_diagram'}]
        },
        'category_phase2': { text: "<b>Phase 2: Collaborate and Plan</b>", isCategory: true, content: [{type: 'empty'}] },
        'item_groups': {
            text: "• Cross-functional AI working groups to identify areas and conduct AI impact assessments.",
            tooltip: "Cross-functional AI working groups including RF Engineers, Technical Support, Network and operations Support, Strategy and Business Development etc. to identify areas and conduct AI impact assessments.",
            isIndented: true,
            content: [{type: 'svg', generator: 'adoption_groups_diagram'}]
        },
        'item_tools': {
            text: "• <b>Tools:</b> Surveys, suggestion boxes, workshops",
            tooltip: "Tools: Surveys, suggestion boxes, workshops",
            isIndented: true,
            content: [{type: 'svg', generator: 'adoption_tools_diagram'}]
        },
        'item_output': {
            text: "• <b>Output:</b> AI task matrix (Human-led, AI-assisted, Fully automated)",
            tooltip: "Output: AI task matrix (Human-led, AI-assisted, Fully automated)",
            isIndented: true,
            content: [{type: 'svg', generator: 'adoption_matrix_diagram'}]
        }
    }
},
{ // Page 21
    title: "AI Adoption Plan: Phase 3 & 4",
    dotColor: 'rgb(130, 225, 160)',
    subheadings: {
        'category_phase3': { text: "<b>Phase 3: Training and Upskilling</b>", isCategory: true, content: [{type: 'empty'}] },
        'item_tiers': {
            text: "• <b>Training Tiers:</b> Includes Basic AI Literacy, Role-Specific Workshops, and Advanced Roles for data teams.",
            tooltip: "Basic AI Literacy: All staff – Understanding what AI is, ethical use, limitations. Role/Tool-Specific Workshops: customized to specific department. Advanced Roles: Data teams – Prompt engineering, ML model interpretation, AI ethics.",
            isIndented: true,
            content: [{type: 'svg', generator: 'adoption_training_pyramid'}]
        },
        'item_incentives': {
            text: "• <b>Incentives:</b> Badges, promotions, or bonuses tied to upskilling.",
            tooltip: "Incentives: Badges, promotions, or bonuses tied to upskilling.",
            isIndented: true,
            content: [{type: 'svg', generator: 'adoption_incentives_diagram'}]
        },
        'category_phase4': { text: "<b>Phase 4: Pilot and Feedback</b>", isCategory: true, content: [{type: 'empty'}] },
        'item_agenting': {
            text: "• Agenting AIs, Chatbots and Voicebots (Regional, Urdu, English)",
            tooltip: "Agenting AIs, Chatbots and Voicebots (Regional, Urdu, English)",
            isIndented: true,
            content: [{type: 'svg', generator: 'intervention_chatbots'}]
        },
        'item_anomalies': {
            text: "• Anomalies detections, Issuing commands, Automate FAQs, billing, subscriptions",
            tooltip: "Anomalies detections, Issuing commands, Automate FAQs, billing, subscriptions",
            isIndented: true,
            content: [{type: 'svg', generator: 'pilot_tasks_diagram'}]
        },
        'item_trigger_service': {
            text: "• Trigger service adjustments.",
            tooltip: "Trigger service adjustments.",
            isIndented: true,
            content: [{type: 'svg', generator: 'intervention_adjustments'}]
        }
    }
},
{ // Page 22
    title: "AI Adoption Plan: Phase 5 & Sustainability",
    dotColor: 'rgb(130, 225, 160)',
    subheadings: {
        'category_phase5': { text: "<b>Phase 5: Integrate and scale up.</b>", isCategory: true, content: [{type: 'empty'}] },
        'item_integrate': {
            text: "• Integrate successful tools across departments with clear governance structures.",
            tooltip: "Integrate successful tools across departments with clear governance structures.",
            isIndented: true,
            content: [{type: 'svg', generator: 'adoption_scale_diagram'}]
        },
        'item_hitl': {
            text: "• Develop a Human-in-the-Loop (HITL) framework: AI suggestions always require human approval.",
            tooltip: "Develop a Human-in-the-Loop (HITL) framework: AI suggestions always require human approval.",
            isIndented: true,
            content: [{type: 'svg', generator: 'adoption_hitl_diagram'}]
        },
        'item_iterative': {
            text: "• Continue iterative training to adapt to newer tools and evolving workflows.",
            tooltip: "Continue iterative training to adapt to newer tools and evolving workflows.",
            isIndented: true,
            content: [{type: 'svg', generator: 'sustain_training_diagram'}]
        },
        'item_sustainability': {
            text: "• <b>Monitoring and Sustainability:</b> Regular audits to check for bias, job erosion, or overdependence on AI.",
            tooltip: "Monitoring and Sustainability: Regular audits to check for bias, job erosion, or overdependence on AI.",
            isIndented: true,
            content: [{type: 'svg', generator: 'adoption_sustain_diagram'}]
        }
    }
},
{ // Page 23
    title: "Next Steps for the Idea Factory Team",
     dotColor: 'rgb(245, 255, 120)',
    subheadings: {
        'next_analyze': { 
            text: "<b>1. Analyze:</b> The team will analyze feedback from the initial pitch and market research.", 
            tooltip: "The first step is to thoroughly analyze all feedback gathered from the pitch process, as well as initial market research and diagnostic findings, to identify strengths and areas for improvement.",
            content: [{type: 'svg', generator: 'nextsteps_analyze'}] 
        },
        'next_refine': {
            text: "<b>2. Refine:</b> Refine the value proposition, service blueprints, and engagement model.",
            tooltip: "Based on the analysis, the team will refine the core value proposition, polish the service blueprints for each intervention, and optimize the overall client engagement model for maximum impact and clarity.",
            content: [{type: 'svg', generator: 'nextsteps_refine'}]
        },
        'next_simulation': {
            text: "<b>3. Prepare for Simulation:</b> Conduct internal dry-runs and pressure-test the pitch.",
            tooltip: "The team will prepare for a full-scale client simulation by conducting multiple internal dry-runs of the refined pitch. This includes pressure-testing the proposal against different potential client objections and questions.",
            content: [{type: 'svg', generator: 'nextsteps_simulation'}]
        },
        'next_catalog': {
            text: "<b>4. The Solution Catalog:</b> Finalize a comprehensive catalog of AI services.",
            tooltip: "'The Solution Catalog' is a complete portfolio of services with Vertical Deep Dives (e.g., AI for Telecom) and Horizontal Applications (e.g., Churn Prediction for any industry).",
            content: [{type: 'svg', generator: 'nextsteps_catalog'}]
        }
    }
}
        ];
        
        const createChart = (container, config) => { const canvas = document.createElement('canvas'); container.appendChild(canvas); const chart = new Chart(canvas.getContext('2d'), config); currentCharts.push(chart); return canvas; };
        const mediaGenerators = { 
            // All generators are complete and restored here
            // Add this inside your existing const mediaGenerators = { ... }
jacquardLoom: function(p) {
    // Initial state: A simple alternating pattern
    let currentCard = [1, 0, 1, 0, 1, 0, 1, 0]; 
    let weaveHistory = [];
    
    // Layout Configuration
    const cardStartX = 60;
    const cardY = 80;
    const holeSpacing = 30;
    const holeSize = 20;
    
    const fabricStartX = 60;
    const fabricStartY = 220;
    const fabricCellSize = 30;
    
    // Button Configuration
    let btn = { x: 60, y: 140, w: 180, h: 40 };

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
        p.cursor(p.ARROW);
    };

    p.draw = function() {
        p.background(233); // Matches pane background

        // --- SECTION 1: THE INPUT (Punch Card) ---
        p.noStroke();
        p.fill(50);
        p.textSize(14);
        p.textAlign(p.LEFT);
        p.text("1. PUNCH YOUR CODE (CLICK HOLES)", 60, 40);

        // Draw Card Background
        p.fill(210, 180, 140);
        p.rect(cardStartX - 20, cardY - 30, (currentCard.length * holeSpacing) + 40, 60, 5);

        // Draw Interactive Holes
        p.textAlign(p.CENTER);
        for(let i = 0; i < currentCard.length; i++) {
            let x = cardStartX + (i * holeSpacing);
            
            // Visual Logic: Black = Hole (1/On), Card Color = Solid (0/Off)
            if(currentCard[i] === 1) {
                p.fill(30); // Hole
                p.stroke(255, 50);
            } else {
                p.fill(180, 150, 110); // Solid
                p.stroke(100);
            }
            p.ellipse(x, cardY, holeSize, holeSize);
            
            // Binary Label below hole
            p.noStroke();
            p.fill(80);
            p.textSize(10);
            p.text(currentCard[i], x, cardY + 25);
        }

        // --- SECTION 2: THE ACTION (Button) ---
        // distinct hover effect
        if (p.mouseX > btn.x && p.mouseX < btn.x + btn.w && 
            p.mouseY > btn.y && p.mouseY < btn.y + btn.h) {
            p.fill(0, 100, 230); // Darker blue on hover
            p.cursor(p.HAND);
        } else {
            p.fill(0, 123, 255); // Standard Blue
            p.cursor(p.ARROW);
        }
        
        p.rect(btn.x, btn.y, btn.w, btn.h, 5);
        p.fill(255);
        p.textSize(14);
        p.text("WEAVE THIS ROW  ⬇", btn.x + btn.w/2, btn.y + btn.h/2);

        // --- SECTION 3: THE OUTPUT (Fabric) ---
        p.fill(50);
        p.textAlign(p.LEFT);
        p.text("2. WOVEN FABRIC HISTORY", 60, 200);

        // Draw the fabric grid
        for(let r = 0; r < weaveHistory.length; r++) {
            let rowData = weaveHistory[r];
            let y = fabricStartY + (r * fabricCellSize);
            
            // Stop drawing if we run off canvas
            if (y > p.height - 20) break;

            for(let c = 0; c < rowData.length; c++) {
                let x = fabricStartX + (c * fabricCellSize);
                
                // FABRIC LOGIC:
                // 1 (Hole) = Warp thread lifted (Blue)
                // 0 (Solid) = Warp thread down (Weft Color / Grey)
                if(rowData[c] === 1) {
                    p.fill(0, 123, 255); 
                } else {
                    p.fill(200); 
                }
                p.stroke(255);
                p.rect(x, y, fabricCellSize, fabricCellSize);
            }
        }
    };

    p.mousePressed = function() {
        // 1. Check for HOLE clicks (Toggle Bits)
        for(let i = 0; i < currentCard.length; i++) {
            let x = cardStartX + (i * holeSpacing);
            let d = p.dist(p.mouseX, p.mouseY, x, cardY);
            if(d < holeSize) {
                currentCard[i] = currentCard[i] === 1 ? 0 : 1;
                return; // Stop checking
            }
        }

        // 2. Check for BUTTON click (Weave Row)
        if (p.mouseX > btn.x && p.mouseX < btn.x + btn.w && 
            p.mouseY > btn.y && p.mouseY < btn.y + btn.h) {
            
            // Add a COPY of the current card to the history
            // We use unshift to put the newest row at the top (visually correct for a loom growing downwards)
            weaveHistory.unshift([...currentCard]);
            
            // Limit history length to prevent performance issues
            if(weaveHistory.length > 20) weaveHistory.pop();
        }
    };

    p.windowResized = function() {
        p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
    };
},
jacquardBinary: function(p) {
    let currentCard = [1, 0, 1, 0, 1, 0, 1, 0]; 
    let weaveHistory = [];
    
    // Layout
    const cardStartX = 50, cardY = 80, holeSpacing = 35;
    let btn = { x: 50, y: 150, w: 200, h: 40 };

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(233); 
        
        // 1. Title
        p.fill(50); p.noStroke(); p.textSize(16); p.textAlign(p.LEFT);
        p.text("STEP 1: ENCODE THE DESIGN (THE 'SOFTWARE')", 50, 40);

        // 2. Punch Card Interface
        p.fill(210, 180, 140);
        p.rect(cardStartX - 20, cardY - 30, (currentCard.length * holeSpacing) + 40, 60, 5);

        for(let i = 0; i < currentCard.length; i++) {
            let x = cardStartX + (i * holeSpacing);
            // Visual feedback: Hole vs Solid
            if(currentCard[i] === 1) { p.fill(30); p.stroke(255, 100); } 
            else { p.fill(190, 160, 120); p.stroke(100); }
            p.ellipse(x, cardY, 25, 25);
            
            p.noStroke(); p.fill(80); p.textSize(12);
            p.text(currentCard[i], x, cardY + 45); // 1 or 0 label
        }

        // 3. The Button
        if (p.mouseX > btn.x && p.mouseX < btn.x + btn.w && p.mouseY > btn.y && p.mouseY < btn.y + btn.h) {
            p.fill(0, 100, 230); p.cursor(p.HAND);
        } else {
            p.fill(0, 123, 255); p.cursor(p.ARROW);
        }
        p.rect(btn.x, btn.y, btn.w, btn.h, 5);
        p.fill(255); p.text("EXECUTE BINARY ROW ⬇", btn.x + btn.w/2, btn.y + btn.h/2);

        // 4. Fabric Output
        p.fill(50); p.textAlign(p.LEFT);
        p.text("OUTPUT (WOVEN MEMORY)", 50, 230);
        
        let cellSize = 30;
        for(let r = 0; r < weaveHistory.length; r++) {
            for(let c = 0; c < weaveHistory[r].length; c++) {
                if(weaveHistory[r][c] === 1) p.fill(0, 123, 255); 
                else p.fill(200);
                p.stroke(255);
                p.rect(50 + (c * cellSize), 250 + (r * cellSize), cellSize, cellSize);
            }
        }
    };

    p.mousePressed = function() {
        // Toggle Holes
        for(let i = 0; i < currentCard.length; i++) {
            let x = cardStartX + (i * holeSpacing);
            if(p.dist(p.mouseX, p.mouseY, x, cardY) < 15) {
                currentCard[i] = currentCard[i] === 1 ? 0 : 1;
                return;
            }
        }
        // Button Click
        if (p.mouseX > btn.x && p.mouseX < btn.x + btn.w && p.mouseY > btn.y && p.mouseY < btn.y + btn.h) {
            weaveHistory.unshift([...currentCard]);
            if(weaveHistory.length > 8) weaveHistory.pop();
        }
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
jacquardMechanism: function(p) {
    let frameCount = 0;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(233);
        frameCount++;
        
        let phase = Math.sin(frameCount * 0.05); // Animation cycle
        let isPushing = phase > 0; // Card pushing against rods
        
        // Title
        p.fill(50); p.noStroke(); p.textAlign(p.LEFT); p.textSize(16);
        p.text("THE MECHANISM: PHYSICAL LOGIC GATE", 50, 40);

        // --- DRAW TWO EXAMPLES: HOLE vs SOLID ---
        
        // 1. Example A: HOLE (Bit 1) -> ROD PASSES -> HOOK LIFTS
        drawMechanismUnit(p, 100, 100, true, isPushing, "HOLE (1) = LIFT");

        // 2. Example B: SOLID (Bit 0) -> ROD BLOCKED -> HOOK STAYS
        drawMechanismUnit(p, 350, 100, false, isPushing, "SOLID (0) = DROP");
    };

    function drawMechanismUnit(p, x, y, hasHole, isPushing, label) {
        p.push();
        p.translate(x, y);
        
        // 1. The Card
        p.fill(210, 180, 140); p.noStroke();
        let cardX = isPushing ? 40 : 0; // Animation movement
        p.rect(cardX, 50, 20, 100); 
        if(hasHole) { p.fill(50); p.rect(cardX + 5, 90, 10, 20); } // Draw hole
        
        // 2. The Spring-Loaded Rod (Needle)
        p.stroke(100); p.strokeWeight(4);
        let rodX = 80; 
        let rodPushed = !hasHole && isPushing; // If solid card pushes, rod moves back
        if(rodPushed) rodX += 20; 
        
        p.line(rodX, 100, rodX + 100, 100); // The horizontal rod
        
        // 3. The Vertical Hook (Warp Thread Control)
        let hookLifted = hasHole && isPushing; // Only lifts if hole allows rod to stay put
        let hookY = hookLifted ? -40 : 0; 
        
        p.stroke(0, 123, 255); // Blue thread
        p.line(rodX + 80, 100 + hookY, rodX + 80, 300); // Vertical thread
        
        // 4. Labels
        p.noStroke(); p.fill(80); p.textSize(12);
        p.text(label, 60, 320);
        
        p.pop();
    }
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
jacquardSoftware: function(p) {
    let cards = [
        [1,1,1,1,0,0,0,0], // Pattern A
        [1,1,0,0,1,1,0,0], // Pattern B
        [1,0,1,0,1,0,1,0], // Pattern C
        [0,0,0,0,1,1,1,1]  // Pattern D
    ];
    let cardIndex = 0;
    let lastSwitch = 0;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(233);
        
        // Timer to auto-play pattern
        if(p.millis() - lastSwitch > 1000) {
            cardIndex = (cardIndex + 1) % cards.length;
            lastSwitch = p.millis();
        }

        // Title
        p.fill(50); p.noStroke(); p.textAlign(p.LEFT); p.textSize(16);
        p.text("STORED PROGRAM: AUTOMATED WEAVING", 50, 40);

        // 1. Draw the "Chain" of cards
        let activeCard = cards[cardIndex];
        
        p.push();
        p.translate(100, 100);
        
        // Previous Card (Fading out)
        p.fill(210, 180, 140, 100);
        p.rect(0, -60, 200, 40);
        
        // ACTIVE CARD
        p.fill(210, 180, 140);
        p.rect(0, 0, 200, 60);
        p.fill(50); p.text("CURRENT INSTRUCTION", 100, -15);
        
        for(let i=0; i<activeCard.length; i++) {
            p.fill(activeCard[i] === 1 ? 50 : 200); // Hole vs Solid
            p.ellipse(25 + (i*20), 30, 15, 15);
        }
        
        // Next Card (Incoming)
        p.fill(210, 180, 140, 100);
        p.rect(0, 80, 200, 40);
        
        p.pop();

        // 2. Draw Resulting Pattern
        p.fill(50); p.text("OUTPUT", 400, 80);
        let cellSize = 20;
        for(let i=0; i<activeCard.length; i++) {
             // If 1, show Blue (Thread Up), If 0 show Grey
             if(activeCard[i] === 1) p.fill(0, 123, 255);
             else p.fill(200);
             p.rect(360 + (i * cellSize), 100, cellSize, 100);
        }
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
           
           
            'nextsteps_analyze/': (c) => { 
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:11px; text-anchor:middle;}
            .item{opacity:0; animation:pop 0.5s ease-out forwards;}
            @keyframes pop{from{transform:scale(0)} to{transform:scale(1)}}
            .line{stroke-dasharray:100; stroke-dashoffset:100; animation:draw 0.5s forwards;}
            @keyframes draw{to{stroke-dashoffset:0}}
        </style>
        <g class="item" style="animation-delay:0.2s;">
            <rect x="40" y="40" width="80" height="50" fill="#ccc" rx="5"/>
            <text class="f" x="80" y="105">Pitch Feedback</text>
        </g>
        <g class="item" style="animation-delay:0.4s;">
            <rect x="40" y="110" width="80" height="50" fill="#ccc" rx="5"/>
            <text class="f" x="80" y="175">Market Research</text>
        </g>
        <path class="line" d="M120 65 H 170" stroke="#333" style="animation-delay:0.6s;"/>
        <path class="line" d="M120 135 H 170" stroke="#333" style="animation-delay:0.8s;"/>
        <g class="item" style="animation-delay:1.0s;">
            <path d="M180,80 l30,-20 l30,20 l-15,30z" fill="var(--accent-color)"/>
            <text class="f" fill="white" x="210" y="100">Analysis</text>
        </g>
        <path class="line" d="M240 100 H 290" stroke="#333" style="animation-delay:1.2s;"/>
        <g class="item" style="animation-delay:1.4s;">
            <rect x="290" y="75" width="80" height="50" fill="#5cb85c" rx="5"/>
            <text class="f" fill="white" x="330" y="105">Insights</text>
        </g>
    </svg>`;
    return c;
},
        'nextsteps_refine': (c) => {
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:11px; text-anchor:middle;}
            .shape{fill:#ccc; animation:refine 2s 1s ease-in-out forwards;}
            .sparkle{opacity:0; animation:spark 0.5s 3s forwards;}
            @keyframes refine{
                0%{fill:#ccc; d:path("M150 100 L 180 50 L 220 50 L 250 100 L 220 150 L 180 150 Z");}
                100%{fill:var(--accent-color); d:path("M200 40 L 150 100 L 200 160 L 250 100 Z");}
            }
            @keyframes spark{ 0%{opacity:1;transform:scale(1);} 100%{opacity:0;transform:scale(0);} }
        </style>
        <text class="f" x="100" y="105">Rough Concept</text>
        <path class="shape" d="M150 100 L 180 50 L 220 50 L 250 100 L 220 150 L 180 150 Z"/>
        <text class="f" x="300" y="105">Refined Solution</text>
        <path class="sparkle" fill="gold" d="M200 30 l -5 5 l 5 5 l 5 -5z"/>
        <path class="sparkle" style="animation-delay:3.1s;" fill="gold" d="M260 100 l -5 5 l 5 5 l 5 -5z"/>
        <path class="sparkle" style="animation-delay:3.2s;" fill="gold" d="M140 100 l -5 5 l 5 5 l 5 -5z"/>
    </svg>`;
    return c;
},
        'nextsteps_simulation': (c) => {
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:11px; text-anchor:middle;}
            .item{opacity:0; animation:fade 0.5s ease-out forwards;}
            @keyframes fade{to{opacity:1;}}
        </style>
        <g class="item">
            <circle cx="80" cy="100" r="15" fill="var(--accent-color)"/>
            <circle cx="120" cy="100" r="15" fill="var(--accent-color)"/>
            <text class="f" x="100" y="135">Idea Factory Team</text>
        </g>
        <rect x="200" y="40" width="160" height="120" fill="#333" rx="5" class="item" style="animation-delay:0.3s;"/>
        <text class="f item" fill="white" x="280" y="60" style="animation-delay:0.5s;">Client Simulation</text>
        <g class="item" style="animation-delay:1.0s;">
            <circle cx="280" cy="100" r="20" fill="#ccc"/>
            <text class="f" x="280" y="105" font-size="20">?</text>
            <text class="f" x="280" y="135">Client Questions</text>
        </g>
        <g class="item" style="animation-delay:1.5s;">
            <path d="M150 90 c 20 -30, 80 -30, 100 0" stroke="gold" stroke-width="2" fill="none"/>
            <path d="M140 100 l10-10 h-10z" fill="gold"/>
            <text class="f" x="200" y="55">Answers</text>
        </g>
    </svg>`;
    return c;
},
        'nextsteps_catalog': (c) => {
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:11px; text-anchor:middle;}
            .page{transform-origin:left; animation:turn 1s ease-out 0.5s forwards;}
            .item{opacity:0; animation:fade 0.5s ease-out forwards;}
            @keyframes turn{from{transform:perspective(500px) rotateY(0deg);} to{transform:perspective(500px) rotateY(-160deg);}}
            @keyframes fade{to{opacity:1;}}
        </style>
        <text class="f" x="200" y="25" style="font-weight:bold;">The Solution Catalog</text>
        <rect x="80" y="40" width="240" height="150" fill="#f0f0f0" rx="5"/>
        <text class="f item" style="animation-delay:1.5s;" x="200" y="70" font-weight="bold">Horizontals</text>
        <text class="f item" style="animation-delay:1.7s;" x="200" y="90">(Churn, NLP, etc.)</text>
        <g class="page">
            <rect x="80" y="40" width="120" height="150" fill="var(--accent-color)" rx="5"/>
            <text class="f item" fill="white" x="140" y="70" font-weight="bold">Verticals</text>
            <text class="f item" fill="white" x="140" y="90">(Telecom)</text>
            <text class="f item" fill="white" x="140" y="110">(Banking)</text>
        </g>
    </svg>`;
    return c;
},
            'adoption_sustain_diagram': (c) => { 
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:11px; text-anchor:middle;}
            .item{opacity:0; animation:pop 0.5s ease-out forwards;}
            @keyframes pop{from{transform:scale(0)} to{transform:scale(1)}}
            
            /* The path the dot will follow */
            #motion-path { fill: none; stroke: #ccc; stroke-width: 2; }
            
            /* The moving dot */
            .flow-dot {
                fill: var(--accent-color);
                offset-path: path("M200,40 A60,60 0 1,1 199.9,40"); /* Defines the circular motion path */
                animation: move 4s linear infinite;
                opacity: 0;
            }
            @keyframes move {
                0% { motion-offset: 0%; opacity: 1; }
                90% { opacity: 1; }
                100% { motion-offset: 100%; opacity: 0; }
            }
        </style>

        <path id="motion-path" d="M200,40 A60,60 0 1,1 199.9,40"/>
        
        <circle class="flow-dot" r="5"/>

        <g class="item" style="animation-delay:0.2s;">
            <circle cx="200" cy="40" r="15" fill="#f0f0f0"/>
            <text class="f" x="200" y="20">Regular Audits</text>
        </g>
        <g class="item" style="animation-delay:0.5s;">
            <circle cx="120" cy="130" r="15" fill="#f0f0f0"/>
            <text class="f" x="120" y="160">Check for Bias</text>
        </g>
        <g class="item" style="animation-delay:0.8s;">
            <circle cx="280" cy="130" r="15" fill="#f0f0f0"/>
            <text class="f" x="280" y="160">Monitor Job Erosion</text>
        </g>
    </svg>`;
    return c; 
},
            'pilot_tasks_diagram': (c) => { 
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font:bold 11px var(--font-family);text-anchor:middle;}
            .node{fill:#ccc;}
            .anomaly{animation:flash 1s infinite;}
            @keyframes flash{50%{fill:red;}}
            .item{opacity:0; animation:fade 0.5s ease-out forwards;}
            @keyframes fade{to{opacity:1;}}
        </style>
        <text class="f item" x="95" y="30">Anomaly Detection</text>
        <g class="item">
            <path d="M50 100 L 75 125 L 100 100 L 125 125 L 150 100 M75 75 L 87.5 87.5 L 112.5 87.5 L 125 75" stroke="#ccc" fill="none"/>
            <circle class="node" cx="50" cy="100" r="8"/><circle class="node" cx="75" cy="125" r="8"/>
            <circle class="node" cx="100" cy="100" r="8"/><circle class="node anomaly" cx="125" cy="125" r="8"/>
            <circle class="node" cx="150" cy="100" r="8"/><circle class="node" cx="75" cy="75" r="8"/>
            <circle class="node" cx="125" cy="75" r="8"/>
        </g>
        <line x1="200" y1="20" x2="200" y2="180" stroke="#eee"/>
        <text class="f item" x="300" y="30" style="animation-delay:0.5s;">Automated Tasks</text>
        <g class="item" style="animation-delay:0.5s;">
            <path d="M280 80 h20 v20 h-10 l-5-5 v-10 l-5 0z" fill="var(--accent-color)"/>
            <text class="f" x="300" y="125">AI</text>
        </g>
        <g class="item" style="animation-delay:1.0s;">
            <text class="f" x="250" y="70">FAQs</text>
            <text class="f" x="350" y="70">Billing</text>
            <text class="f" x="250" y="160">Commands</text>
            <text class="f" x="350" y="160">Subscriptions</text>
        </g>
    </svg>`; 
    return c; 
},
            'adoption_incentives_diagram': (c) => { 
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font:bold 12px var(--font-family);text-anchor:middle;}
            .item{opacity:0; animation:pop 0.5s ease-out forwards;}
            @keyframes pop{from{transform:scale(0)} to{transform:scale(1)}}
            .line{stroke-dasharray:100; stroke-dashoffset:100; animation:draw 0.5s forwards;}
            @keyframes draw{to{stroke-dashoffset:0}}
        </style>
        <g class="item">
            <rect x="160" y="80" width="80" height="40" fill="var(--accent-color)" rx="5"/>
            <text class="f" fill="white" x="200" y="105">Upskilling</text>
        </g>
        <path class="line" d="M200 80 L 150 40" stroke="#ccc" style="animation-delay:0.5s;"/>
        <g class="item" style="animation-delay:0.8s;">
            <path d="M150 10 l -15 15 l 15 15 l 15-15z" fill="gold"/>
            <text class="f" x="100" y="30">Badges</text>
        </g>
        <g>
            <path class="line" d="M240 100 H 300" stroke="#ccc" style="animation-delay:1.0s;"/>
            <g class="item" style="animation-delay:1.3s;">
                <path d="M310 80 v10 h-15 v15 h15 v10 l10-17.5z" fill="orange"/>
                <text class="f" x="315" y="130">Promotions</text>
            </g>
        </g>
        <g>
            <path class="line" d="M200 120 L 150 160" stroke="#ccc" style="animation-delay:1.5s;"/>
            <g class="item" style="animation-delay:1.8s;">
                <circle cx="150" cy="180" r="15" fill="limegreen"/>
                <text class="f" x="100" y="185">Bonuses</text>
            </g>
        </g>
    </svg>`; 
    return c; 
},
            'intervention_adjustments': (c) => { 
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:11px; text-anchor:middle;}
            .item{opacity:0; animation:fade 0.5s 0.5s forwards;}
            @keyframes fade{to{opacity:1;}}
            .line{stroke-dasharray:300; stroke-dashoffset:300; animation:draw 2s 1s ease-in-out forwards;}
            @keyframes draw{to{stroke-dashoffset:0;}}
            .switch-bg{fill:#ccc; transition:fill 0.5s;}
            .switch-btn{fill:white; transform:translateX(0); transition:transform 0.5s;}
            .switch.on .switch-bg{fill:#5cb85c;}
            .switch.on .switch-btn{transform:translateX(20px);}
            .switch{animation:flip 0.5s 3s forwards;}
            @keyframes flip{to{transform:scale(1);}} /* dummy to trigger transition */
        </style>
        <text class="f" x="200" y="30" style="font-weight:bold;">Automatic Service Adjustment</text>
        <g class="item">
            <path d="M100,80 l30,-20 l30,20 l-15,30z" fill="var(--accent-color)"/>
            <text class="f" x="130" y="125">AI Monitor</text>
        </g>
        <path class="line" d="M30 100 H 100 C 120 100, 130 50, 150 50 S 180 150, 200 100 H 370" stroke="#ccc" stroke-width="2" fill="none"/>
        <g class="item" style="animation-delay:2.5s;">
            <g class="switch">
                <rect class="switch-bg" x="280" y="80" width="50" height="30" rx="15"/>
                <circle class="switch-btn" cx="295" cy="95" r="12"/>
            </g>
            <text class="f" x="305" y="130">Adjust Service</text>
        </g>
    </svg>`;
    return c; 
},
            'focal_churn_dashboard': (c) => { 
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color);}
            .bg{fill: #f0f0f0; stroke: #ccc; stroke-width:1;}
            .title{font-size:14px; font-weight:bold; text-anchor:middle;}
            .label{font-size:10px;}
            .value{font-size:16px; font-weight:bold; fill: #d9534f;}
            .item{opacity:0; animation:fadeInUp 0.5s ease-out forwards;}
            @keyframes fadeInUp{ from{opacity:0; transform:translateY(15px);} to{opacity:1; transform:translateY(0);} }
        </style>
        <rect class="bg" x="10" y="10" width="380" height="180" rx="10"/>
        <text class="f title" x="200" y="35">Churn Prediction Dashboard</text>
        <path d="M50 80 H 150" stroke="#ccc" stroke-width="15" stroke-linecap="round"/>
        <path id="gauge" d="M50 80 H 125" stroke="#d9534f" stroke-width="15" stroke-linecap="round" style="stroke-dasharray: 100; stroke-dashoffset: 100; animation: drawGauge 1s 0.5s ease-out forwards;"/>
        @keyframes drawGauge{to{stroke-dashoffset: 25;}}
        <text class="f label" x="100" y="65" text-anchor="middle">Predicted Monthly Churn</text>
        <text class="f value" x="100" y="110" text-anchor="middle">7.5%</text>

        <line x1="180" y1="50" x2="180" y2="180" stroke="#ccc"/>
        <text class="f label" x="280" y="65" text-anchor="middle">High-Risk Segments</text>
        <g class="item" style="animation-delay: 1.0s;">
            <rect x="200" y="80" width="160" height="25" fill="#fff"/>
            <text class="f label" x="205" y="96">1. Low Data Usage</text>
        </g>
        <g class="item" style="animation-delay: 1.2s;">
            <rect x="200" y="110" width="160" height="25" fill="#fff"/>
            <text class="f label" x="205" y="126">2. Frequent Call Drops</text>
        </g>
        <g class="item" style="animation-delay: 1.4s;">
            <rect x="200" y="140" width="160" height="25" fill="#fff"/>
            <text class="f label" x="205" y="156">3. Inactive for 15+ Days</text>
        </g>
    </svg>`;
    return c;
},
        'focal_experience_journey': (c) => {
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:10px; text-anchor:middle;}
            .path{stroke-dasharray:500; stroke-dashoffset:500; animation:drawPath 2s ease-out 0.5s forwards;}
            @keyframes drawPath{to{stroke-dashoffset:0;}}
            .node{opacity:0; animation:popIn 0.5s ease-out forwards;}
            @keyframes popIn{from{transform:scale(0);} to{transform:scale(1);}}
            .face{font-size:14px; animation:changeFace 1s ease-out forwards;}
            @keyframes changeFace{0%{fill:orange;} 100%{fill:green;}}
        </style>
        <path class="path" d="M40 100 C 100 50, 150 150, 200 100 S 300 50, 360 100" stroke="#ccc" stroke-width="2" fill="none"/>
        <g class="node" style="animation-delay:0.8s;">
            <circle cx="40" cy="100" r="15" fill="#fff" stroke="var(--accent-color)" stroke-width="2"/>
            <text class="f face">😐</text><text class="f" y="30">App</text>
        </g>
        <g class="node" transform="translate(125, 93)" style="animation-delay:1.2s;">
            <circle r="15" fill="#fff" stroke="var(--accent-color)" stroke-width="2"/>
            <text class="f face" style="animation-delay:1.2s;">🙂</text><text class="f" y="-20">Store</text>
        </g>
        <g class="node" transform="translate(200, 100)" style="animation-delay:1.6s;">
            <circle r="15" fill="#fff" stroke="var(--accent-color)" stroke-width="2"/>
            <text class="f face" style="animation-delay:1.6s;">😊</text><text class="f" y="30">Call Center</text>
        </g>
        <g class="node" transform="translate(360, 100)" style="animation-delay:2.0s;">
            <circle r="20" fill="gold"/>
            <text class="f" style="font-size:8px; font-weight:bold;">CSAT: 9/10</text>
        </g>
    </svg>`;
    return c;
},
        'focal_network_map': (c) => {
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:10px;}
            .land{fill:#dcedc8; stroke:#a5d6a7;}
            .tower{fill:green; transition: fill 0.5s;}
            .scanner{opacity:0; animation:scan 3s ease-in-out 0.5s forwards;}
            @keyframes scan{
                0%{opacity:1; transform:translateX(0);} 
                50%{transform:translateX(100px);} 
                100%{opacity:0; transform:translateX(200px);}
            }
            .fault{animation:flash 2s 1.5s infinite;}
            @keyframes flash{50%{fill:gold;}}
            .team{opacity:0; animation:dispatch 2s ease-out 2.5s forwards;}
            @keyframes dispatch{to{opacity:1; transform:translate(120px, -20px);}}
        </style>
        <path class="land" d="M100 20 L 150 10 L 200 40 L 280 30 L 320 80 L 290 150 L 200 180 L 120 160 L 80 100 Z"/>
        <circle class="tower" cx="160" cy="50" r="5"/>
        <circle class="tower fault" id="faulty-tower" cx="240" cy="90" r="5"/>
        <circle class="tower" cx="180" cy="140" r="5"/>
        <circle class="tower" cx="260" cy="150" r="5"/>
        <path class="scanner" d="M150 0 L 130 200" stroke="rgba(0,123,255,0.5)" stroke-width="4"/>
        <g class="team">
            <rect x="50" y="100" width="20" height="15" fill="orange" rx="3"/>
            <text class="f" x="45" y="130">Maint. Team</text>
        </g>
    </svg>`;
    return c;
},
        'focal_marketing_funnel': (c) => {
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:10px; text-anchor:middle;}
            .item{opacity:0; animation:fadeIn 0.5s forwards;}
            @keyframes fadeIn{to{opacity:1;}}
            .cust{animation:fall 2s linear forwards; fill:#ccc;}
            @keyframes fall{
                from{transform:translateY(0); opacity:1;}
                to{transform:translateY(110px); opacity:0;}
            }
            .filtered{fill:var(--accent-color); animation-delay:0.1s;}
        </style>
        <text class="f item" x="200" y="20">Personalization Funnel</text>
        <path d="M100 30 L 150 160 H 250 L 300 30 Z" fill="#f0f0f0"/>
        
        <circle class="cust" cx="150" cy="40" r="5"/>
        <circle class="cust filtered" cx="175" cy="40" r="5"/>
        <circle class="cust" cx="200" cy="40" r="5"/>
        <circle class="cust filtered" cx="225" cy="40" r="5"/>
        <circle class="cust" cx="250" cy="40" r="5"/>
        
        <g class="item" style="animation-delay:2.2s;">
            <rect x="150" y="165" width="100" height="25" fill="gold" rx="5"/>
            <text class="f" x="200" y="180" style="font-weight:bold;">Targeted Offer</text>
        </g>
    </svg>`;
    return c;
},
        'focal_loyalty_ladder': (c) => {
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:10px;}
            .step{opacity:0; animation:build 0.5s ease-out forwards;}
            @keyframes build{from{transform:translateY(20px);opacity:0;} to{transform:translateY(0);opacity:1;}}
            .climber{animation:climb 3s ease-in-out 2s forwards;}
            @keyframes climb{
                0%{transform:translate(0,0);} 
                33%{transform:translate(60px,-40px);}
                66%{transform:translate(120px,-80px);}
                100%{transform:translate(180px,-120px);}
            }
        </style>
        <g class="step" style="animation-delay:0.2s;">
            <rect x="50" y="160" width="80" height="20" fill="#cd7f32"/>
            <text class="f" x="70" y="174" fill="white">Bronze</text>
        </g>
        <g class="step" style="animation-delay:0.4s;">
            <rect x="110" y="120" width="80" height="20" fill="#c0c0c0"/>
            <text class="f" x="135" y="134">Silver</text>
        </g>
        <g class="step" style="animation-delay:0.6s;">
            <rect x="170" y="80" width="80" height="20" fill="#ffd700"/>
            <text class="f" x="195" y="94">Gold</text>
        </g>
        <g class="step" style="animation-delay:0.8s;">
            <rect x="230" y="40" width="80" height="20" fill="#e5e4e2"/>
            <text class="f" x="250" y="54">Platinum</text>
        </g>
        <g class="climber">
            <circle cx="80" cy="150" r="8" fill="var(--accent-color)"/>
            <path d="M 80 142 a 10 10 0 0 0 0 -12" fill="none" stroke="var(--accent-color)" stroke-width="2"/>
        </g>
    </svg>`;
    return c;
},
            // CHART: This generator follows the single-line convention as its configuration object is simple.
            'client_history_diagram': (c) => { return createChart(c, {type:'line',data:{labels:['2005 (Launch)','2006','2007 (Price Wars)','2008'],datasets:[{label:'Market Position & Revenue',data:[50,80,45,40],borderColor:'#ff6384',backgroundColor:'rgba(255,99,132,0.2)',fill:true,tension:0.1}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Initial Success Followed by Price Wars'}}}}); },

// SVG: This generator is formatted for readability, which is best practice for complex SVG/HTML.
            'client_problem_diagram': (c) => { 
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font:bold 12px var(--font-family); text-anchor:middle;}
            .item{animation:fade-in 0.5s ease-out forwards; opacity:0;}
            @keyframes fade-in{to{opacity:1;}}
            .arrow{animation:drop 1s ease-in forwards; transform-origin:center;}
            @keyframes drop{from{transform:translateY(-20px);opacity:0;} to{transform:translateY(0);opacity:1;}}
        </style>
        <g class="item">
            <text class="f" x="80" y="60">ARPU</text>
            <path class="arrow" d="M80 70 L 80 140 L 70 130 M 80 140 L 90 130" stroke="red" stroke-width="3" fill="none"/>
        </g>
        <g class="item" style="animation-delay:0.5s;">
            <circle cx="200" cy="100" r="25" fill="#ccc"/>
            <path d="M200 80 L 230 100 L 200 120" stroke="var(--main-text-color)" fill="none" stroke-width="3"/>
            <text class="f" x="200" y="150">Subscriber Churn</text>
        </g>
        <g class="item" style="animation-delay:1s;">
            <rect x="290" y="70" width="80" height="60" rx="5" fill="rgba(255,99,132,0.8)"/>
            <text class="f" fill="white" x="330" y="95">RED</text>
            <text class="f" fill="white" x="330" y="115">FLAG</text>
        </g>
    </svg>`; 
    return c; 
},

// CHART: This generator also follows the single-line convention.
        'client_market_diagram': (c) => { return createChart(c, {type:'doughnut',data:{labels:['Prepaid (PAYG)','Postpaid'],datasets:[{data:[95,5],backgroundColor:['#36a2eb','#c9cbcf'],borderColor:'var(--pane-bg-right)',borderWidth:4}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Market Context: 95% Prepaid'}}}}); },

// SVG: This more complex SVG is also formatted for best-practice readability.
        'client_need_diagram': (c) => { 
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font:bold 12px var(--font-family); text-anchor:middle;}
            .item{animation:fade-in 1s ease-out forwards; opacity:0;}
            @keyframes fade-in{to{opacity:1;}}
            .line{stroke-dasharray: 200; stroke-dashoffset: 200; animation: draw 2s ease-out 1s forwards;}
            @keyframes draw{to{stroke-dashoffset:0;}}
            .risk{animation:pulse 1.5s infinite alternate; fill:red;}
            @keyframes pulse{to{opacity:0.3;}}
        </style>
        <g transform="translate(50, 50)" class="item">
            <circle cx="0" cy="50" r="30" fill="rgba(0,123,255,0.2)"/>
            <circle cx="0" cy="50" r="10" fill="var(--accent-color)"/>
            <path d="M-25 25 L 25 75 M-25 75 L 25 25" stroke="var(--accent-color)" stroke-width="2"/>
            <text class="f" x="0" y="110">Predictability</text>
        </g>
        <path class="line" d="M120 100 C 180 120, 220 60, 280 80 S 350 130, 380 100" stroke="#ccc" stroke-width="3" fill="none"/>
        <path class="line" d="M120 100 C 180 100, 220 100, 380 100" stroke="var(--accent-color)" stroke-width="2" fill="none" stroke-dasharray="5 5" style="animation-delay:1.5s;"/>
        <circle class="risk" cx="255" cy="70" r="8" style="opacity:0; animation-delay:2s;"/>
        <text class="f" x="255" y="60" style="opacity:0; animation:fade-in 1s 2s forwards;">Risk</text>
    </svg>`; 
    return c; 
},
'roadmap_phase1_diagnose': (c) => { 
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:11px;}
            .item, .line{opacity:0; animation:fade-in 0.5s ease-out forwards;}
            .check{stroke-dasharray:50; stroke-dashoffset:50; animation:draw 0.5s ease-out forwards;}
            @keyframes fade-in{to{opacity:1;}} @keyframes draw{to{stroke-dashoffset:0;}}
        </style>
        <text class="f" x="100" y="30" text-anchor="middle" style="font-weight:bold;">Diagnostic Toolkit</text>
        <rect x="30" y="40" width="140" height="130" fill="#f0f0f0" rx="5" class="item"/>
        <text class="f item" x="40" y="60" style="animation-delay:0.2s;">✓ Churn</text>
        <text class="f item" x="40" y="80" style="animation-delay:0.4s;">✓ Customer Exp.</text>
        <text class="f item" x="40" y="100" style="animation-delay:0.6s;">✓ Network Health</text>
        <text class="f item" x="40" y="120" style="animation-delay:0.8s;">✓ Marketing</text>
        <text class="f item" x="40" y="140" style="animation-delay:1.0s;">✓ Loyalty</text>
        <g class="item" style="animation-delay:1.2s;">
            <path d="M240 70 h80 v80 h-80z M240 90 h80 M240 110 h80 M240 130 h80" fill="#ccc" stroke="#333" stroke-width="0.5"/>
            <text class="f" x="280" y="60" text-anchor="middle">Data Infrastructure</text>
        </g>
        <path class="line" d="M170 105 H 240" stroke="#333" stroke-width="2" style="animation-delay:1.4s;"/>
        <path class="check" d="M260 95 l10 10 l20 -20" stroke="var(--accent-color)" stroke-width="4" fill="none" style="animation-delay:1.6s;"/>
    </svg>`;
    return c;
},
'roadmap_phase2_pilot': (c) => {
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:11px; text-anchor:middle;}
            .cust{fill:#ccc; animation:flow 2s ease-in-out forwards;}
            .at-risk{fill:red;}
            @keyframes flow{
                from{transform:translateX(0); opacity:1;} 
                to{transform:translateX(140px); opacity:0;}
            }
            .item{opacity:0; animation:pop 1s 2s ease-out forwards;}
            @keyframes pop{from{transform:scale(0)} to{transform:scale(1)}}
        </style>
        <text class="f" x="80" y="40">Pilot Group</text>
        <circle class="cust" cx="80" cy="80" r="8"/>
        <circle class="cust at-risk" cx="60" cy="100" r="8" style="animation-delay:0.1s;"/>
        <circle class="cust" cx="100" cy="100" r="8" style="animation-delay:0.2s;"/>
        <circle class="cust at-risk" cx="80" cy="120" r="8" style="animation-delay:0.3s;"/>
        <rect x="150" y="70" width="100" height="60" fill="var(--accent-color)" rx="5"/>
        <text class="f" x="200" y="105" fill="white" style="font-size:10px;">AI Churn Model</text>
        <g class="item" transform="translate(320, 100)">
            <path d="M0 -30 L -15 -10 H 15 Z" fill="#FFC107"/>
            <rect x="-10" y="-10" width="20" height="25" fill="#FFC107"/>
            <text class="f" y="30">Pilot Success</text>
        </g>
    </svg>`;
    return c;
},
'roadmap_phase3_scale': (c) => {
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f { font-family: var(--font-family); fill: var(--main-text-color); font-size: 11px; text-anchor: middle; }
            
            /* The pilot circle that expands and fades */
            .pilot-group { animation: expand 1.5s ease-out 0.5s forwards; transform-origin: center; }
            @keyframes expand {
                0% { transform: scale(1); opacity: 1; }
                100% { transform: scale(5); opacity: 0; }
            }

            /* The full-scale elements that fade in */
            .full-base { opacity: 0; animation: fadeIn 1s ease-out 1.5s forwards; }
            @keyframes fadeIn { to { opacity: 1; } }

            /* The arrows that draw and fade in */
            .arrow { opacity: 0; animation: fadeIn 1s 2.5s forwards; marker-end: url(#head); }
        </style>
        
        <defs>
            <marker id="head" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--accent-color)"/>
            </marker>
        </defs>

        <g class="pilot-group">
            <circle cx="200" cy="100" r="20" fill="var(--accent-color)" opacity="0.8"/>
            <text class="f" x="200" y="135">Pilot</text>
        </g>
        
        <g class="full-base">
            <rect x="80" y="40" width="240" height="100" rx="10" fill="rgba(0,123,255,0.2)"/>
            <text class="f" x="200" y="85">Full Scale Rollout to</text>
            <text class="f" x="200" y="105" style="font-weight:bold;">Entire Subscriber Base</text>
            
            <path class="arrow" d="M120 140 v 25 h -20"/>
            <text class="f arrow" x="100" y="180">Marketing</text>
            
            <path class="arrow" d="M280 140 v 25 h 20"/>
            <text class="f arrow" x="300" y="180">Retention</text>
        </g>
    </svg>`;
    return c;
},
'roadmap_phase4_sustain': (c) => {
    c.innerHTML = `<svg viewBox="0 0 400 200">
        <style>
            .f{font-family:var(--font-family); fill:var(--main-text-color); font-size:11px; text-anchor:middle;}
            .item{opacity:0; animation:pop 0.5s ease-out forwards;}
            @keyframes pop{from{transform:scale(0)} to{transform:scale(1)}}
            .flow-arrow{transform-origin:center; animation:rotate 8s linear infinite;}
            @keyframes rotate{to{transform:rotate(360deg);}}
        </style>
        <g class="item">
            <circle cx="200" cy="100" r="30" fill="#f0f0f0"/>
            <path d="M190 90 h20 v25 l-20 -5z M195 80 l10-10 l-10 0z" fill="var(--accent-color)"/>
            <text class="f" x="200" y="125" style="font-weight:bold;">T-Nor Team</text>
        </g>
        <g class="flow-arrow">
            <path d="M200,30 A 70 70 0 0 1 270,100" fill="none" stroke="#ccc" stroke-width="2"/>
            <path d="M270,100 L 260 95 L 265 105 Z" fill="#ccc"/>
            <text class="f item" x="255" y="55" style="animation-delay:0.5s;">Manage Models</text>
        </g>
        <g class="flow-arrow" style="transform:rotate(120deg);">
             <path d="M200,30 A 70 70 0 0 1 270,100" fill="none" stroke="#ccc" stroke-width="2"/>
            <path d="M270,100 L 260 95 L 265 105 Z" fill="#ccc"/>
            <text class="f item" transform="rotate(-120)" x="-145" y="155" style="animation-delay:0.8s;">Gather Data</text>
        </g>
         <g class="flow-arrow" style="transform:rotate(240deg);">
             <path d="M200,30 A 70 70 0 0 1 270,100" fill="none" stroke="#ccc" stroke-width="2"/>
            <path d="M270,100 L 260 95 L 265 105 Z" fill="#ccc"/>
            <text class="f item" transform="rotate(-240)" x="-105" y="-195" style="animation-delay:1.1s;">Continuously Optimize</text>
        </g>
    </svg>`;
    return c;
},
analyticalArchitecture: function(p) {
    let state = 0; // 0=Idle, 1=Fetch, 2=Process, 3=Store
    let t = 0;
    
    // Schematic Layout
    let storeX = 100, millX = 450, yBase = 150;
    
    // Data objects
    let valA = { val: 5, label: "VAR 1" };
    let valB = { val: 3, label: "VAR 2" };
    let accumulator = 0;

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
        p.textFont('Segoe UI');
    };

    p.draw = function() {
        p.background(233); // Matches pane background

        // --- ZONES ---
        // Store Zone
        p.noStroke();
        p.fill(220, 220, 230);
        p.rect(20, 20, 200, p.height - 40, 10);
        p.fill(80, 80, 100);
        p.textSize(16); p.text("THE STORE (MEMORY)", 120, 50);
        
        // Mill Zone
        p.fill(230, 220, 220);
        p.rect(350, 20, 200, p.height - 40, 10);
        p.fill(100, 80, 80);
        p.text("THE MILL (CPU)", 450, 50);

        // --- DRAW COLUMNS ---
        drawColumn(p, storeX, yBase, valA.val, valA.label);
        drawColumn(p, storeX, yBase + 120, valB.val, valB.label);
        
        // Draw Accumulator in Mill
        p.fill(255); p.stroke(100); p.strokeWeight(2);
        p.circle(millX, yBase + 60, 100);
        p.noStroke(); p.fill(0); p.textSize(24);
        p.text(accumulator, millX, yBase + 60);
        p.textSize(12); p.text("ACCUMULATOR", millX, yBase + 125);

        // --- ANIMATION ---
        if(state === 1) { // FETCH
            let curX = p.lerp(storeX, millX, t);
            let curY1 = p.lerp(yBase, yBase + 60, t);
            let curY2 = p.lerp(yBase + 120, yBase + 60, t);
            
            drawPacket(p, curX, curY1, valA.val);
            drawPacket(p, curX, curY2, valB.val);
            
            t += 0.02;
            if(t >= 1) { state = 2; t = 0; accumulator = valA.val + valB.val; }
            
            p.fill(0); p.text("FETCHING DATA...", p.width/2, p.height - 50);
        }
        else if(state === 2) { // PROCESS
            p.push();
            p.translate(millX, yBase + 60);
            p.rotate(p.frameCount * 0.2);
            p.noFill(); p.stroke(0, 123, 255); p.strokeWeight(3);
            p.arc(0, 0, 110, 110, 0, 5); // Spinning ring
            p.pop();
            
            t += 0.02;
            if(t >= 1) { state = 0; t = 0; } // End cycle for simplicity
            
            p.noStroke(); p.fill(0, 123, 255); 
            p.text("PROCESSING (ADDITION)", p.width/2, p.height - 50);
        }
        else {
            // Idle State Button
            let btnW = 160, btnH = 40;
            let btnX = p.width/2 - btnW/2, btnY = 350;
            
            if(p.mouseX > btnX && p.mouseX < btnX+btnW && p.mouseY > btnY && p.mouseY < btnY+btnH) {
                p.fill(0, 100, 230); p.cursor(p.HAND);
            } else {
                p.fill(0, 123, 255); p.cursor(p.ARROW);
            }
            p.rect(btnX, btnY, btnW, btnH, 5);
            p.fill(255); p.textSize(14); p.text("EXECUTE CYCLE", p.width/2, btnY + 20);
            
            // Reset accumulator visually after a while
            if(accumulator > 0 && p.frameCount % 200 === 0) accumulator = 0;
        }
    };

    p.mousePressed = function() {
        if(state === 0 && p.mouseX > p.width/2 - 80 && p.mouseX < p.width/2 + 80 && p.mouseY > 350 && p.mouseY < 390) {
            state = 1; t = 0; accumulator = 0;
        }
    };

    function drawColumn(p, x, y, val, label) {
        p.fill(200); p.stroke(100); p.strokeWeight(1);
        p.rect(x - 20, y - 30, 40, 60); // Column body
        p.fill(255); p.rect(x - 15, y - 10, 30, 20); // Value window
        p.fill(0); p.noStroke(); p.textSize(14); p.text(val, x, y + 2);
        p.textSize(12); p.text(label, x, y - 40);
    }
    
    function drawPacket(p, x, y, val) {
        p.fill(255, 200, 0); p.noStroke();
        p.circle(x, y, 25);
        p.fill(0); p.text(val, x, y);
    }
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},analyticalGears: function(p) {
    let angle = 0;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
        p.angleMode(p.DEGREES);
    };

    p.draw = function() {
        p.background(233);
        
        // Instructions
        p.fill(50); p.noStroke(); 
        p.textSize(16); p.text("THE MILL: PHYSICAL CALCULATION", p.width/2, 40);
        p.textSize(12); p.fill(100);
        p.text("Drag horizontal to rotate the Driver Gear", p.width/2, 65);

        p.translate(p.width/2, p.height/2);

        // 1. DRIVER GEAR (Input)
        p.push();
        p.translate(-90, 0);
        p.rotate(angle);
        drawGear(p, 70, 10, [100, 150, 250]);
        p.pop();
        
        // 2. RESULT GEAR (Output)
        // Rotates opposite direction
        p.push();
        p.translate(70, 0);
        p.rotate(-angle);
        drawGear(p, 70, 10, [100, 200, 100]);
        p.pop();
        
        // 3. Labels
        p.resetMatrix();
        p.fill(0); p.textSize(14);
        p.text("DRIVER (INPUT)", p.width/2 - 90, p.height/2 + 90);
        p.text("RESULT (OUTPUT)", p.width/2 + 70, p.height/2 + 90);
        
        // Calculation Display
        let value = Math.floor((Math.abs(angle) % 360) / 36);
        p.textSize(24); p.fill(0, 100, 0);
        p.text("CURRENT VALUE: " + value, p.width/2, p.height - 50);
    };

    function drawGear(p, r, teeth, color) {
        p.fill(color); p.stroke(50); p.strokeWeight(1);
        p.circle(0, 0, r*2);
        
        // Teeth
        p.fill(80); p.noStroke();
        for(let i=0; i<360; i+=360/teeth) {
            let x = (r - 5) * p.cos(i);
            let y = (r - 5) * p.sin(i);
            p.circle(x, y, 8);
        }
        
        // Indicator Line
        p.stroke(255); p.strokeWeight(3);
        p.line(0, 0, r-10, 0);
        p.noStroke(); p.fill(0); p.circle(0,0, 10);
    }

    p.mouseDragged = function() {
        // Simple drag logic
        angle += (p.mouseX - p.pmouseX);
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},analyticalCycle: function(p) {
    let particles = [];
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(233);
        
        // Spawn particles
        if(p.frameCount % 50 === 0) {
            particles.push({x: 50, y: 150, active: true});
        }
        
        // --- DRAW FLOWCHART ---
        p.stroke(150); p.strokeWeight(2);
        p.line(100, 150, 500, 150); // Main timeline
        
        // Input Node
        drawNode(p, 100, 150, "INPUT\n(CARDS)", [220, 180, 140]);
        // Process Node
        drawNode(p, 300, 150, "THE MILL\n(PROCESS)", [200, 200, 220]);
        // Output Node
        drawNode(p, 500, 150, "OUTPUT\n(PRINTER)", [180, 220, 180]);
        
        // Feedback Loop Line
        p.noFill(); p.stroke(150, 150, 200); p.strokeWeight(2);
        p.beginShape();
        p.vertex(500, 180);
        p.vertex(500, 250);
        p.vertex(300, 250);
        p.vertex(300, 190);
        p.endShape();
        p.fill(150); p.noStroke(); 
        p.triangle(300, 190, 295, 200, 305, 200); // Arrow head
        p.text("ITERATIVE LOOP", 400, 240);

        // --- ANIMATE PARTICLES ---
        for(let i=particles.length-1; i>=0; i--) {
            let pt = particles[i];
            
            p.fill(0, 123, 255); p.noStroke();
            p.circle(pt.x, pt.y, 12);
            
            pt.x += 2;
            
            // Interaction at Mill
            if(pt.x > 260 && pt.x < 340) {
                pt.y = 150 + Math.sin(pt.x * 0.2) * 10; // "Processing" wave
            } else {
                pt.y = 150;
            }
            
            if(pt.x > 550) particles.splice(i, 1);
        }
    };
    
    function drawNode(p, x, y, label, color) {
        p.fill(color); p.stroke(100); p.strokeWeight(2);
        p.rectMode(p.CENTER);
        p.rect(x, y, 90, 70, 10);
        p.fill(0); p.noStroke(); p.textSize(12);
        p.text(label, x, y);
    }
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
tubePhysics: function(p) {
    let electrons = [];
    let gridVoltage = 0; // Controlled by mouse

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(20); // Dark background for "Glowing" look
        
        // Interaction: Mouse Y controls Grid Voltage (Up = Open/Positive, Down = Closed/Negative)
        gridVoltage = p.map(p.mouseY, p.height, 0, -5, 5, true);
        
        // 1. Draw The Tube Glass
        p.noFill(); p.stroke(100, 100, 150); p.strokeWeight(2);
        p.rect(p.width/2 - 60, 50, 120, 300, 40);
        
        // 2. Anode (Top Plate)
        p.fill(200); p.noStroke(); p.rect(p.width/2 - 40, 60, 80, 20);
        p.fill(255); p.text("ANODE (+)", p.width/2, 40);

        // 3. Cathode (Bottom Filament)
        p.stroke(255, 100, 0); p.strokeWeight(4);
        p.line(p.width/2 - 30, 300, p.width/2 + 30, 300);
        p.fill(255, 100, 0, 100); p.noStroke();
        p.circle(p.width/2, 300, 40 + p.random(-2, 2)); // Heat glow
        p.fill(255); p.text("HEATED CATHODE (-)", p.width/2, 330);

        // 4. The Grid (Control Valve)
        let gridColor = gridVoltage > 0 ? p.color(0, 255, 0) : p.color(255, 0, 0);
        p.stroke(gridColor); p.strokeWeight(4);
        p.drawingContext.setLineDash([10, 10]);
        p.line(p.width/2 - 50, 180, p.width/2 + 50, 180);
        p.drawingContext.setLineDash([]);
        
        p.fill(gridColor); p.noStroke();
        p.text(gridVoltage > 0 ? "GRID OPEN" : "GRID CLOSED", p.width/2, 160);

        // 5. Electron Simulation
        if (p.frameCount % 2 === 0) {
            electrons.push({x: p.width/2 + p.random(-20, 20), y: 300, vy: -2});
        }
        
        for (let i = electrons.length - 1; i >= 0; i--) {
            let e = electrons[i];
            
            // Grid Physics
            if (e.y < 180 && e.y > 170 && gridVoltage < 0) {
                e.vy *= -0.5; // Bounce back if grid is negative
            }
            
            e.y += e.vy;
            
            p.fill(0, 200, 255); p.noStroke();
            p.circle(e.x, e.y, 6);
            
            if (e.y < 60 || e.y > 350) electrons.splice(i, 1);
        }
        
        // Instructions
        p.fill(150);
        p.text("MOVE MOUSE UP/DOWN TO CONTROL THE GRID VOLTAGE", p.width/2, p.height - 30);
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},logicGateVis: function(p) {
    let inputA = false;
    let inputB = false;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(233);
        
        // Inputs
        drawSwitch(p, 100, 100, inputA, "INPUT A");
        drawSwitch(p, 100, 250, inputB, "INPUT B");
        
        // Wire Lines
        p.stroke(100); p.strokeWeight(3);
        p.line(160, 100, 300, 100); // A to Logic
        p.line(160, 250, 300, 250); // B to Logic
        
        // LOGIC ZONE
        p.noStroke(); p.fill(50);
        p.text("LOGIC GATE EXAMPLES", 400, 50);

        // AND Gate Result
        let andResult = inputA && inputB;
        drawBulb(p, 400, 100, andResult, "AND GATE\n(Needs Both)");
        
        // OR Gate Result
        let orResult = inputA || inputB;
        drawBulb(p, 400, 250, orResult, "OR GATE\n(Needs Either)");

        p.fill(100);
        p.text("CLICK SWITCHES TO TOGGLE INPUTS", p.width/2, p.height - 30);
    };
    
    p.mousePressed = function() {
        if(p.dist(p.mouseX, p.mouseY, 100, 100) < 30) inputA = !inputA;
        if(p.dist(p.mouseX, p.mouseY, 100, 250) < 30) inputB = !inputB;
    };

    function drawSwitch(p, x, y, state, label) {
        p.fill(state ? [0, 200, 0] : [200, 0, 0]);
        p.stroke(50); p.strokeWeight(2);
        p.rectMode(p.CENTER);
        p.rect(x, y, 60, 40, 5);
        p.fill(255); p.noStroke();
        p.text(state ? "1 (ON)" : "0 (OFF)", x, y);
        p.fill(0); p.text(label, x, y - 40);
    }
    
    function drawBulb(p, x, y, state, label) {
        p.fill(state ? [255, 255, 0] : [50]);
        p.stroke(0); p.strokeWeight(1);
        p.circle(x, y, 50);
        if(state) { // Glow effect
            p.drawingContext.shadowBlur = 20;
            p.drawingContext.shadowColor = "orange";
            p.circle(x, y, 50);
            p.drawingContext.shadowBlur = 0;
        }
        p.fill(0); p.noStroke();
        p.text(label, x + 80, y);
    }
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},binaryAdder: function(p) {
    let inA = 0;
    let inB = 0;
    
    // Layout coords
    let xIn = 80, xGate = 250, xOut = 450;
    let yTop = 100, yBot = 250;

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
        p.textFont('Courier New'); // Monospace for code feel
    };

    p.draw = function() {
        p.background(30); // Dark tech background
        
        // --- 1. INPUTS ---
        drawBinaryInput(p, xIn, yTop, inA, "A");
        drawBinaryInput(p, xIn, yBot, inB, "B");
        
        // --- 2. WIRES (The Flow) ---
        p.noFill(); p.strokeWeight(3);
        
        // Wire A splits to XOR and AND
        p.stroke(inA ? [0, 255, 0] : [100]); 
        p.line(xIn + 30, yTop, xGate - 40, yTop); // To XOR
        p.line(xIn + 30, yTop, xIn + 80, yTop); 
        p.line(xIn + 80, yTop, xIn + 80, yBot + 40); // Drop down
        p.line(xIn + 80, yBot + 40, xGate - 40, yBot + 40); // To AND

        // Wire B splits to XOR and AND
        p.stroke(inB ? [0, 255, 0] : [100]);
        p.line(xIn + 30, yBot, xGate - 40, yBot); // To AND (actually bottom gate)
        p.line(xIn + 30, yBot, xIn + 60, yBot);
        p.line(xIn + 60, yBot, xIn + 60, yTop + 40); // Go Up
        p.line(xIn + 60, yTop + 40, xGate - 40, yTop + 40); // To XOR

        // --- 3. GATES ---
        
        // XOR GATE (Calculates SUM)
        // Logic: 1 if inputs are different
        let sum = inA ^ inB; 
        drawGateShape(p, xGate, yTop + 20, "XOR", [100, 100, 255]);
        
        // AND GATE (Calculates CARRY)
        // Logic: 1 if both inputs are 1
        let carry = inA & inB;
        drawGateShape(p, xGate, yBot + 20, "AND", [255, 100, 100]);

        // --- 4. OUTPUTS ---
        
        // Sum Output
        p.stroke(sum ? [0, 255, 0] : [100]);
        p.line(xGate + 40, yTop + 20, xOut, yTop + 20);
        drawOutputLamp(p, xOut + 40, yTop + 20, sum, "SUM (1s Digit)");

        // Carry Output
        p.stroke(carry ? [0, 255, 0] : [100]);
        p.line(xGate + 40, yBot + 20, xOut, yBot + 20);
        drawOutputLamp(p, xOut + 40, yBot + 20, carry, "CARRY (2s Digit)");
        
        // --- 5. THE MATH EXPLANATION ---
        p.fill(255); p.noStroke(); p.textSize(20);
        let total = inA + inB;
        let binaryStr = total.toString(2).padStart(2, '0');
        p.text(`CALCULATION: ${inA} + ${inB} = ${total} (Binary: ${binaryStr})`, p.width/2, p.height - 50);
        
        p.textSize(12); p.fill(150);
        p.text("CLICK INPUTS TO TOGGLE 0/1", p.width/2, p.height - 20);
    };

    p.mousePressed = function() {
        if(p.dist(p.mouseX, p.mouseY, xIn, yTop) < 30) inA = inA ? 0 : 1;
        if(p.dist(p.mouseX, p.mouseY, xIn, yBot) < 30) inB = inB ? 0 : 1;
    };

    function drawBinaryInput(p, x, y, val, label) {
        p.fill(val ? [0, 255, 0] : [50]);
        p.stroke(255); p.strokeWeight(2);
        p.circle(x, y, 50);
        p.fill(val ? 0 : 255); p.noStroke();
        p.textSize(24); p.text(val, x, y + 8);
        p.textSize(14); p.fill(200); p.text(label, x - 40, y);
    }
    
    function drawGateShape(p, x, y, label, color) {
        p.fill(color); p.stroke(255); p.strokeWeight(2);
        p.rectMode(p.CENTER);
        p.rect(x, y, 80, 60, 10);
        p.fill(255); p.noStroke();
        p.textSize(16); p.text(label, x, y);
    }
    
    function drawOutputLamp(p, x, y, val, label) {
        p.fill(val ? [0, 255, 0] : [30, 30, 30]);
        p.stroke(100); p.strokeWeight(2);
        p.circle(x, y, 40);
        if(val) { // Glow
            p.drawingContext.shadowBlur = 30;
            p.drawingContext.shadowColor = "#00FF00";
            p.circle(x, y, 40);
            p.drawingContext.shadowBlur = 0;
        }
        p.fill(200); p.noStroke(); p.textSize(12);
        p.text(label, x, y - 40);
    }
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
rippleAdder: function(p) {
    // 8-bit inputs (Index 0 is LSB/Rightmost)
    let A = [0, 0, 0, 0, 0, 0, 0, 0];
    let B = [0, 0, 0, 0, 0, 0, 0, 0];
    
    // Layout Config
    // We need to fit 8 blocks, so we start further right and reduce spacing
    let startX = p.windowWidth * 0.55; 
    let spacing = 55; 
    let yA = 80, yB = 250;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
        p.textFont('monospace');
    };

    p.draw = function() {
        p.background(30);
        
        let carry = 0;
        
        // --- DRAW THE ADDER CHAIN (Right to Left) ---
        for(let i=0; i<8; i++) {
            let x = startX - (i * spacing);
            let bitVal = Math.pow(2, i);
            
            // 1. Calculate Full Adder Logic
            let sum = A[i] ^ B[i] ^ carry;
            let nextCarry = (A[i] & B[i]) | (carry & (A[i] ^ B[i]));
            
            // 2. Draw Connections (Wires)
            p.strokeWeight(2); // Thinner wires for 8-bit
            
            // Input Wires
            p.stroke(A[i] ? [0,255,0] : [60]); p.line(x, yA + 20, x, 130);
            p.stroke(B[i] ? [0,255,0] : [60]); p.line(x, yB - 20, x, 190);
            
            // Carry Wire (The "Ripple")
            if(i < 7) {
                p.stroke(nextCarry ? [255,200,0] : [60]); 
                p.line(x - 20, 160, x - spacing + 20, 160);
            }
            
            // 3. Draw The Full Adder Block
            p.fill(50); p.stroke(150); p.strokeWeight(1);
            p.rectMode(p.CENTER);
            p.rect(x, 160, 40, 60, 4); // Smaller blocks
            
            // 4. Draw Input Toggles
            drawBitToggle(p, x, yA, A[i]);
            drawBitToggle(p, x, yB, B[i]);
            
            // 5. Draw Sum Output (LED)
            drawOutputLED(p, x, 220, sum);
            
            // Label place value (1, 2, 4, 8...)
            p.fill(150); p.noStroke(); p.textSize(10);
            p.text(bitVal, x, 160); 

            carry = nextCarry;
        }
        
        // --- FINAL CARRY OUT (Overflow) ---
        if(carry) {
            let xFinal = startX - (8 * spacing) + 30;
            drawOutputLED(p, xFinal, 160, 1);
            p.fill(255, 100, 100); p.text("OVERFLOW", xFinal, 190);
        }

        // --- EXPLANATION TEXT ---
        let decA = parseInt([...A].reverse().join(''), 2);
        let decB = parseInt([...B].reverse().join(''), 2);
        let total = decA + decB;
        
        

        p.fill(255); p.textSize(18);
        p.text(`8-BIT CALCULATION: ${decA} + ${decB} = ${total}`, p.width/2, 30);
        
        p.fill(150); p.textSize(12);
        p.text("CLICK INPUTS TO TOGGLE BITS", p.width/2, p.height - 20);
    };

    p.mousePressed = function() {
        for(let i=0; i<8; i++) {
            let x = startX - (i * spacing);
            if(p.dist(p.mouseX, p.mouseY, x, yA) < 15) A[i] = A[i] ? 0 : 1;
            if(p.dist(p.mouseX, p.mouseY, x, yB) < 15) B[i] = B[i] ? 0 : 1;
        }
    };

    function drawBitToggle(p, x, y, val) {
        p.fill(val ? [0,200,0] : [200,0,0]); p.stroke(200); p.strokeWeight(1);
        p.circle(x, y, 20); // Smaller toggle buttons
        p.fill(255); p.noStroke(); p.textSize(10); p.text(val, x, y);
    }
    
    function drawOutputLED(p, x, y, val) {
        p.fill(val ? [0,100,255] : [30]); p.stroke(80);
        p.circle(x, y, 15); // Smaller LEDs
        if(val) { p.drawingContext.shadowBlur=10; p.drawingContext.shadowColor="#0066FF"; p.circle(x, y, 15); p.drawingContext.shadowBlur=0; }
    }
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},

byteConverter: function(p) {
    // 8 bits, initialized to 0
    let byte = [0, 0, 0, 0, 0, 0, 0, 0];
    let placeValues = [128, 64, 32, 16, 8, 4, 2, 1];
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(233);
        
        let total = 0;
        let equation = "";
        
        // --- DRAW 8 SWITCHES ---
        let startX = 60;
        let spacing = (p.width - 120) / 7;
        let y = 150;
        
        for(let i=0; i<8; i++) {
            let x = startX + (i * spacing);
            let isActive = byte[i] === 1;
            
            // 1. Draw Connection Line (if active)
            if(isActive) {
                p.stroke(0, 123, 255); p.strokeWeight(3);
                p.line(x, y, p.width/2, 280); // Line to total
                total += placeValues[i];
            }
            
            // 2. The Place Value Label (Top)
            p.noStroke(); p.fill(80); p.textSize(14);
            p.text(placeValues[i], x, y - 50);
            
            // 3. The Switch
            p.stroke(50); p.strokeWeight(1);
            p.fill(isActive ? [0, 123, 255] : [200]);
            p.rectMode(p.CENTER);
            p.rect(x, y, 40, 60, 5);
            
            // Toggle Lever graphic
            p.fill(255);
            let toggleY = isActive ? y - 15 : y + 15;
            p.rect(x, toggleY, 30, 20, 2);
            
            // Binary Label (0 or 1)
            p.fill(0); p.textSize(16);
            p.text(byte[i], x, y + 45);
        }
        
        // --- DRAW RESULT ---
        p.fill(50); p.noStroke();
        p.textSize(20); p.text("DECIMAL VALUE", p.width/2, 290);
        
        
        
        p.textSize(60); p.fill(0, 123, 255);
        p.text(total, p.width/2, 350);
        
        // ASCII Character Preview (Bonus context)
        if(total > 32 && total < 127) {
            p.textSize(16); p.fill(100);
            p.text(`ASCII CHARACTER: "${String.fromCharCode(total)}"`, p.width/2, 400);
        }

        // Instructions
        p.fill(100); p.textSize(12);
        p.text("CLICK SWITCHES TO CONVERT BINARY TO DECIMAL", p.width/2, 40);
    };

    p.mousePressed = function() {
        let startX = 60;
        let spacing = (p.width - 120) / 7;
        let y = 150;
        
        for(let i=0; i<8; i++) {
            let x = startX + (i * spacing);
            // Hitbox for switch
            if(p.mouseX > x - 25 && p.mouseX < x + 25 && p.mouseY > y - 40 && p.mouseY < y + 40) {
                byte[i] = byte[i] === 1 ? 0 : 1;
            }
        }
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
gateAND: function(p) {
    let sensorActive = false;
    let barrierClosed = false;
    let angle = 0;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(233);
        
        // --- 1. THE SCULPTURE (Output) ---
        p.push();
        p.translate(p.width/2, 120);
        
        // Logic: Both must be true
        let isRunning = sensorActive && barrierClosed;
        
        if(isRunning) {
            angle += 0.1; // Spin!
            p.fill(0, 123, 255); // Active Blue
        } else {
            p.fill(100); // Inactive Grey
        }
        
        // Draw Kinetic Blades
        p.noStroke();
        p.rotate(angle);
        for(let i=0; i<4; i++) {
            p.rotate(p.PI/2);
            p.ellipse(0, -40, 20, 80);
        }
        p.fill(50); p.circle(0,0, 20); // Axle
        p.pop();
        
        // Label
        p.fill(50); p.noStroke(); p.textSize(16);
        p.text(isRunning ? "SCULPTURE: ACTIVE (1)" : "SCULPTURE: OFF (0)", p.width/2, 220);

        // --- 2. INPUT A: MOTION SENSOR ---
        let x1 = p.width/2 - 120, y1 = 300;
        
        // Draw "Eye" Sensor
        p.fill(sensorActive ? [0,255,0] : [50]); p.stroke(100); p.strokeWeight(3);
        p.circle(x1, y1, 60);
        
        // Pupil
        p.fill(0); p.noStroke();
        p.circle(x1, y1, 20);
        if(sensorActive) { // Beams
             p.stroke(0, 255, 0, 100); p.strokeWeight(4);
             p.line(x1, y1-30, x1-20, y1-60);
             p.line(x1, y1-30, x1+20, y1-60);
        }
        
        p.fill(0); p.noStroke(); p.text("MOTION SENSOR", x1, y1 + 50);
        p.fill(sensorActive ? [0,150,0] : [100]); p.text(sensorActive ? "DETECTED (1)" : "NOBODY (0)", x1, y1 + 70);


        // --- 3. INPUT B: SAFETY BARRIER ---
        let x2 = p.width/2 + 120, y2 = 300;
        
        // Draw Gate graphic
        p.stroke(100); p.strokeWeight(4);
        p.line(x2 - 40, y2 + 30, x2 - 40, y2 - 30); // Post
        p.line(x2 + 40, y2 + 30, x2 + 40, y2 - 30); // Post
        
        if(barrierClosed) {
            p.stroke(0, 255, 0); p.strokeWeight(8);
            p.line(x2 - 40, y2, x2 + 40, y2); // Closed bar
        } else {
            p.stroke(255, 0, 0); p.strokeWeight(8);
            p.line(x2 - 40, y2 - 30, x2 + 40, y2 - 50); // Open/Angled bar
        }
        
        p.fill(0); p.noStroke(); p.text("SAFETY BARRIER", x2, y2 + 50);
        p.fill(barrierClosed ? [0,150,0] : [150,0,0]); p.text(barrierClosed ? "CLOSED (1)" : "OPEN (0)", x2, y2 + 70);

        // LOGIC VISUALIZER
        p.stroke(150); p.strokeWeight(2);
        p.line(x1, y1-40, p.width/2 - 20, 230);
        p.line(x2, y2-40, p.width/2 + 20, 230);
        
        p.fill(50); p.noStroke(); p.textSize(12);
        p.text("CLICK ICONS TO TOGGLE STATE", p.width/2, p.height - 20);
    };

    p.mousePressed = function() {
        if(p.dist(p.mouseX, p.mouseY, p.width/2 - 120, 300) < 40) sensorActive = !sensorActive;
        if(p.dist(p.mouseX, p.mouseY, p.width/2 + 120, 300) < 40) barrierClosed = !barrierClosed;
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
gateOR: function(p) {
    let padLeft = false;
    let padRight = false;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(30); // Dark room
        
        // Logic: Either A OR B
        let lightsOn = padLeft || padRight;
        
        // --- 1. THE LIGHTS (Output) ---
        let lx = p.width/2, ly = 50;
        
        // Draw Fixtures
        p.fill(20); p.stroke(100);
        p.rect(lx - 50, ly, 40, 40);
        p.rect(lx + 50, ly, 40, 40);
        
        if(lightsOn) {
            // Light Beams (Cone Gradients simulated)
            p.noStroke();
            p.fill(255, 255, 200, 150); // Bright center
            p.triangle(lx - 50, ly+20, lx - 90, 250, lx - 10, 250);
            p.triangle(lx + 50, ly+20, lx + 10, 250, lx + 90, 250);
            
            p.fill(255, 255, 200, 50); // Glow
            p.circle(lx - 50, 250, 100);
            p.circle(lx + 50, 250, 100);
        }
        
        p.fill(255);
        p.text(lightsOn ? "LIGHTS: ON (1)" : "LIGHTS: OFF (0)", lx, 280);

        // --- 2. INPUTS: PRESSURE PADS ---
        drawPad(p, lx - 80, 350, padLeft, "LEFT PAD");
        drawPad(p, lx + 80, 350, padRight, "RIGHT PAD");
        
        // Wires
        p.stroke(100); p.strokeWeight(2);
        p.line(lx - 80, 320, lx, 290);
        p.line(lx + 80, 320, lx, 290);
        
        p.fill(150); p.noStroke(); 
        p.text("CLICK PADS TO STEP ON THEM", p.width/2, p.height - 20);
    };
    
    function drawPad(p, x, y, active, label) {
        p.fill(active ? [0, 255, 0] : [60]);
        p.stroke(150); p.strokeWeight(active ? 0 : 2);
        // Draw Pad
        p.rectMode(p.CENTER);
        p.rect(x, y, 80, 60, 5);
        
        // Draw "Shoe Print" likeness
        p.fill(active ? [0, 100, 0] : [40]); p.noStroke();
        p.ellipse(x - 10, y + 5, 20, 35); // Left foot
        p.ellipse(x + 10, y - 5, 20, 35); // Right foot
        
        p.fill(255); 
        p.text(active ? "1" : "0", x, y);
        p.text(label, x, y + 45);
    }

    p.mousePressed = function() {
        if(p.dist(p.mouseX, p.mouseY, p.width/2 - 80, 350) < 50) padLeft = !padLeft;
        if(p.dist(p.mouseX, p.mouseY, p.width/2 + 80, 350) < 50) padRight = !padRight;
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
gateNOT: function(p) {
    let isNoisy = false;
    let waveOffset = 0;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(233);
        
        // Logic: Output is Inverse of Input
        let playsMusic = !isNoisy;
        
        // --- 1. INPUT: MICROPHONE (Room) ---
        let mx = 100, my = p.height/2;
        
        // Draw Mic Likeness
        p.fill(80); p.noStroke();
        p.rect(mx, my + 40, 10, 60); // Stand
        p.fill(30); p.rect(mx, my + 70, 40, 10); // Base
        
        p.fill(150); p.stroke(50); p.strokeWeight(2);
        p.rect(mx, my - 10, 30, 50, 10); // Mesh head
        
        // Noise visualization (Input)
        if(isNoisy) {
            p.noFill(); p.stroke(255, 0, 0); p.strokeWeight(2);
            p.beginShape();
            for(let i=0; i<60; i++) {
                p.vertex(mx + 20 + i, my - 10 + p.random(-15, 15));
            }
            p.endShape();
            p.noStroke(); p.fill(255, 0, 0);
            p.text("NOISY ROOM (1)", mx, my + 90);
        } else {
             p.noStroke(); p.fill(100);
             p.text("SILENT ROOM (0)", mx, my + 90);
        }

        // --- 2. LOGIC GATE ---
        p.stroke(0); p.strokeWeight(2);
        p.line(mx + 20, my, p.width/2 - 30, my); // Wire in
        
        // Draw NOT triangle symbol
        p.fill(255); p.stroke(0);
        p.triangle(p.width/2 - 20, my - 30, p.width/2 - 20, my + 30, p.width/2 + 20, my);
        p.circle(p.width/2 + 25, my, 10); // The inversion bubble

        // --- 3. OUTPUT: SPEAKER (Installation) ---
        let sx = p.width - 100;
        
        p.fill(50); p.noStroke();
        p.rect(sx, my, 80, 120); // Box
        p.fill(30); p.circle(sx, my + 20, 60); // Woofer
        p.fill(30); p.circle(sx, my - 30, 20); // Tweeter
        
        // Music visualization (Output)
        if(playsMusic) {
            waveOffset += 0.2;
            p.noFill(); p.stroke(0, 123, 255); p.strokeWeight(3);
            for(let r=40; r<100; r+=20) {
                let alpha = 255 - (r * 2);
                p.stroke(0, 123, 255, alpha);
                p.arc(sx, my + 20, r + Math.sin(waveOffset)*10, r + Math.sin(waveOffset)*10, p.PI, p.PI + p.PI); // Sound waves (left facing)
            }
            p.noStroke(); p.fill(0, 123, 255);
            p.text("PLAYING MUSIC (1)", sx, my + 90);
        } else {
            p.noStroke(); p.fill(100);
            p.text("SILENCE (0)", sx, my + 90);
        }
        
        p.fill(150); p.text("CLICK MIC TO MAKE NOISE", p.width/2, p.height - 30);
    };

    p.mousePressed = function() {
        if(p.mouseX < p.width/2) isNoisy = !isNoisy;
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
spatialSampling: function(p) {
    let img;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
        
        // 1. Create the "Analog" Masterpiece (High Res Buffer)
        img = p.createGraphics(p.width, p.height);
        
        // Sky Gradient
        let skyTop = p.color(135, 206, 235);
        let skyBot = p.color(240, 248, 255);
        setGradient(img, 0, 0, img.width, img.height, skyTop, skyBot, "Y");
        
        // Sun Gradient (Radial-ish via circles)
        img.noStroke();
        for(let r=100; r>0; r-=20) {
            img.fill(255, 220, 0, 50);
            img.circle(img.width * 0.8, img.height * 0.2, r + 20);
        }
        img.fill(255, 255, 0); 
        img.circle(img.width * 0.8, img.height * 0.2, 60);

        // Clouds (Soft white blobs)
        img.fill(255, 255, 255, 200);
        img.ellipse(img.width * 0.3, img.height * 0.25, 120, 40);
        img.ellipse(img.width * 0.35, img.height * 0.22, 100, 50);
        img.ellipse(img.width * 0.5, img.height * 0.15, 140, 30);

        // Mountains (Linear Gradients)
        let mtnTop = p.color(100, 100, 120);
        let mtnBot = p.color(50, 50, 70);
        
        // Big Mountain
        img.fill(80, 80, 100);
        img.triangle(0, img.height, img.width * 0.4, img.height * 0.3, img.width * 0.8, img.height);
        
        // Grassy Hill Gradient
        let hillTop = p.color(100, 200, 100);
        let hillBot = p.color(34, 139, 34);
        drawGradientShape(img, hillTop, hillBot, [
            {x: 0, y: img.height},
            {x: 0, y: img.height * 0.7},
            {x: img.width * 0.3, y: img.height * 0.65},
            {x: img.width, y: img.height * 0.8},
            {x: img.width, y: img.height}
        ]);
        
        // Tree shape (Simple)
        img.fill(80, 50, 20); img.rect(img.width * 0.2, img.height * 0.65, 20, 60); // Trunk
        img.fill(30, 100, 30); img.triangle(img.width * 0.15, img.height * 0.65, img.width * 0.21, img.height * 0.5, img.width * 0.27, img.height * 0.65); // Leaves
    };

    p.draw = function() {
        p.background(255);
        
        // Interaction: Mouse X determines Block Count (Resolution)
        // Range: From 5 blocks wide (Low Res) to 200 blocks wide (High Res)
        let blocksX = p.map(p.mouseX, 0, p.width, 5, 200);
        blocksX = p.constrain(blocksX, 5, 200);
        blocksX = Math.floor(blocksX);
        
        // Calculate block size based on width
        let blockSize = p.width / blocksX;
        let blocksY = Math.floor(p.height / blockSize);
        
        // 2. Perform the Sampling
        p.noStroke();
        for(let y = 0; y < p.height; y += blockSize) {
            for(let x = 0; x < p.width; x += blockSize) {
                // Sample color from center of grid cell
                let c = img.get(x + blockSize/2, y + blockSize/2);
                p.fill(c);
                // Draw pixel with slight gap if low res to emphasize "Grid"
                let gap = blockSize > 10 ? 1 : 0;
                p.rect(x, y, blockSize - gap, blockSize - gap);
            }
        }
        
        // 3. Info Panel
        p.fill(0, 0, 0, 180); 
        p.rect(0, p.height - 60, p.width, 60);
        
        p.fill(255); p.textSize(18);
        if(blocksX > 150) {
            p.text("RESOLUTION: HIGH (ANALOG SIMULATION)", p.width/2, p.height - 35);
        } else {
            p.text(`RESOLUTION: ${blocksX} x ${blocksY} PIXELS`, p.width/2, p.height - 35);
        }
        
        p.fill(200); p.textSize(12);
        p.text("MOVE MOUSE LEFT TO LOWER RESOLUTION / RIGHT TO INCREASE", p.width/2, p.height - 15);
    };
    
    // Helper for linear gradients
    function setGradient(context, x, y, w, h, c1, c2, axis) {
        context.noFill();
        if (axis === "Y") {
            for (let i = y; i <= y + h; i++) {
                let inter = p.map(i, y, y + h, 0, 1);
                let c = p.lerpColor(c1, c2, inter);
                context.stroke(c);
                context.line(x, i, x + w, i);
            }
        }
    }
    
    // Helper for gradient shapes
    function drawGradientShape(ctx, c1, c2, vertices) {
        // Simplified: just fills average color for p5 graphics context limitation
        // To do true gradient on shape in p5 graphics buffer is complex, 
        // so we fake it by drawing lines or just using lerped solid for simplicity in buffer.
        // Better approach for p5 buffer:
        let gradient = ctx.drawingContext.createLinearGradient(0, 0, 0, ctx.height);
        gradient.addColorStop(0, c1.toString());
        gradient.addColorStop(1, c2.toString());
        ctx.drawingContext.fillStyle = gradient;
        
        ctx.beginShape();
        for(let v of vertices) ctx.vertex(v.x, v.y);
        ctx.endShape(p.CLOSE);
    }
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); p.setup(); };
},
temporalSampling: function(p) {
    let y = 0, vy = 0; // Physics for "Reality"
    let lastSampleTime = 0;
    let sampledY = 0;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(233);
        
        // 1. Simulate "Reality" (Continuous Physics - 60fps)
        vy += 0.5; // Gravity
        y += vy;
        if(y > p.height - 40) { y = p.height - 40; vy *= -0.9; } // Bounce
        
        // Draw Reality (Ghost)
        p.noStroke(); p.fill(0, 0, 0, 20);
        p.circle(p.width/2, y, 50);
        p.fill(150); p.textSize(12); p.text("REALITY (CONTINUOUS)", p.width/2 + 80, y);

        // 2. Simulate "Digital Capture" (Variable Frame Rate)
        // Mouse controls FPS (from 1 to 60)
        let targetFPS = p.map(p.mouseX, 0, p.width, 1, 60);
        targetFPS = p.constrain(targetFPS, 1, 60);
        
        let interval = 1000 / targetFPS; // ms per frame
        
        // If enough time has passed, take a "Snapshot"
        if (p.millis() - lastSampleTime > interval) {
            sampledY = y;
            lastSampleTime = p.millis();
        }
        
        // Draw Sampled Frame
                p.stroke(0); p.strokeWeight(2); p.fill(255, 0, 0);
        p.circle(p.width/2, sampledY, 50);
        p.fill(255, 0, 0); p.noStroke();
        p.text("DIGITAL VIDEO", p.width/2 - 80, sampledY);
        
        // Interface
        p.fill(0); p.textSize(20);
        p.text(`FRAME RATE: ${Math.floor(targetFPS)} FPS`, p.width/2, 40);
        p.textSize(12); p.fill(100);
        p.text("MOVE MOUSE TO ADJUST CAMERA SPEED", p.width/2, 70);
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
nyquistVis: function(p) {
    let time = 0;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(30);
        
        if (p.width < 1) return; // Safety check

        // Interaction: Map mouse to sample density
        let density = p.constrain(p.map(p.mouseX, 0, p.width, 2, 60), 2, 60);
        let spacing = p.width / density;
        let safeSpacing = Math.max(spacing, 10); 
        
        let centerY = p.height / 2;

        // 1. Draw "True" Analog Wave (Ghost)
        p.noFill(); 
        p.stroke(255, 255, 255, 50); 
        p.strokeWeight(2);
        p.beginShape();
        for (let x = 0; x <= p.width; x += 5) {
            let y = centerY + Math.sin(x * 0.05 + time) * 100;
            p.vertex(x, y);
        }
        p.endShape();
        
        p.noStroke(); p.fill(255, 255, 255, 80); 
        p.text("TRUE ANALOG SIGNAL", 120, centerY - 120);

        // 2. Draw Digital Samples (Bars & Dots)
        let samplePoints = [];
        
        for (let x = 0; x <= p.width; x += safeSpacing) {
            let y = centerY + Math.sin(x * 0.05 + time) * 100;
            
            // DRAW VERTICAL BARS (The Pulse Code Modulation look)
            p.stroke(0, 200, 255, 150); // Cyan/Blue color
            p.strokeWeight(3); // Same width as reconstruction line
            p.line(x, centerY, x, y); // Line from center to sample point
            
            // Draw the sample dot
            p.noStroke(); p.fill(0, 255, 0);
            p.circle(x, y, 8);
            
            samplePoints.push({x, y});
        }

        // 3. Draw Digital Reconstruction (Connect the dots)
        p.stroke(0, 255, 0); p.strokeWeight(3); p.noFill();
        p.beginShape();
        for (let pt of samplePoints) {
            p.vertex(pt.x, pt.y);
        }
        p.endShape();
        
        // 4. Center Line (Zero crossing)
        p.stroke(100); p.strokeWeight(1);
        p.line(0, centerY, p.width, centerY);

        // 5. Nyquist Evaluation
        let wavelength = 125;
        let samplesPerWave = wavelength / safeSpacing;
        let isGood = samplesPerWave > 2.0;
        
        

        p.noStroke();
        if(isGood) {
            p.fill(0, 255, 0);
            p.textSize(20);
            p.text("RECONSTRUCTION: ACCURATE", p.width/2, p.height - 50);
        } else {
            p.fill(255, 50, 50);
            p.textSize(20);
            p.text("RECONSTRUCTION: FAILED (ALIASING)", p.width/2, p.height - 50);
            p.textSize(14);
            p.text("(Notice the gaps between bars miss the wave's peaks)", p.width/2, p.height - 30);
        }
        
        p.fill(150); p.textSize(12);
        p.text(`SAMPLING RATE: ${samplesPerWave.toFixed(1)} samples per wave`, p.width/2, 40);

        time += 0.05; // Animate
    };
    
    p.windowResized = function() { 
        p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); 
    };
},
colorMixer: function(p) {
    let mode = 0; // 0=Additive (RGB), 1=Subtractive (CMY), 2=Average
    let mainCanvas; // Buffer for drawing
    
    // Gradient Images (Textures)
    let texLight, texInk, texPaint;

    // Draggable Circles
    let circles = [
        { x: 150, y: 150, r: 90, dragging: false },
        { x: 200, y: 220, r: 90, dragging: false },
        { x: 250, y: 150, r: 90, dragging: false }
    ];

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
        
        mainCanvas = p.createGraphics(p.width, p.height);
        
        // PRE-GENERATE GRADIENT TEXTURES (Performance optimization)
        texLight = createGradientTex(p, 255, 255, 255, 0); // White to transparent
        texInk = createGradientTex(p, 0, 0, 0, 1); // Solid to Transparent (Inverted logic for subtractive)
    };

    p.draw = function() {
        // --- 1. RENDER MIXING ON BUFFER ---
        if(mode === 0) {
            mainCanvas.background(0);
            mainCanvas.blendMode(p.ADD);
        } else if (mode === 1) {
            mainCanvas.background(255);
            mainCanvas.blendMode(p.MULTIPLY);
        } else {
            mainCanvas.background(200);
            mainCanvas.blendMode(p.BLEND);
        }
        
        mainCanvas.noStroke();
        
        // Define colors based on mode
        let c1, c2, c3;
        if(mode === 0) { // RGB
            c1 = p.color(255, 0, 0); c2 = p.color(0, 255, 0); c3 = p.color(0, 0, 255);
        } else if (mode === 1) { // CMY
            c1 = p.color(0, 255, 255); c2 = p.color(255, 0, 255); c3 = p.color(255, 255, 0);
        } else { // Paint
            c1 = p.color(255, 0, 0, 150); c2 = p.color(0, 255, 0, 150); c3 = p.color(0, 0, 255, 150);
        }
        
        // Draw Circles with Gradient Textures
        drawGradientCircle(mainCanvas, circles[0], c1, mode);
        drawGradientCircle(mainCanvas, circles[1], c2, mode);
        drawGradientCircle(mainCanvas, circles[2], c3, mode);
        
        // Draw Buffer to Screen
        p.image(mainCanvas, 0, 0);
        
        // --- 2. EYEDROPPER LOGIC ---
        // Get color under mouse
        let c = mainCanvas.get(p.mouseX, p.mouseY);
        let r = c[0], g = c[1], b = c[2];
        
        // Calculate CMY
        let cy = Math.round((1 - r/255) * 100);
        let mg = Math.round((1 - g/255) * 100);
        let yel = Math.round((1 - b/255) * 100);
        
        // --- 3. UI OVERLAY ---
        // Bottom Data Panel
        p.fill(0, 0, 0, 200); p.noStroke();
        p.rect(0, p.height - 80, p.width, 80);
        
        // Swatch
        p.fill(r, g, b); p.stroke(255); p.strokeWeight(2);
        p.circle(60, p.height - 40, 50);
        
        // Data Text
        p.fill(255); p.noStroke(); p.textAlign(p.LEFT, p.CENTER);
        p.textSize(16); p.textStyle(p.BOLD);
        p.text("HOVER DATA:", 110, p.height - 60);
        
        p.textSize(18); p.textStyle(p.NORMAL);
        
        p.text(`RGB: ${r}, ${g}, ${b}`, 110, p.height - 35);
        p.text(`CMY: ${cy}%, ${mg}%, ${yel}%`, 300, p.height - 35);
        
        // Mode Buttons (Top Right)
        drawButton(p, p.width - 110, 30, "ADD (LIGHT)", mode === 0);
        drawButton(p, p.width - 110, 80, "SUB (INK)", mode === 1);
        drawButton(p, p.width - 110, 130, "AVG (PAINT)", mode === 2);

        // Drag Logic
        if(circles.some(c => c.dragging)) {
            let active = circles.find(c => c.dragging);
            active.x = p.mouseX; active.y = p.mouseY;
        }
    };

    // --- HELPER FUNCTIONS ---
    
    function createGradientTex(p, r, g, b, type) {
        let gfx = p.createGraphics(200, 200);
        gfx.noFill();
        for(let i = 100; i > 0; i-=2) {
            let alpha = p.map(i, 0, 100, 255, 0);
            if(type === 1) alpha = p.map(i, 0, 100, 0, 255); // Inverted for subtractive
            gfx.fill(r, g, b, alpha);
            gfx.noStroke();
            gfx.circle(100, 100, i*2);
        }
        return gfx;
    }

    function drawGradientCircle(ctx, circleObj, col, mode) {
        // We use the tint() function to colorize our pre-made white gradient texture
        ctx.tint(col);
        ctx.imageMode(p.CENTER);
        
        // For additive, we want soft edges. For subtractive, hard edges look more like overlapping filters.
        if (mode === 0) {
             ctx.image(texLight, circleObj.x, circleObj.y, circleObj.r*2, circleObj.r*2);
        } else {
             // Just draw solid circles for subtractive/average to ensure math is accurate
             // (Gradients mess up the CMY math visual)
             ctx.noTint();
             ctx.fill(col);
             ctx.circle(circleObj.x, circleObj.y, circleObj.r*2);
        }
    }

    function drawButton(p, x, y, label, isActive) {
        p.rectMode(p.CENTER);
        p.fill(isActive ? [0, 123, 255] : [50]);
        p.stroke(200); p.strokeWeight(1);
        p.rect(x, y, 100, 40, 5);
        p.fill(255); p.noStroke(); p.textAlign(p.CENTER, p.CENTER);
        p.textSize(11);
        p.text(label, x, y);
        p.rectMode(p.CORNER);
    }

    p.mousePressed = function() {
        // Buttons
        if(p.mouseX > p.width - 160) {
            if(Math.abs(p.mouseY - 30) < 20) mode = 0;
            if(Math.abs(p.mouseY - 80) < 20) mode = 1;
            if(Math.abs(p.mouseY - 130) < 20) mode = 2;
            return;
        }
        // Circles
        for(let c of circles) {
            if(p.dist(p.mouseX, p.mouseY, c.x, c.y) < c.r) {
                c.dragging = true;
                break;
            }
        }
    };
    
    p.mouseReleased = function() { circles.forEach(c => c.dragging = false); };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); p.setup(); };
},
digitalPainter: function(p) {
    let canvasLayer;
    let svGradient; // Buffer for the visual gradient
    
    // Tool State
    let activeTool = 0; // 0=Brush, 1=Eyedropper
    let blendModeStr = 'BLEND'; // 'BLEND', 'ADD', 'MULTIPLY'
    
    // Brush Properties
    let brushSize = 20;
    let brushOpacity = 255;
    
    // Color State (HSB)
    let curHue = 0;
    let curSat = 100;
    let curVal = 100;

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        
        // 1. Canvas Layer (The Painting Surface)
        canvasLayer = p.createGraphics(p.width, p.height);
        canvasLayer.colorMode(p.RGB); // Keep canvas in RGB for consistent blending
        canvasLayer.background(255);
        
        // Pre-fill some shapes to test on
        canvasLayer.noStroke();
        canvasLayer.fill(200, 200, 255); canvasLayer.circle(200, 200, 150);
        canvasLayer.fill(255, 200, 200); canvasLayer.circle(300, 250, 150);

        // 2. Gradient Buffer (For the S/V Picker)
        svGradient = p.createGraphics(100, 100);
        svGradient.colorMode(p.HSB, 360, 100, 100);
        updateSVGradient(curHue); // Initial render
    };

    p.draw = function() {
        p.background(200);
        p.image(canvasLayer, 0, 0);

        // --- UI DRAWING ---
        // Sidebar Background
        p.fill(50); p.noStroke();
        p.rect(0, 0, 140, p.height);

        // 1. HUE PICKER (Vertical Strip)
        p.colorMode(p.HSB, 360, 100, 100);
        for(let i=0; i<360; i+=5) {
            p.fill(i, 100, 100); p.noStroke();
            p.rect(10, 20 + (i/360)*150, 20, 3);
        }
        // Hue Indicator
        p.stroke(255); p.noFill();
        p.rect(8, 20 + (curHue/360)*150 - 2, 24, 6);

        // 2. S/V GRADIENT PICKER (Square Box)
        p.image(svGradient, 40, 20, 80, 150);
        // S/V Indicator
        let indX = 40 + (curSat/100)*80;
        let indY = 20 + ((100-curVal)/100)*150;
        p.stroke(255); p.strokeWeight(1); p.noFill();
        p.circle(indX, indY, 6);
        p.stroke(0);
        p.circle(indX, indY, 4);

        // 3. CURRENT COLOR PREVIEW
        p.colorMode(p.RGB); // Switch to RGB for rendering swatch
        let cRGB = p.color(`hsb(${Math.floor(curHue)}, ${Math.floor(curSat)}%, ${Math.floor(curVal)}%)`);
        p.fill(cRGB); p.stroke(255);
        p.rect(10, 185, 110, 30);
        
        // 4. TOOLS UI
        drawButton(p, 10, 230, 55, 40, "BRUSH", activeTool === 0);
        drawButton(p, 70, 230, 55, 40, "EYE\nDROP", activeTool === 1);
        
        // 5. BLEND MODES
        p.fill(255); p.noStroke(); p.textSize(10); p.textAlign(p.LEFT);
        p.text("BLEND MODE", 10, 290);
        drawButton(p, 10, 300, 35, 25, "NRM", blendModeStr === 'BLEND');
        drawButton(p, 50, 300, 35, 25, "ADD", blendModeStr === 'ADD');
        drawButton(p, 90, 300, 35, 25, "SUB", blendModeStr === 'MULTIPLY');

        // 6. SLIDERS
        drawSlider(p, 340, "SIZE", brushSize, 1, 50);
        drawSlider(p, 380, "OPACITY", brushOpacity, 0, 255);
        
        // Clear Button
        drawButton(p, 10, 420, 110, 30, "CLEAR CANVAS", false);


        // --- INTERACTION LOGIC ---
        
        // If clicking on Canvas area
        if (p.mouseIsPressed && p.mouseX > 140) {
            if (activeTool === 0) { // BRUSH
                canvasLayer.colorMode(p.RGB);
                
                // Set Blend Mode
                if(blendModeStr === 'ADD') canvasLayer.blendMode(p.ADD);
                else if(blendModeStr === 'MULTIPLY') canvasLayer.blendMode(p.MULTIPLY);
                else canvasLayer.blendMode(p.BLEND);
                
                canvasLayer.noStroke();
                // Pass opacity correctly to fill
                let r = p.red(cRGB);
                let g = p.green(cRGB);
                let b = p.blue(cRGB);
                canvasLayer.fill(r, g, b, brushOpacity);
                canvasLayer.circle(p.mouseX, p.mouseY, brushSize);
                
                // Reset for safety
                canvasLayer.blendMode(p.BLEND);
            }
            // Eyedropper handled in overlay section below
        }

        // --- EYEDROPPER OVERLAY ---
        if (activeTool === 1 && p.mouseX > 140) {
            let c = canvasLayer.get(p.mouseX, p.mouseY);
            let r = c[0], g = c[1], b = c[2];

            // Calculate CMY
            let cC = Math.round((1 - r/255) * 100);
            let cM = Math.round((1 - g/255) * 100);
            let cY = Math.round((1 - b/255) * 100);

            // Magnifier Visual
            p.push();
            p.translate(p.mouseX, p.mouseY);
            
            // Draw Swatch (Force RGB mode so it displays correctly)
            p.colorMode(p.RGB); 
            p.stroke(255); p.strokeWeight(3);
            p.fill(r, g, b); 
            p.circle(0, -50, 50);
            
            // Tooltip Box
            p.fill(0, 0, 0, 200); p.noStroke();
            p.rect(30, -70, 110, 60, 5);
            
            // Text Values
            p.fill(255); p.noStroke(); p.textAlign(p.LEFT); p.textSize(11);
            p.text(`RGB: ${r}, ${g}, ${b}`, 40, -50);
            p.text(`CMY: ${cC}, ${cM}, ${cY}`, 40, -30);
            p.text(`HEX: #${p.hex(r,2)}${p.hex(g,2)}${p.hex(b,2)}`, 40, -50 + 40); // Hex fix
            
            p.pop();
        }

        // Brush Cursor
        if (activeTool === 0 && p.mouseX > 140) {
            p.noFill(); p.stroke(50); p.strokeWeight(1);
            p.circle(p.mouseX, p.mouseY, brushSize);
        }
    };
    
    // --- HELPER FUNCTIONS ---

    function updateSVGradient(hue) {
        svGradient.loadPixels();
        for (let y = 0; y < 100; y++) {
            for (let x = 0; x < 100; x++) {
                // X = Saturation (0-100), Y = Brightness (100-0)
                let s = x;
                let b = 100 - y;
                let c = svGradient.color(hue, s, b);
                svGradient.set(x, y, c);
            }
        }
        svGradient.updatePixels();
    }

    function drawButton(p, x, y, w, h, label, active) {
        p.fill(active ? [0, 123, 255] : [80]);
        p.stroke(200); p.strokeWeight(1);
        p.rect(x, y, w, h, 4);
        p.fill(255); p.noStroke(); p.textAlign(p.CENTER, p.CENTER);
        p.textSize(10);
        p.text(label, x + w/2, y + h/2);
    }
    
    function drawSlider(p, y, label, val, min, max) {
        p.fill(255); p.textAlign(p.LEFT); p.text(label, 10, y);
        // Track
        p.stroke(100); p.strokeWeight(2);
        p.line(10, y + 10, 110, y + 10);
        // Knob
        let norm = (val - min) / (max - min);
        let kx = 10 + norm * 100;
        p.fill(0, 123, 255); p.noStroke();
        p.circle(kx, y + 10, 12);
    }

    p.mousePressed = function() {
        // UI INTERACTION (Left Side)
        if (p.mouseX < 140) {
            // 1. Hue Picker (10, 20) to (30, 170)
            if (p.mouseX >= 10 && p.mouseX <= 30 && p.mouseY >= 20 && p.mouseY <= 170) {
                curHue = p.map(p.mouseY, 20, 170, 0, 360);
                curHue = p.constrain(curHue, 0, 360);
                updateSVGradient(curHue);
            }
            // 2. S/V Picker (40, 20) to (120, 170)
            else if (p.mouseX >= 40 && p.mouseX <= 120 && p.mouseY >= 20 && p.mouseY <= 170) {
                curSat = p.map(p.mouseX, 40, 120, 0, 100);
                curVal = p.map(p.mouseY, 20, 170, 100, 0); // Inverted Y
                curSat = p.constrain(curSat, 0, 100);
                curVal = p.constrain(curVal, 0, 100);
            }
            // 3. Tool Buttons
            else if (p.mouseY >= 230 && p.mouseY <= 270) {
                if (p.mouseX >= 10 && p.mouseX <= 65) activeTool = 0; // Brush
                if (p.mouseX >= 70 && p.mouseX <= 125) activeTool = 1; // Eyedropper
            }
            // 4. Blend Modes
            else if (p.mouseY >= 300 && p.mouseY <= 325) {
                if (p.mouseX >= 10 && p.mouseX <= 45) blendModeStr = 'BLEND';
                if (p.mouseX >= 50 && p.mouseX <= 85) blendModeStr = 'ADD';
                if (p.mouseX >= 90 && p.mouseX <= 125) blendModeStr = 'MULTIPLY';
            }
            // 5. Sliders (Simple hit detection)
            else if (p.mouseY >= 340 && p.mouseY <= 360) {
                brushSize = p.map(p.mouseX, 10, 110, 1, 50, true);
            }
            else if (p.mouseY >= 380 && p.mouseY <= 400) {
                brushOpacity = p.map(p.mouseX, 10, 110, 0, 255, true);
            }
            // 6. Clear Button
            else if (p.mouseY >= 420 && p.mouseY <= 450) {
                canvasLayer.background(255);
            }
        }
    };
    
    // Dragging Logic for sliders/pickers
    p.mouseDragged = function() {
        if (p.mouseX < 140) {
             // Reuse click logic for dragging sliders/pickers
             p.mousePressed();
        }
    };

    p.windowResized = function() { 
        p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); 
        // Re-create gradient buffer on resize to be safe
        svGradient = p.createGraphics(100, 100);
        svGradient.colorMode(p.HSB, 360, 100, 100);
        updateSVGradient(curHue);
    };
},
sketchpadDraw: function(p) {
    let strokes = [];
    let currentStroke = [];
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
    };

    p.draw = function() {
        p.background(20); // Dark CRT background
        
        // CRT Scanline effect overlay
        p.noStroke(); p.fill(0, 50, 0, 50);
        for(let y=0; y<p.height; y+=4) p.rect(0, y, p.width, 1);
        
        // Draw Interface
        p.noFill(); p.stroke(0, 255, 0); p.strokeWeight(1);
        p.rect(20, 20, p.width-40, p.height-40); // Screen Bezel
        
        // Draw Strokes
        p.strokeWeight(2);
        p.stroke(0, 255, 100); // Phosphor Green
        p.noFill();
        
        // Draw finished strokes
        for(let s of strokes) {
            p.beginShape();
            for(let pt of s) p.vertex(pt.x, pt.y);
            p.endShape();
        }
        
        // Draw current stroke
        if(currentStroke.length > 0) {
            p.stroke(200, 255, 200); // Brighter while drawing
            p.beginShape();
            for(let pt of currentStroke) p.vertex(pt.x, pt.y);
            p.endShape();
        }
        
        // Light Pen Cursor
        p.noCursor();
        p.stroke(0, 255, 0); p.fill(0, 0, 0, 0);
        p.circle(p.mouseX, p.mouseY, 10);
        p.line(p.mouseX, p.mouseY, p.mouseX + 20, p.mouseY + 20); // Pen handle graphic
        
        // UI Text
        p.fill(0, 255, 0); p.noStroke(); p.textSize(14); p.textFont('Courier New');
        p.textAlign(p.LEFT, p.TOP);
        p.text("SKETCHPAD v1.0 (1963)", 30, 30);
        p.text("MODE: DRAW", 30, 50);
        
        p.textAlign(p.CENTER, p.BOTTOM);
        p.text("CLICK AND DRAG TO DRAW WITH LIGHT PEN", p.width/2, p.height - 30);
        
            };
    
    p.mousePressed = function() {
        if(p.mouseX > 20 && p.mouseX < p.width-20 && p.mouseY > 20 && p.mouseY < p.height-20) {
            currentStroke = [];
        }
    };
    
    p.mouseDragged = function() {
        currentStroke.push({x: p.mouseX, y: p.mouseY});
    };
    
    p.mouseReleased = function() {
        if(currentStroke.length > 0) strokes.push(currentStroke);
        currentStroke = [];
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
masterInstance: function(p) {
    let rivetRadius = 30;
    let rivetRotation = 0;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
        p.rectMode(p.CENTER);
    };

    p.draw = function() {
        p.background(20);
        
        // Layout
        let masterX = p.width * 0.25;
        let masterY = p.height * 0.5;
        
        // --- 1. DRAW MASTER OBJECT ---
        p.stroke(0, 255, 0); p.strokeWeight(2); p.noFill();
        p.rect(masterX, masterY, 150, 200); // Selection Box
        p.fill(0, 255, 0); p.noStroke();
        p.text("MASTER DEFINITION", masterX, masterY - 120);
        
        // Draw the Rivet (Master)
        drawRivet(p, masterX, masterY, rivetRadius, rivetRotation, true);
        
        // --- 2. DRAW INSTANCES ---
        let instX = p.width * 0.7;
        p.stroke(0, 255, 0, 100); p.noFill();
        p.rect(instX, masterY, 200, 200); // Instance Area
        p.fill(0, 255, 0, 150); p.noStroke();
        p.text("INSTANCES (COPIES)", instX, masterY - 120);
        
        // 4 Instances arranged in a grid
        drawRivet(p, instX - 50, masterY - 50, rivetRadius, rivetRotation, false);
        drawRivet(p, instX + 50, masterY - 50, rivetRadius, rivetRotation, false);
        drawRivet(p, instX - 50, masterY + 50, rivetRadius, rivetRotation, false);
        drawRivet(p, instX + 50, masterY + 50, rivetRadius, rivetRotation, false);

        // --- 3. CONTROLS ---
        p.fill(255);
        p.text("MODIFY MASTER TO UPDATE ALL INSTANCES", p.width/2, p.height - 50);
        
        // Simulated Interaction (Auto-animate for demonstration)
        if(p.mouseIsPressed && p.mouseX < p.width/2) {
             rivetRotation += 0.05;
             rivetRadius = 30 + Math.sin(p.frameCount * 0.1) * 10;
        } else {
             p.fill(0, 255, 0);
             p.text("(CLICK & HOLD LEFT SIDE TO MODIFY)", masterX, masterY + 120);
        }
    };
    
    function drawRivet(p, x, y, r, rot, isMaster) {
        p.push();
        p.translate(x, y);
        p.rotate(rot);
        
        if(isMaster) {
            p.stroke(255, 255, 0); p.strokeWeight(3); // Bright Yellow for Master
        } else {
            p.stroke(0, 255, 0); p.strokeWeight(1); // Green for Instance
        }
        p.noFill();
        
        // The "Rivet" Shape (Hexagon + Circle)
        p.circle(0, 0, r);
        p.beginShape();
        for(let i=0; i<6; i++) {
            let angle = (p.TWO_PI / 6) * i;
            p.vertex(Math.cos(angle) * (r + 10), Math.sin(angle) * (r + 10));
        }
        p.endShape(p.CLOSE);
        p.line(-r, -r, r, r); // Crosshair
        p.line(r, -r, -r, r);
        
        p.pop();
    }
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
geometricConstraints: function(p) {
    let isConstrained = false;
    let t = 0; // Animation time
    
    // "Rough" Points (Wobbly input)
    let roughPoints = [
        {x: -60, y: -50}, {x: 70, y: -40}, 
        {x: 55, y: 60}, {x: -70, y: 55}
    ];
    
    // "Perfect" Points (Target rectangle)
    let perfectPoints = [
        {x: -60, y: -50}, {x: 60, y: -50}, 
        {x: 60, y: 50}, {x: -60, y: 50}
    ];
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(20);
        
        // Title
        p.fill(0, 255, 0); p.textFont('Courier New'); p.textSize(16);
        p.text("CONSTRAINT SOLVER", p.width/2, 40);
        
        p.push();
        p.translate(p.width/2, p.height/2 - 20);
        
        // Draw Edges
        p.stroke(0, 255, 0); p.strokeWeight(2); p.noFill();
        p.beginShape();
        
        for(let i=0; i<4; i++) {
            let r = roughPoints[i];
            let target = perfectPoints[i];
            
            // Interpolate based on state
            let x, y;
            if(isConstrained) {
                // Lerp towards perfection
                x = p.lerp(r.x, target.x, t);
                y = p.lerp(r.y, target.y, t);
            } else {
                x = r.x; y = r.y;
            }
            p.vertex(x, y);
            
            // Draw Vertex Points
            p.push();
            p.fill(0); p.stroke(0, 255, 0);
            p.circle(x, y, 8);
            p.pop();
        }
        p.endShape(p.CLOSE);
        
        // Geometric indicators (Right angles)
        if(t > 0.8) {
            p.stroke(255, 255, 0); p.strokeWeight(1);
            p.rect(-60, -50, 10, 10); // Corner marker
            p.rect(60, 50, -10, -10);
        }
        
        p.pop();
        
        // Animation Logic
        if(isConstrained && t < 1) t += 0.05;
        if(!isConstrained && t > 0) t -= 0.05;

        // --- BUTTON ---
        let btnColor = isConstrained ? [0, 100, 0] : [0, 50, 0];
        p.fill(btnColor); p.stroke(0, 255, 0);
        p.rect(p.width/2 - 80, p.height - 80, 160, 40);
        
        p.fill(0, 255, 0);
        p.text(isConstrained ? "RELEASE CONSTRAINT" : "APPLY CONSTRAINT", p.width/2, p.height - 60);
        
        // Explanation
        p.fill(150); p.textSize(12);
        p.text(isConstrained ? "GEOMETRY RECTIFIED (PARALLEL/PERPENDICULAR)" : "USER INPUT (ROUGH SKETCH)", p.width/2, p.height - 30);
    };

    p.mousePressed = function() {
        if(p.mouseX > p.width/2 - 80 && p.mouseX < p.width/2 + 80 && 
           p.mouseY > p.height - 80 && p.mouseY < p.height - 40) {
            isConstrained = !isConstrained;
        }
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
wireframeModel: function(p) {
    let angle = 0;
    
    // Define an Icosahedron (Vertices) using Golden Ratio
    let t = (1.0 + Math.sqrt(5.0)) / 2.0;
    let vertices = [
        [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
        [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
        [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
    ];
    
    // Define Edges (Pairs of vertex indices)
    let edges = [
        [0, 11], [0, 5], [0, 1], [0, 7], [0, 10], [1, 5], [1, 9], [1, 8], [1, 7], 
        [2, 11], [2, 10], [2, 6], [2, 3], [2, 4], [3, 6], [3, 8], [3, 9], [3, 4], 
        [4, 11], [4, 5], [4, 9], [5, 11], [6, 10], [6, 7], [6, 8], [7, 10], [8, 9], 
        [5, 9], [11, 10], [7, 8]
    ];

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(20);
        p.translate(p.width/2, p.height/2);
        
        // Interaction: MouseX controls rotation speed
        angle += 0.01 + (p.mouseX / p.width) * 0.05;
        
        // 3D Projection Logic
        let projected = [];
        let scale = 80;
        
        for(let v of vertices) {
            // Rotate Y
            let x1 = v[0] * Math.cos(angle) - v[2] * Math.sin(angle);
            let z1 = v[0] * Math.sin(angle) + v[2] * Math.cos(angle);
            // Rotate X
            let y2 = v[1] * Math.cos(angle*0.5) - z1 * Math.sin(angle*0.5);
            let z2 = v[1] * Math.sin(angle*0.5) + z1 * Math.cos(angle*0.5);
            
            // Perspective Projection (Z-divide)
            let perspective = 300 / (300 + z2); 
            let px = x1 * scale * perspective;
            let py = y2 * scale * perspective;
            
            projected.push([px, py]);
            
            // Draw Vertices
            p.fill(0, 255, 255); p.noStroke();
            p.circle(px, py, 6);
        }
        
        // Draw Edges
        p.stroke(0, 255, 100); p.strokeWeight(2);
        for(let e of edges) {
            let p1 = projected[e[0]];
            let p2 = projected[e[1]];
            p.line(p1[0], p1[1], p2[0], p2[1]);
        }
        
        // UI
        p.fill(255); p.noStroke(); p.textSize(14);
        p.text("RAW WIREFRAME (VERTICES & EDGES)", 0, p.height/2 - 30);
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
renderingPipeline: function(p) {
    let angle = 0;
    
    // Cube Geometry (Faces defined by 3 points)
    // Front, Back, Left, Right, Top, Bottom
    // Simplified for demo: Just 4 faces of a pyramid
    let pyramid = [
        [[0, -100, 0], [-100, 100, 100], [100, 100, 100]], // Front
        [[0, -100, 0], [100, 100, 100], [100, 100, -100]], // Right
        [[0, -100, 0], [100, 100, -100], [-100, 100, -100]], // Back
        [[0, -100, 0], [-100, 100, -100], [-100, 100, 100]]  // Left
    ];

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(30);
        p.translate(p.width/2, p.height/2);
        
        angle += 0.02;
        
        // Light Source Vector (Coming from top-right-front)
        let lightDir = p.createVector(0.5, -0.5, 1).normalize();
        
        // Sort faces by depth (Painter's Algorithm) so back faces don't draw on top
        // (Skipped for simple pyramid demo, but important in real 3D)
        
        for(let face of pyramid) {
            let projFace = [];
            let avgZ = 0;
            
            // 1. Transform Vertices
            for(let v of face) {
                // Rotation
                let x = v[0] * Math.cos(angle) - v[2] * Math.sin(angle);
                let z = v[0] * Math.sin(angle) + v[2] * Math.cos(angle);
                let y = v[1];
                
                // Tilt
                let y2 = y * Math.cos(0.5) - z * Math.sin(0.5);
                let z2 = y * Math.sin(0.5) + z * Math.cos(0.5);
                
                let scale = 1;
                projFace.push(p.createVector(x, y2, z2));
                avgZ += z2;
            }
            
            // 2. Calculate Normal (Direction face is pointing)
            let vA = p5.Vector.sub(projFace[1], projFace[0]);
            let vB = p5.Vector.sub(projFace[2], projFace[0]);
            let normal = vA.cross(vB).normalize();
            
            // 3. Backface Culling (Don't draw if facing away)
            // Dot product with camera vector (0, 0, 1)
            if(normal.z > 0) {
                // 4. Calculate Lighting (Dot product of Normal and Light)
                // Result is -1 to 1. Map -1 to 0 (dark) and 1 to 255 (bright)
                let intensity = normal.dot(lightDir);
                let brightness = p.map(intensity, -1, 1, 50, 255);
                
                // Draw Solid Face
                p.fill(0, 100, 255, brightness); 
                p.stroke(255, 50); p.strokeWeight(1);
                
                p.beginShape();
                for(let v of projFace) p.vertex(v.x, v.y);
                p.endShape(p.CLOSE);
            }
        }
        
        p.fill(255); p.noStroke(); 
        p.text("FLAT SHADING (SOLID POLYGONS)", 0, p.height/2 - 30);
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
textureCube: function(p) {
    let angle = 0;
    let tex; // The texture image
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
        
        // Create a procedural "Texture" (Checkerboard)
        tex = p.createGraphics(200, 200);
        tex.background(255);
        tex.fill(0); tex.noStroke();
        for(let i=0; i<4; i++) {
            for(let j=0; j<4; j++) {
                if((i+j)%2==0) tex.rect(i*50, j*50, 50, 50);
            }
        }
        tex.fill(255, 0, 0); tex.textSize(30); tex.textAlign(p.CENTER, p.CENTER);
        tex.text("UV MAP", 100, 100);
    };

    p.draw = function() {
        p.background(30);
        
        // Draw the flat texture source on the left
        p.image(tex, 20, 20, 100, 100);
        p.fill(255); p.noStroke(); p.textSize(10);
        p.text("SOURCE TEXTURE (2D)", 70, 135);
        
        p.translate(p.width/2, p.height/2);
        angle += 0.01;
        
        // Define a simple Cube face (just one rotating quad for demo clarity)
        let size = 100;
        let p1 = rot(-size, -size, angle);
        let p2 = rot(size, -size, angle);
        let p3 = rot(size, size, angle);
        let p4 = rot(-size, size, angle);
        
        // Draw the Mapped Face (Using textureQuad is hard in 2D p5, so we simulate visuals)
        // We draw the shape, clip it, and draw the texture inside transformed
        
        p.noStroke();
        p.textureMode(p.NORMAL);
        // We need WEBGL mode to do real texture mapping easily in p5.
        // Since we are in 2D canvas mode, we will simulate the "Look"
        // by drawing the grid transforming.
        
        p.fill(255); 
        p.quad(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y);
        
        // Draw grid lines on the quad to simulate the texture map
        p.stroke(0); p.strokeWeight(2);
        
        // Interpolate grid lines
        for(let i=0.25; i<1; i+=0.25) {
            let top = p5.Vector.lerp(p1, p2, i);
            let bot = p5.Vector.lerp(p4, p3, i);
            p.line(top.x, top.y, bot.x, bot.y); // Vertical lines
            
            let left = p5.Vector.lerp(p1, p4, i);
            let right = p5.Vector.lerp(p2, p3, i);
            p.line(left.x, left.y, right.x, right.y); // Horizontal lines
        }
        
        p.fill(0, 255, 0); p.noStroke();
        p.text("MAPPED GEOMETRY", 0, 150);
    };
    
    // Helper to rotate 2D point around center (simulating Y-axis spin)
    function rot(x, y, a) {
        // Simple perspective projection simulation
        let x2 = x * Math.cos(a);
        let scale = 1 + (x * Math.sin(a) * 0.002); // Foreshortening
        return p.createVector(x2, y);
    }
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
lSystemTree: function(p) {
    let angle = p.PI / 4;
    let sliderAngle;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(30);
        
        // Interaction: MouseX controls branching angle
        // Map 0-Width to 0-90 degrees
        angle = p.map(p.mouseX, 0, p.width, 0, p.PI/2);
        
        p.stroke(0, 255, 150); p.strokeWeight(2);
        p.translate(p.width/2, p.height); // Start at bottom center
        branch(150); // Start recursive growth
        
        // UI Overlay
        p.resetMatrix();
        p.fill(255); p.noStroke(); p.textSize(16);
        let deg = Math.floor(p.degrees(angle));
        p.text(`BRANCH ANGLE: ${deg}°`, p.width/2, 40);
        p.fill(150); p.textSize(12);
        p.text("MOVE MOUSE LEFT/RIGHT TO MUTATE THE DNA", p.width/2, 70);
    };

    function branch(len) {
        p.line(0, 0, 0, -len); // Draw trunk/branch
        p.translate(0, -len); // Move to end
        
        if (len > 4) { // Recursion limit (Stop at 4 pixels)
            p.push();
            p.rotate(angle); // Turn right
            branch(len * 0.67); // Grow shorter branch
            p.pop();
            
            p.push();
            p.rotate(-angle); // Turn left
            branch(len * 0.67); // Grow shorter branch
            p.pop();
        }
    }
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
perlinTerrain: function(p) {
    let startOffset = 0;
    
    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        p.textAlign(p.CENTER, p.CENTER);
    };

    p.draw = function() {
        p.background(30, 30, 50); // Dark sky
        
        p.noFill(); p.strokeWeight(2);
        
        // 1. Draw "True Random" Line (Top) - The Chaos
        p.stroke(255, 100, 100); 
        p.beginShape();
        for(let x=0; x<p.width; x+=5) {
            p.vertex(x, 150 + p.random(-20, 20));
        }
        p.endShape();
        p.noStroke(); p.fill(255, 100, 100); p.textSize(12);
        p.text("TRUE RANDOMNESS (TV STATIC)", p.width/2, 100);

        // 2. Draw "Perlin Noise" Landscape (Bottom) - The Organic
        p.stroke(100, 200, 255); p.noFill();
        p.beginShape();
        let xoff = startOffset;
        for(let x=0; x<p.width; x+=5) {
            // Map noise value (0-1) to height
            let y = p.map(p.noise(xoff), 0, 1, 250, p.height - 50);
            p.vertex(x, y);
            xoff += 0.01; // Smoothness factor
        }
        p.endShape();
        
        // Fill the bottom to look like terrain
        p.fill(0, 100, 150, 50); p.noStroke();
        p.rect(0, p.height - 50, p.width, 50); // Water line?
        
        p.fill(100, 200, 255);
        p.text("PERLIN NOISE (ORGANIC SMOOTHNESS)", p.width/2, 220);
        
        // Instructions
        p.fill(150); 
        p.text("THE LANDSCAPE SCROLLS AUTOMATICALLY", p.width/2, p.height - 20);
        
        startOffset += 0.01; // Animate scroll
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
gameOfLife: function(p) {
    let grid;
    let cols;
    let rows;
    let resolution = 20;
    let isPlaying = true;

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        cols = Math.floor(p.width / resolution);
        rows = Math.floor(p.height / resolution);
        grid = make2DArray(cols, rows);
        
        // Random seed
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                grid[i][j] = p.floor(p.random(2));
            }
        }
    };

    p.draw = function() {
        p.background(30);

        // Draw Grid
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                let x = i * resolution;
                let y = j * resolution;
                if (grid[i][j] == 1) {
                    p.fill(160, 255, 180); // Life color
                    p.stroke(0);
                    p.rect(x, y, resolution - 1, resolution - 1);
                }
            }
        }

        // Calculate Next Generation
        if(isPlaying && p.frameCount % 5 === 0) { // Slow down simulation
            let next = make2DArray(cols, rows);
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    let state = grid[i][j];
                    let neighbors = countNeighbors(grid, i, j);

                    if (state == 0 && neighbors == 3) {
                        next[i][j] = 1; // Reproduction
                    } else if (state == 1 && (neighbors < 2 || neighbors > 3)) {
                        next[i][j] = 0; // Death
                    } else {
                        next[i][j] = state; // Stasis
                    }
                }
            }
            grid = next;
        }
        
        // UI
        p.fill(0, 0, 0, 150); p.noStroke();
        p.rect(0, p.height - 40, p.width, 40);
        p.fill(255); p.textAlign(p.CENTER, p.CENTER); p.textSize(12);
        p.text(isPlaying ? "SIMULATING... (CLICK TO DRAW / SPACE TO PAUSE)" : "PAUSED (CLICK TO DRAW / SPACE TO RESUME)", p.width/2, p.height - 20);
    };

    function make2DArray(cols, rows) {
        let arr = new Array(cols);
        for (let i = 0; i < arr.length; i++) {
            arr[i] = new Array(rows);
        }
        return arr;
    }

    function countNeighbors(grid, x, y) {
        let sum = 0;
        for (let i = -1; i < 2; i++) {
            for (let j = -1; j < 2; j++) {
                let col = (x + i + cols) % cols; // Wrap edges
                let row = (y + j + rows) % rows;
                sum += grid[col][row];
            }
        }
        sum -= grid[x][y];
        return sum;
    }
    
    p.mousePressed = function() {
        // Allow manual drawing
        let i = p.floor(p.mouseX / resolution);
        let j = p.floor(p.mouseY / resolution);
        if(i >= 0 && i < cols && j >= 0 && j < rows) {
            grid[i][j] = 1;
        }
    };
    
    p.keyPressed = function() {
        if (p.key === ' ') isPlaying = !isPlaying;
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); p.setup(); };
},
videoSignal: function(p) {
    let vid;
    let ready = false;

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        // Request Camera
        vid = p.createCapture(p.VIDEO, () => { ready = true; });
        vid.size(320, 240); // Low res for performance effect
        vid.hide(); // Hide the HTML element
        p.pixelDensity(1);
    };

    p.draw = function() {
        p.background(0);
        
        if(!ready) {
            p.fill(255); p.textAlign(p.CENTER);
            p.text("WAITING FOR CAMERA PERMISSION...", p.width/2, p.height/2);
            return;
        }

        // Draw distorted video
        vid.loadPixels();
        let step = 8; // Pixel block size
        
        p.noStroke();
        for (let y = 0; y < vid.height; y += step) {
            for (let x = 0; x < vid.width; x += step) {
                // Calculate distortion based on mouse (The Magnet)
                let dist = p.dist(p.mouseX/2, p.mouseY/2, x, y); // divide mouse by 2 because video is smaller
                let shift = (p.mouseX / p.width) * (5000 / (dist + 10)); 
                
                // Get pixel color from shifted position
                let srcX = Math.floor(x + Math.sin(y * 0.1 + p.frameCount * 0.1) * shift);
                srcX = p.constrain(srcX, 0, vid.width - 1);
                
                let offset = (y * vid.width + srcX) * 4;
                let r = vid.pixels[offset];
                let g = vid.pixels[offset + 1];
                let b = vid.pixels[offset + 2];
                
                // RGB Split effect (Chromatic Aberration)
                p.fill(r, 0, 0, 200);
                p.rect(x * (p.width/vid.width) - 5, y * (p.height/vid.height), step*2, step*2);
                
                p.fill(0, g, b, 200);
                p.rect(x * (p.width/vid.width) + 5, y * (p.height/vid.height), step*2, step*2);
            }
        }
        
        p.fill(0, 255, 0); p.textSize(16);
        p.text("SIGNAL JAMMER: MOVE MOUSE TO DISTORT", p.width/2, 30);
    };
    
    // Cleanup to stop camera when slide changes
    p.remove = function() {
        if(vid) { vid.stop(); vid.remove(); }
    };
    
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
videoVision: function(p) {
    let vid;
    let ready = false;

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        vid = p.createCapture(p.VIDEO, () => { ready = true; });
        vid.size(320, 240);
        vid.hide();
        p.pixelDensity(1);
    };

    p.draw = function() {
        p.background(0);
        
        if(!ready) {
             p.fill(255); p.text("INITIALIZING VISION SYSTEM...", p.width/2, p.height/2);
             return;
        }

        vid.loadPixels();
        p.loadPixels(); // Canvas pixels

        // Simple Edge Detection Kernel
        // Iterate over video pixels
        for (let y = 0; y < vid.height; y++) {
            for (let x = 0; x < vid.width; x++) {
                // Get index of current pixel and neighbor (right)
                let i = (y * vid.width + x) * 4;
                let iRight = (y * vid.width + (x + 1)) * 4;
                let iDown = ((y + 1) * vid.width + x) * 4;
                
                // Compare brightness
                let b = (vid.pixels[i] + vid.pixels[i+1] + vid.pixels[i+2]) / 3;
                let bRight = (vid.pixels[iRight] + vid.pixels[iRight+1] + vid.pixels[iRight+2]) / 3;
                let bDown = (vid.pixels[iDown] + vid.pixels[iDown+1] + vid.pixels[iDown+2]) / 3;
                
                let diff = Math.abs(b - bRight) + Math.abs(b - bDown);
                
                // Threshold
                let output = diff > 20 ? 255 : 0; // If difference is high, draw White
                
                // Draw to screen (scaled up manually to fill canvas)
                // Note: Direct pixel manipulation is CPU heavy, so we draw small rectangles instead for this demo
                // Or map to p.pixels if we matched resolution. 
                // For simplicity/performance in presentation:
                if (output > 0) {
                     p.fill(0, 255, 0); p.noStroke();
                     p.rect(x * (p.width/vid.width), y * (p.height/vid.height), 3, 3);
                }
            }
        }
        
        p.fill(0, 255, 0); p.rect(0, p.height - 40, p.width, 40);
        p.fill(0); p.textSize(16);
        p.text("COMPUTER VISION: EDGE DETECTION", p.width/2, p.height - 15);
    };

    p.remove = function() { if(vid) { vid.stop(); vid.remove(); } };
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); };
},
videoTime: function(p) {
    let vid;
    let ready = false;
    let x = 0;

    p.setup = function() {
        p.createCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7);
        vid = p.createCapture(p.VIDEO, () => { ready = true; });
        vid.size(320, 240);
        vid.hide();
        p.background(0);
    };

    p.draw = function() {
        if(!ready) return;

        // SLIT SCAN LOGIC
        // Instead of clearing background, we draw one vertical slice per frame
        // moving across the screen.
        
        // 1. Get the center column of pixels from the webcam
        let w = vid.width;
        let h = vid.height;
        let centerX = w / 2;
        
        // 2. Draw that center slice onto the canvas at current x
        p.copy(vid, centerX, 0, 1, h, x, 0, 1, p.height);
        
        // 3. Move X
        x++;
        if (x > p.width) {
            x = 0; // Loop back
        }
        
        // Draw "Scan Line" indicator
        p.stroke(255, 0, 0);
        p.line(x, 0, x, p.height);
        
        // Live Preview in corner
        p.image(vid, p.width - 100, p.height - 80, 80, 60);
        p.noFill(); p.stroke(255); p.rect(p.width - 100, p.height - 80, 80, 60);
        
        p.fill(255); p.noStroke(); p.textSize(16);
        p.text("TEMPORAL DISPLACEMENT (SLIT SCAN)", p.width/2, 30);
        p.fill(150); p.textSize(12);
        p.text("MOVE YOUR BODY TO PAINT WITH TIME", p.width/2, 50);
    };

    p.remove = function() { if(vid) { vid.stop(); vid.remove(); } };
    p.windowResized = function() { p.resizeCanvas(p.windowWidth * 0.6, p.windowHeight * 0.7); p.background(0); x=0; };
},
 // Agentic Customer Service System Generators
            'agentic_overview': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.flow{animation:flow 2s ease-in-out infinite alternate;}.agent{fill:var(--accent-color);stroke:white;stroke-width:2;}.connect{stroke:var(--accent-color);stroke-width:2;animation:pulse 1.5s ease-in-out infinite;}@keyframes flow{from{opacity:0.6;}to{opacity:1;}}@keyframes pulse{0%{stroke-opacity:0.3;}50%{stroke-opacity:1;}100%{stroke-opacity:0.3;}}</style><text class="f" x="200" y="25" text-anchor="middle">AI Agentic Customer Service System</text><circle class="agent flow" cx="80" cy="80" r="25"/><text class="f" x="80" y="85" text-anchor="middle" fill="white">Intent</text><circle class="agent flow" style="animation-delay:0.2s" cx="200" cy="60" r="25"/><text class="f" x="200" y="65" text-anchor="middle" fill="white">Route</text><circle class="agent flow" style="animation-delay:0.4s" cx="320" cy="80" r="25"/><text class="f" x="320" y="85" text-anchor="middle" fill="white">Resolve</text><circle class="agent flow" style="animation-delay:0.6s" cx="140" cy="140" r="25"/><text class="f" x="140" y="145" text-anchor="middle" fill="white">Escalate</text><circle class="agent flow" style="animation-delay:0.8s" cx="260" cy="140" r="25"/><text class="f" x="260" y="145" text-anchor="middle" fill="white">Learn</text><path class="connect" d="M105 80 L 175 65"/><path class="connect" d="M225 60 L 295 75"/><path class="connect" d="M185 75 L 155 125"/><path class="connect" d="M305 95 L 275 125"/><path class="connect" d="M165 140 L 235 140"/><text class="f" x="200" y="185" text-anchor="middle">24/7 Multilingual Support</text></svg>`; return c; },
            'agentic_step1': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.channel{animation:blink 2s linear infinite;}.msg{animation:flow 3s linear infinite;}@keyframes blink{0%{opacity:0.4;}50%{opacity:1;}100%{opacity:0.4;}}@keyframes flow{from{transform:translateX(-20px);opacity:0;}to{transform:translateX(20px);opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">Intent Recognition Agent</text><g class="channel"><rect x="20" y="50" width="60" height="30" fill="#4bc0c0" rx="5"/><text class="f" x="50" y="70" text-anchor="middle" fill="white">Voice</text></g><g class="channel" style="animation-delay:0.5s"><rect x="20" y="90" width="60" height="30" fill="#36a2eb" rx="5"/><text class="f" x="50" y="110" text-anchor="middle" fill="white">Chat</text></g><g class="channel" style="animation-delay:1s"><rect x="20" y="130" width="60" height="30" fill="#ff6384" rx="5"/><text class="f" x="50" y="150" text-anchor="middle" fill="white">Email</text></g><g class="msg"><path d="M90 65 L 160 65" stroke="#4bc0c0" stroke-width="3" marker-end="url(#arrowhead)"/></g><g class="msg" style="animation-delay:0.5s"><path d="M90 105 L 160 105" stroke="#36a2eb" stroke-width="3" marker-end="url(#arrowhead)"/></g><g class="msg" style="animation-delay:1s"><path d="M90 145 L 160 145" stroke="#ff6384" stroke-width="3" marker-end="url(#arrowhead)"/></g><circle cx="200" cy="105" r="35" fill="var(--accent-color)"/><text class="f" x="200" y="100" text-anchor="middle" fill="white">NLP</text><text class="f" x="200" y="115" text-anchor="middle" fill="white">Engine</text><path d="M240 105 L 300 105" stroke="var(--accent-color)" stroke-width="3" stroke-dasharray="5 5"/><rect x="310" y="85" width="70" height="40" fill="#e0e0e0" rx="5"/><text class="f" x="345" y="100" text-anchor="middle">Categorized</text><text class="f" x="345" y="115" text-anchor="middle">Intent</text><defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="var(--accent-color)"/></marker></defs></svg>`; return c; },
            'agentic_step2': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.route{animation:route 2s ease-in-out infinite alternate;transform-origin:center;}@keyframes route{from{transform:scale(0.9);}to{transform:scale(1.1);}}</style><text class="f" x="200" y="25" text-anchor="middle">Smart Routing Agent</text><rect x="50" y="50" width="80" height="30" fill="#e0e0e0" rx="5"/><text class="f" x="90" y="70" text-anchor="middle">Customer Query</text><circle class="route" cx="200" cy="100" r="30" fill="var(--accent-color)"/><text class="f" x="200" y="95" text-anchor="middle" fill="white">Smart</text><text class="f" x="200" y="110" text-anchor="middle" fill="white">Router</text><path d="M140 65 L 170 85" stroke="#333" stroke-width="2" marker-end="url(#arrowhead)"/><g><path d="M230 85 L 280 60" stroke="limegreen" stroke-width="3"/><rect x="290" y="45" width="60" height="30" fill="limegreen" rx="5"/><text class="f" x="320" y="65" text-anchor="middle" fill="white">AI Bot</text></g><g><path d="M230 100 L 280 100" stroke="orange" stroke-width="3"/><rect x="290" y="85" width="60" height="30" fill="orange" rx="5"/><text class="f" x="320" y="105" text-anchor="middle" fill="white">Human</text></g><g><path d="M230 115 L 280 140" stroke="red" stroke-width="3"/><rect x="290" y="125" width="60" height="30" fill="red" rx="5"/><text class="f" x="320" y="145" text-anchor="middle" fill="white">Expert</text></g><text class="f" x="370" y="60" text-anchor="middle" style="font-size:10px">Simple</text><text class="f" x="370" y="100" text-anchor="middle" style="font-size:10px">Medium</text><text class="f" x="370" y="140" text-anchor="middle" style="font-size:10px">Complex</text><defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#333"/></marker></defs></svg>`; return c; },
            'agentic_step3': (c) => { const co={type:'radar',data:{labels:['Knowledge Base','Billing Systems','Network Status','Customer History','Product Catalog','Policy Database'],datasets:[{label:'Data Access Speed (ms)',data:[45,67,23,89,156,78],backgroundColor:'rgba(54,162,235,0.2)',borderColor:'rgba(54,162,235,1)',borderWidth:2}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Resolution Agent - Data Access Performance'}},scales:{r:{beginAtZero:true,max:200}}}};return createChart(c,co)},
            'agentic_step4': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.transfer{animation:transfer 3s ease-in-out infinite;}@keyframes transfer{0%{transform:translateX(0);opacity:1;}50%{transform:translateX(80px);opacity:0.5;}100%{transform:translateX(160px);opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">Escalation Agent - Context Transfer</text><circle cx="80" cy="100" r="25" fill="var(--accent-color)"/><text class="f" x="80" y="95" text-anchor="middle" fill="white">AI</text><text class="f" x="80" y="110" text-anchor="middle" fill="white">Agent</text><circle cx="320" cy="100" r="25" fill="#ff6384"/><text class="f" x="320" y="95" text-anchor="middle" fill="white">Human</text><text class="f" x="320" y="110" text-anchor="middle" fill="white">Expert</text><g class="transfer"><rect x="120" y="80" width="100" height="40" fill="#e0e0e0" rx="5"/><text class="f" x="170" y="95" text-anchor="middle">Complete Context</text><text class="f" x="170" y="110" text-anchor="middle">+ History</text></g><text class="f" x="80" y="140" text-anchor="middle" style="font-size:10px">Complex Issue</text><text class="f" x="80" y="155" text-anchor="middle" style="font-size:10px">Detected</text><text class="f" x="320" y="140" text-anchor="middle" style="font-size:10px">Seamless</text><text class="f" x="320" y="155" text-anchor="middle" style="font-size:10px">Handoff</text><text class="f" x="200" y="180" text-anchor="middle" style="font-style:italic">Zero Information Loss</text></svg>`; return c; },
            'agentic_step5': (c) => { const co={type:'line',data:{labels:['Week 1','Week 2','Week 3','Week 4','Week 5','Week 6','Week 7','Week 8'],datasets:[{label:'Response Accuracy (%)',data:[78,82,85,88,91,93,95,96],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true,tension:0.4},{label:'Knowledge Base Updates',data:[12,15,18,22,28,35,42,48],borderColor:'var(--accent-color)',backgroundColor:'rgba(54,162,235,0.2)',fill:true,tension:0.4}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Learning Agent - Continuous Improvement'}},scales:{y:{beginAtZero:true}}}};return createChart(c,co)},
            'agentic_efficiency': (c) => { const co={type:'bar',data:{labels:['Response Time','First-Call Resolution'],datasets:[{label:'Before AI (%)',data:[100,68],backgroundColor:'rgba(255,99,132,0.8)'},{label:'After AI (%)',data:[13,92],backgroundColor:'rgba(75,192,192,0.8)'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Efficiency Improvements'}},scales:{y:{beginAtZero:true,max:100}}}};return createChart(c,co)},
            'agentic_satisfaction': (c) => { const co={type:'doughnut',data:{labels:['Excellent (5)','Good (4)','Average (3)','Poor (2)','Very Poor (1)'],datasets:[{data:[47,32,15,4,2],backgroundColor:['#4bc0c0','#36a2eb','#ffce56','#ff9f40','#ff6384']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Customer Satisfaction Distribution (4.7/5 Average)'}}}};return createChart(c,co)},
            'agentic_costs': (c) => { const co={type:'bar',data:{labels:['Operational Costs','Query Volume'],datasets:[{label:'Reduction/Increase (%)',data:[-43,300],backgroundColor:['#ff6384','#4bc0c0']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Business Impact: Costs vs Volume'}},scales:{y:{beginAtZero:true}}}};return createChart(c,co)},
            // Churn Prevention System Generators
            'churn_overview': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.pulse{animation:pulse 2s ease-in-out infinite alternate;}.flow{animation:flow 3s linear infinite;}.risk-high{fill:#ff6384;}.risk-medium{fill:#ffce56;}.risk-low{fill:#4bc0c0;}@keyframes pulse{from{transform:scale(0.9);opacity:0.7;}to{transform:scale(1.1);opacity:1;}}@keyframes flow{from{transform:translateX(-30px);opacity:0;}to{transform:translateX(30px);opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">AI-Powered Churn Prediction System</text><g><rect x="20" y="50" width="80" height="40" fill="#e0e0e0" rx="5"/><text class="f" x="60" y="75" text-anchor="middle">Customer Data</text></g><g class="flow"><path d="M110 70 L 160 70" stroke="var(--accent-color)" stroke-width="3" stroke-dasharray="5 5"/></g><circle class="pulse" cx="200" cy="100" r="35" fill="var(--accent-color)"/><text class="f" x="200" y="95" text-anchor="middle" fill="white">ML Engine</text><text class="f" x="200" y="110" text-anchor="middle" fill="white">Churn Risk</text><g><circle class="risk-high pulse" style="animation-delay:0.5s" cx="300" cy="60" r="15"/><text class="f" x="300" y="45" text-anchor="middle" style="font-size:10px">High Risk</text><circle class="risk-medium pulse" style="animation-delay:1s" cx="300" cy="100" r="15"/><text class="f" x="300" y="120" text-anchor="middle" style="font-size:10px">Medium</text><circle class="risk-low pulse" style="animation-delay:1.5s" cx="300" cy="140" r="15"/><text class="f" x="300" y="155" text-anchor="middle" style="font-size:10px">Low Risk</text></g><g class="flow" style="animation-delay:1s"><path d="M240 85 L 280 70" stroke="#ff6384" stroke-width="2"/><path d="M240 100 L 280 100" stroke="#ffce56" stroke-width="2"/><path d="M240 115 L 280 130" stroke="#4bc0c0" stroke-width="2"/></g><text class="f" x="200" y="185" text-anchor="middle">30-60 Days Advance Prediction</text></svg>`; return c; },
            'churn_detection': (c) => { const co={type:'radar',data:{labels:['Call Patterns','Data Usage','Billing History','Service Complaints','Network Quality','Payment Delays'],datasets:[{label:'Signal Strength',data:[85,72,94,68,76,89],backgroundColor:'rgba(255,99,132,0.2)',borderColor:'rgba(255,99,132,1)',borderWidth:2}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Churn Detection Signals'}},scales:{r:{beginAtZero:true,max:100}}}};return createChart(c,co)},
            'churn_risk_assessment': (c) => { const co={type:'scatter',data:{datasets:[{label:'High Value, High Risk',data:[{x:85,y:90},{x:78,y:88},{x:92,y:85}],backgroundColor:'#ff6384',borderColor:'#ff6384'},{label:'High Value, Low Risk',data:[{x:88,y:15},{x:91,y:12},{x:85,y:18}],backgroundColor:'#4bc0c0',borderColor:'#4bc0c0'},{label:'Low Value, High Risk',data:[{x:25,y:87},{x:18,y:92},{x:32,y:85}],backgroundColor:'#ffce56',borderColor:'#ffce56'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Customer Risk vs Value Matrix'}},scales:{x:{title:{display:true,text:'Customer Value Score'}},y:{title:{display:true,text:'Churn Risk Score'}}}}};return createChart(c,co)},
            'churn_intervention': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.channel{animation:blink 1.5s linear infinite;}.alert{animation:alert 2s ease-in-out infinite;}@keyframes blink{0%{opacity:0.4;}50%{opacity:1;}100%{opacity:0.4;}}@keyframes alert{0%{transform:scale(1);fill:#ff6384;}50%{transform:scale(1.2);fill:#ff9999;}100%{transform:scale(1);fill:#ff6384;}}</style><text class="f" x="200" y="25" text-anchor="middle">Multi-Channel Intervention System</text><circle class="alert" cx="100" cy="100" r="25"/><text class="f" x="100" y="95" text-anchor="middle" fill="white">High Risk</text><text class="f" x="100" y="110" text-anchor="middle" fill="white">Customer</text><g class="channel"><rect x="180" y="50" width="60" height="25" fill="#36a2eb" rx="5"/><text class="f" x="210" y="67" text-anchor="middle" fill="white">SMS</text><path d="M130 85 L 175 62" stroke="#36a2eb" stroke-width="2"/></g><g class="channel" style="animation-delay:0.3s"><rect x="180" y="80" width="60" height="25" fill="#4bc0c0" rx="5"/><text class="f" x="210" y="97" text-anchor="middle" fill="white">Voice Call</text><path d="M130 100 L 175 92" stroke="#4bc0c0" stroke-width="2"/></g><g class="channel" style="animation-delay:0.6s"><rect x="180" y="110" width="60" height="25" fill="#ff9f40" rx="5"/><text class="f" x="210" y="127" text-anchor="middle" fill="white">App Push</text><path d="M130 115 L 175 122" stroke="#ff9f40" stroke-width="2"/></g><g class="channel" style="animation-delay:0.9s"><rect x="180" y="140" width="60" height="25" fill="#9966ff" rx="5"/><text class="f" x="210" y="157" text-anchor="middle" fill="white">Email</text><path d="M130 125 L 175 152" stroke="#9966ff" stroke-width="2"/></g><rect x="280" y="85" width="80" height="30" fill="limegreen" rx="5"/><text class="f" x="320" y="95" text-anchor="middle" fill="white">Personalized</text><text class="f" x="320" y="108" text-anchor="middle" fill="white">Retention Offer</text><path d="M250 100 L 275 100" stroke="limegreen" stroke-width="3" stroke-dasharray="5 5"/></svg>`; return c; },
            'churn_conversation': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.comm{animation:comm 3s ease-in-out infinite alternate;}.bubble{fill:#e0e0e0;stroke:#333;stroke-width:1;}@keyframes comm{from{opacity:0.6;}to{opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">AI Conversation Agent - Multi-Modal Communication</text><circle cx="80" cy="100" r="25" fill="var(--accent-color)"/><text class="f" x="80" y="95" text-anchor="middle" fill="white">Customer</text><text class="f" x="80" y="110" text-anchor="middle" fill="white">At Risk</text><g class="comm"><ellipse class="bubble" cx="160" cy="70" rx="35" ry="20"/><text class="f" x="160" y="67" text-anchor="middle">Voice Call</text><text class="f" x="160" y="78" text-anchor="middle">"Hi, we have"</text><path d="M110 85 L 130 75" stroke="#333" stroke-width="2"/></g><g class="comm" style="animation-delay:1s"><ellipse class="bubble" cx="240" cy="70" rx="35" ry="20"/><text class="f" x="240" y="67" text-anchor="middle">SMS/Chat</text><text class="f" x="240" y="78" text-anchor="middle">"Special offer"</text><path d="M190 75 L 210 75" stroke="#333" stroke-width="2"/></g><g class="comm" style="animation-delay:2s"><ellipse class="bubble" cx="320" cy="70" rx="35" ry="20"/><text class="f" x="320" y="67" text-anchor="middle">WhatsApp</text><text class="f" x="320" y="78" text-anchor="middle">"for you!"</text><path d="M270 75 L 290 75" stroke="#333" stroke-width="2"/></g><g><ellipse class="bubble" cx="200" cy="130" rx="45" ry="25"/><text class="f" x="200" y="125" text-anchor="middle">AI Response:</text><text class="f" x="200" y="138" text-anchor="middle">"What issues are you facing?"</text><text class="f" x="200" y="150" text-anchor="middle">"Let me help with better rates"</text><path d="M320 85 L 235 110" stroke="limegreen" stroke-width="2"/></g><text class="f" x="200" y="180" text-anchor="middle" style="font-style:italic">Real-time Issue Resolution & Offer Negotiation</text></svg>`; return c; },
            'churn_offers': (c) => { const co={type:'doughnut',data:{labels:['Discounted Plans','Bonus Data','Free Minutes','Premium Services','Bill Credits'],datasets:[{data:[35,28,18,12,7],backgroundColor:['#ff6384','#36a2eb','#ffce56','#4bc0c0','#9966ff']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Dynamic Retention Offers Distribution'}}}};return createChart(c,co)},
            'churn_outcomes': (c) => { const co={type:'line',data:{labels:['Week 1','Week 2','Week 3','Week 4','Week 5','Week 6','Week 7','Week 8'],datasets:[{label:'Successful Retentions',data:[12,18,24,31,38,42,47,52],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true,tension:0.4},{label:'Failed Interventions',data:[8,7,6,5,4,4,3,3],borderColor:'#ff6384',backgroundColor:'rgba(255,99,132,0.2)',fill:true,tension:0.4}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Intervention Outcomes Tracking'}}}};return createChart(c,co)},
            'churn_reduction_chart': (c) => { const co={type:'bar',data:{labels:['Jan','Feb','Mar','Apr','May','Jun'],datasets:[{label:'Before AI (%)',data:[8.2,8.4,8.1,8.3,8.5,8.2],backgroundColor:'rgba(255,99,132,0.8)'},{label:'After AI (%)',data:[8.2,7.8,7.1,6.4,5.8,5.4],backgroundColor:'rgba(75,192,192,0.8)'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Monthly Churn Rate Reduction'}},scales:{y:{beginAtZero:true,max:10}}}};return createChart(c,co)},
            'churn_revenue_impact': (c) => { const co={type:'bar',data:{labels:['Avg CLV Before','Avg CLV After'],datasets:[{label:'Customer Lifetime Value ($)',data:[543,730],backgroundColor:['#ff9f40','#4bc0c0']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Customer Lifetime Value Impact (+$187)'}}}};return createChart(c,co)},
            'churn_campaign_roi': (c) => { const co={type:'doughnut',data:{labels:['Successful Retention (67%)','Failed Retention (33%)'],datasets:[{data:[67,33],backgroundColor:['limegreen','#ff6384']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Retention Campaign Success Rate'}}}};return createChart(c,co)},
            // Hyper-Personalized Marketing & Loyalty System Generators
            'marketing_overview': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.pulse{animation:pulse 2s ease-in-out infinite alternate;}.flow{animation:flow 3s linear infinite;}.segment{animation:segment 4s ease-in-out infinite alternate;}@keyframes pulse{from{transform:scale(0.9);opacity:0.7;}to{transform:scale(1.1);opacity:1;}}@keyframes flow{from{transform:translateX(-20px);opacity:0;}to{transform:translateX(20px);opacity:1;}}@keyframes segment{from{fill:#36a2eb;}to{fill:#4bc0c0;}}</style><text class="f" x="200" y="25" text-anchor="middle">Hyper-Personalized Marketing & Loyalty System</text><g><rect x="20" y="50" width="80" height="40" fill="#e0e0e0" rx="5"/><text class="f" x="60" y="75" text-anchor="middle">360° Customer</text><text class="f" x="60" y="88" text-anchor="middle">Data</text></g><g class="flow"><path d="M110 70 L 160 70" stroke="var(--accent-color)" stroke-width="3" stroke-dasharray="5 5"/></g><circle class="pulse" cx="200" cy="100" r="35" fill="var(--accent-color)"/><text class="f" x="200" y="95" text-anchor="middle" fill="white">ML Engine</text><text class="f" x="200" y="110" text-anchor="middle" fill="white">Personalization</text><g><circle class="segment" cx="300" cy="60" r="12"/><text class="f" x="300" y="45" text-anchor="middle" style="font-size:10px">Night Users</text><circle class="segment" style="animation-delay:1s" cx="320" cy="100" r="12"/><text class="f" x="320" y="120" text-anchor="middle" style="font-size:10px">Roamers</text><circle class="segment" style="animation-delay:2s" cx="300" cy="140" r="12"/><text class="f" x="300" y="155" text-anchor="middle" style="font-size:10px">Heavy Data</text></g><g class="flow" style="animation-delay:1s"><path d="M240 85 L 285 65" stroke="#36a2eb" stroke-width="2"/><path d="M240 100 L 305 100" stroke="#4bc0c0" stroke-width="2"/><path d="M240 115 L 285 135" stroke="#ff6384" stroke-width="2"/></g><text class="f" x="200" y="185" text-anchor="middle">Micro-Segment Targeting</text></svg>`; return c; },
            'marketing_data_unification': (c) => { const co={type:'radar',data:{labels:['CDR Data','Usage History','App Interactions','Billing Records','Support Logs','Location Data'],datasets:[{label:'Data Completeness (%)',data:[95,88,92,97,85,78],backgroundColor:'rgba(54,162,235,0.2)',borderColor:'rgba(54,162,235,1)',borderWidth:2}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'360° Customer Profile - Data Sources'}},scales:{r:{beginAtZero:true,max:100}}}};return createChart(c,co)},
            'marketing_segmentation': (c) => { const co={type:'doughnut',data:{labels:['Night-time Data Users','Weekend Callers','Roaming Professionals','Heavy Video Streamers','Price-Sensitive Users','Premium Service Users'],datasets:[{data:[18,24,16,15,19,8],backgroundColor:['#ff6384','#36a2eb','#ffce56','#4bc0c0','#9966ff','#ff9f40']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Behavioral Micro-Segments'}}}};return createChart(c,co)},
            'marketing_personalization': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.match{animation:match 2s ease-in-out infinite alternate;}.rec{fill:#4bc0c0;}.offer{fill:#ff6384;}@keyframes match{from{opacity:0.6;}to{opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">AI Recommendation Engine</text><g><circle cx="80" cy="100" r="25" fill="var(--accent-color)"/><text class="f" x="80" y="95" text-anchor="middle" fill="white">Customer</text><text class="f" x="80" y="110" text-anchor="middle" fill="white">Profile</text></g><g class="match"><rect class="rec" x="150" y="60" width="70" height="25" rx="5"/><text class="f" x="185" y="77" text-anchor="middle" fill="white">Data Bundle</text><path d="M110 85 L 145 72" stroke="#4bc0c0" stroke-width="3"/></g><g class="match" style="animation-delay:0.5s"><rect class="offer" x="150" y="90" width="70" height="25" rx="5"/><text class="f" x="185" y="107" text-anchor="middle" fill="white">Premium App</text><path d="M110 100 L 145 102" stroke="#ff6384" stroke-width="3"/></g><g class="match" style="animation-delay:1s"><rect class="rec" x="150" y="120" width="70" height="25" rx="5"/><text class="f" x="185" y="137" text-anchor="middle" fill="white">Voice Pack</text><path d="M110 115 L 145 132" stroke="#4bc0c0" stroke-width="3"/></g><g><rect x="280" y="85" width="80" height="30" fill="limegreen" rx="5"/><text class="f" x="320" y="95" text-anchor="middle" fill="white">Personalized</text><text class="f" x="320" y="108" text-anchor="middle" fill="white">Offer Match</text><path d="M230 100 L 275 100" stroke="limegreen" stroke-width="3" stroke-dasharray="5 5"/></g><text class="f" x="200" y="180" text-anchor="middle">ML-Driven Product Matching</text></svg>`; return c; },
            'marketing_loyalty': (c) => { const co={type:'bar',data:{labels:['Bronze','Silver','Gold','Platinum','Diamond'],datasets:[{label:'Customers',data:[2400,1800,1200,600,200],backgroundColor:['#cd7f32','#c0c0c0','#ffd700','#e5e4e2','#b9f2ff']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Dynamic Loyalty Tier Distribution'}}}};return createChart(c,co)},
            'marketing_delivery': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.channel{animation:optimal 3s ease-in-out infinite alternate;}.time{fill:#36a2eb;stroke:white;stroke-width:2;}@keyframes optimal{from{opacity:0.6;}to{opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">Optimal Delivery Channel & Timing</text><g><circle cx="80" cy="100" r="25" fill="var(--accent-color)"/><text class="f" x="80" y="95" text-anchor="middle" fill="white">Customer</text><text class="f" x="80" y="110" text-anchor="middle" fill="white">Analysis</text></g><g class="channel"><rect x="150" y="50" width="60" height="25" fill="#36a2eb" rx="5"/><text class="f" x="180" y="67" text-anchor="middle" fill="white">SMS 9AM</text><path d="M110 85 L 145 62" stroke="#36a2eb" stroke-width="2"/></g><g class="channel" style="animation-delay:1s"><rect x="150" y="80" width="60" height="25" fill="#4bc0c0" rx="5"/><text class="f" x="180" y="97" text-anchor="middle" fill="white">App 2PM</text><path d="M110 100 L 145 92" stroke="#4bc0c0" stroke-width="2"/></g><g class="channel" style="animation-delay:2s"><rect x="150" y="110" width="60" height="25" fill="#ff9f40" rx="5"/><text class="f" x="180" y="127" text-anchor="middle" fill="white">Email 7PM</text><path d="M110 115 L 145 122" stroke="#ff9f40" stroke-width="2"/></g><g><circle class="time" cx="280" cy="60" r="15"/><text class="f" x="280" y="45" text-anchor="middle" style="font-size:10px">Peak Times</text><circle class="time" cx="320" cy="100" r="15"/><text class="f" x="320" y="120" text-anchor="middle" style="font-size:10px">Channels</text><circle class="time" cx="280" cy="140" r="15"/><text class="f" x="280" y="155" text-anchor="middle" style="font-size:10px">Response</text></g><text class="f" x="200" y="180" text-anchor="middle">Behavioral Pattern Optimization</text></svg>`; return c; },
            'marketing_learning': (c) => { const co={type:'line',data:{labels:['Week 1','Week 2','Week 3','Week 4','Week 5','Week 6','Week 7','Week 8'],datasets:[{label:'Campaign Conversion Rate (%)',data:[8.2,9.1,10.5,12.3,14.1,15.8,17.2,18.6],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true,tension:0.4},{label:'A/B Test Improvements (%)',data:[5,7,12,18,25,31,38,44],borderColor:'var(--accent-color)',backgroundColor:'rgba(54,162,235,0.2)',fill:true,tension:0.4}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Continuous Learning & Optimization'}}}};return createChart(c,co)},
            'marketing_arpu': (c) => { const co={type:'bar',data:{labels:['Jan','Feb','Mar','Apr','May','Jun'],datasets:[{label:'Before Personalization ($)',data:[28.40,28.10,27.90,28.20,28.50,28.30],backgroundColor:'rgba(255,99,132,0.8)'},{label:'After Personalization ($)',data:[28.40,29.20,30.50,32.10,34.20,34.90],backgroundColor:'rgba(75,192,192,0.8)'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'ARPU Growth Through Personalization (+23%)'}}}};return createChart(c,co)},
            'marketing_conversion': (c) => { const co={type:'bar',data:{labels:['Conversion Rate','Engagement Rate'],datasets:[{label:'Generic Campaigns (%)',data:[12.5,28.3],backgroundColor:'rgba(255,99,132,0.8)'},{label:'Personalized Campaigns (%)',data:[14.4,39.6],backgroundColor:'rgba(75,192,192,0.8)'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Campaign Performance Improvement'}}}};return createChart(c,co)},
            'marketing_loyalty_scores': (c) => { const co={type:'doughnut',data:{labels:['Highly Loyal (8-10)','Moderately Loyal (6-7)','Low Loyalty (4-5)','At Risk (1-3)'],datasets:[{data:[65,25,8,2],backgroundColor:['#4bc0c0','#36a2eb','#ffce56','#ff6384']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Customer Loyalty Distribution (Avg: 8.2/10)'}}}};return createChart(c,co)},
            // Proactive Churn Intervention System Generators
            'intervention_overview': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.alert{animation:alert 2s ease-in-out infinite;}.action{animation:action 3s linear infinite;}.success{fill:limegreen;}@keyframes alert{0%{transform:scale(1);fill:#ff6384;}50%{transform:scale(1.2);fill:#ff9999;}100%{transform:scale(1);fill:#ff6384;}}@keyframes action{from{stroke-dashoffset:100;}to{stroke-dashoffset:0;}}</style><text class="f" x="200" y="25" text-anchor="middle">Proactive Churn Intervention System</text><g><rect x="20" y="70" width="70" height="30" fill="#e0e0e0" rx="5"/><text class="f" x="55" y="90" text-anchor="middle">Churn Risk</text><text class="f" x="55" y="102" text-anchor="middle">Alert</text></g><circle class="alert" cx="130" cy="100" r="20"/><text class="f" x="130" y="105" text-anchor="middle" fill="white">85%</text><g class="action"><path d="M155 100 L 220 100" stroke="var(--accent-color)" stroke-width="4" stroke-dasharray="100"/></g><g><rect x="230" y="70" width="70" height="30" fill="var(--accent-color)" rx="5"/><text class="f" x="265" y="85" text-anchor="middle" fill="white">Instant</text><text class="f" x="265" y="98" text-anchor="middle" fill="white">Intervention</text></g><g><path d="M310 85 L 350 65" stroke="limegreen" stroke-width="3"/><rect class="success" x="360" y="50" width="35" height="30" rx="5"/><text class="f" x="377" y="70" text-anchor="middle" fill="white">72%</text><text class="f" x="377" y="45" text-anchor="middle" style="font-size:10px">Accept</text></g><g><path d="M310 95 L 350 115" stroke="#ff6384" stroke-width="3"/><rect x="360" y="100" width="35" height="30" fill="#ff6384" rx="5"/><text class="f" x="377" y="120" text-anchor="middle" fill="white">28%</text><text class="f" x="377" y="135" text-anchor="middle" style="font-size:10px">Decline</text></g><text class="f" x="200" y="180" text-anchor="middle">Real-time Automated Retention</text></svg>`; return c; },
            'intervention_trigger': (c) => { const co={type:'line',data:{labels:['Mon','Tue','Wed','Thu','Fri','Sat','Sun'],datasets:[{label:'Churn Risk Score',data:[45,52,68,78,85,89,92],borderColor:'#ff6384',backgroundColor:'rgba(255,99,132,0.2)',fill:true},{label:'Intervention Threshold',data:[85,85,85,85,85,85,85],borderColor:'red',borderDash:[5,5]}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Churn Risk Monitoring & Trigger Points'}},scales:{y:{min:0,max:100}}}};return createChart(c,co)},
            'intervention_offer_selection': (c) => { const co={type:'scatter',data:{datasets:[{label:'Data Bundles',data:[{x:75,y:85},{x:68,y:78},{x:82,y:92}],backgroundColor:'#36a2eb',borderColor:'#36a2eb'},{label:'Discount Plans',data:[{x:85,y:65},{x:78,y:72},{x:90,y:58}],backgroundColor:'#4bc0c0',borderColor:'#4bc0c0'},{label:'Premium Services',data:[{x:45,y:95},{x:52,y:88},{x:38,y:92}],backgroundColor:'#ff6384',borderColor:'#ff6384'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Next-Best-Offer Selection Matrix'}},scales:{x:{title:{display:true,text:'Customer Value Score'}},y:{title:{display:true,text:'Offer Success Probability'}}}}};return createChart(c,co)},
            'intervention_outreach': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.outreach{animation:outreach 2s ease-in-out infinite alternate;}.msg{fill:#e0e0e0;stroke:#333;stroke-width:1;}@keyframes outreach{from{opacity:0.6;}to{opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">Multi-Channel Automated Outreach</text><circle cx="80" cy="100" r="25" fill="#ff6384"/><text class="f" x="80" y="95" text-anchor="middle" fill="white">At-Risk</text><text class="f" x="80" y="110" text-anchor="middle" fill="white">Customer</text><g class="outreach"><rect class="msg" x="140" y="50" width="120" height="30" rx="5"/><text class="f" x="200" y="65" text-anchor="middle">Voice: "Hi Sarah, we have"</text><text class="f" x="200" y="78" text-anchor="middle">"a special offer for you..."</text><path d="M110 85 L 135 65" stroke="#4bc0c0" stroke-width="3"/></g><g class="outreach" style="animation-delay:0.7s"><rect class="msg" x="140" y="90" width="120" height="30" rx="5"/><text class="f" x="200" y="105" text-anchor="middle">SMS: "Get 50% off your</text><text class="f" x="200" y="118" text-anchor="middle">next recharge! Reply YES"</text><path d="M110 100 L 135 105" stroke="#36a2eb" stroke-width="3"/></g><g class="outreach" style="animation-delay:1.4s"><rect class="msg" x="140" y="130" width="120" height="30" rx="5"/><text class="f" x="200" y="145" text-anchor="middle">App Push: "Don't miss out</text><text class="f" x="200" y="158" text-anchor="middle">on exclusive savings!"</text><path d="M110 115 L 135 145" stroke="#ff9f40" stroke-width="3"/></g><g><rect x="300" y="85" width="80" height="30" fill="limegreen" rx="5"/><text class="f" x="340" y="95" text-anchor="middle" fill="white">Personalized</text><text class="f" x="340" y="108" text-anchor="middle" fill="white">Script</text><path d="M270 100 L 295 100" stroke="limegreen" stroke-width="3"/></g><text class="f" x="200" y="185" text-anchor="middle">Synchronized Multi-Modal Contact</text></svg>`; return c; },
            'intervention_conversation': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 10px var(--font-family);}.chat{animation:chat 4s ease-in-out infinite alternate;}.bubble{fill:#e8f4f8;stroke:#333;stroke-width:1;}.ai-bubble{fill:#d4edda;}</style><text class="f" x="200" y="25" text-anchor="middle">AI Conversation Management</text><ellipse class="bubble chat" cx="120" cy="60" rx="50" ry="20"/><text class="f" x="120" y="57" text-anchor="middle">"I'm having billing issues"</text><text class="f" x="120" y="68" text-anchor="middle">"and poor network"</text><ellipse class="ai-bubble chat" style="animation-delay:1s" cx="280" cy="60" rx="50" ry="20"/><text class="f" x="280" y="57" text-anchor="middle">"I understand. Let me help"</text><text class="f" x="280" y="68" text-anchor="middle">"with a special package"</text><ellipse class="bubble chat" style="animation-delay:2s" cx="120" cy="110" rx="40" ry="15"/><text class="f" x="120" y="113" text-anchor="middle">"What's the offer?"</text><ellipse class="ai-bubble chat" style="animation-delay:3s" cx="280" cy="110" rx="50" ry="20"/><text class="f" x="280" y="107" text-anchor="middle">"50% off for 6 months"</text><text class="f" x="280" y="118" text-anchor="middle">"+ 5GB bonus data"</text><ellipse class="bubble chat" style="animation-delay:4s" cx="120" cy="160" rx="30" ry="15"/><text class="f" x="120" y="163" text-anchor="middle">"Yes, please!"</text><circle cx="350" cy="160" r="20" fill="limegreen"/><text class="f" x="350" y="167" text-anchor="middle" fill="white">Retained!</text><path d="M200 100 L 190 100" stroke="#333" stroke-width="2"/><path d="M210 100 L 200 100" stroke="#333" stroke-width="2"/><text class="f" x="200" y="185" text-anchor="middle">Real-time Negotiation & Resolution</text></svg>`; return c; },
            'intervention_provisioning': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.provision{animation:provision 3s linear infinite;}.api{stroke:var(--accent-color);stroke-width:3;}@keyframes provision{from{stroke-dashoffset:200;}to{stroke-dashoffset:0;}}</style><text class="f" x="200" y="25" text-anchor="middle">Automated Provisioning System</text><g><rect x="20" y="80" width="80" height="40" fill="limegreen" rx="5"/><text class="f" x="60" y="95" text-anchor="middle" fill="white">Customer</text><text class="f" x="60" y="108" text-anchor="middle" fill="white">Accepts</text></g><g class="provision"><path class="api" d="M110 100 L 180 100" stroke-dasharray="200"/></g><g><rect x="190" y="80" width="80" height="40" fill="var(--accent-color)" rx="5"/><text class="f" x="230" y="95" text-anchor="middle" fill="white">API Call</text><text class="f" x="230" y="108" text-anchor="middle" fill="white">Trigger</text></g><g class="provision" style="animation-delay:1s"><path class="api" d="M280 100 L 350 100" stroke-dasharray="200"/></g><g><rect x="360" y="60" width="35" height="80" fill="#4bc0c0" rx="5"/><text class="f" x="377" y="80" text-anchor="middle" fill="white">T-Nor</text><text class="f" x="377" y="93" text-anchor="middle" fill="white">Billing</text><text class="f" x="377" y="106" text-anchor="middle" fill="white">System</text><text class="f" x="377" y="119" text-anchor="middle" fill="white">Update</text></g><text class="f" x="60" y="140" text-anchor="middle" style="font-size:10px">Voice/SMS/App</text><text class="f" x="230" y="140" text-anchor="middle" style="font-size:10px">REST API</text><text class="f" x="377" y="155" text-anchor="middle" style="font-size:10px">Instant</text><text class="f" x="200" y="180" text-anchor="middle">Real-time Account Provisioning</text></svg>`; return c; },
            'intervention_tracking': (c) => { const co={type:'line',data:{labels:['Week 1','Week 2','Week 3','Week 4','Week 5','Week 6','Week 7','Week 8'],datasets:[{label:'Intervention Success Rate (%)',data:[58,62,67,71,72,74,76,78],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true,tension:0.4},{label:'Model Accuracy (%)',data:[82,84,87,89,91,93,94,95],borderColor:'var(--accent-color)',backgroundColor:'rgba(54,162,235,0.2)',fill:true,tension:0.4}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Intervention Performance Tracking'}}}};return createChart(c,co)},
            'intervention_churn_reduction': (c) => { const co={type:'bar',data:{labels:['Control Group','Intervention Group'],datasets:[{label:'Churn Rate (%)',data:[8.2,5.7],backgroundColor:['#ff6384','#4bc0c0']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Churn Reduction in Pilot Regions (-30%)'}}}};return createChart(c,co)},
            'intervention_roi': (c) => { const co={type:'doughnut',data:{labels:['ROI: 380%','Investment Cost'],datasets:[{data:[380,100],backgroundColor:['limegreen','#e0e0e0']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Intervention ROI & Offer Acceptance (72%)'}}}};return createChart(c,co)},
            'intervention_satisfaction': (c) => { const co={type:'bar',data:{labels:['Satisfaction Score','Positive Feedback'],datasets:[{label:'Rating/Percentage',data:[4.6,89],backgroundColor:['#4bc0c0','limegreen']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Customer Response to Interventions'}},scales:{y:{beginAtZero:true,max:100}}}};return createChart(c,co)},
            // Social Media Sentiment & Escalation System Generators
            'sentiment_overview': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.monitor{animation:monitor 3s ease-in-out infinite alternate;}.sentiment{animation:sentiment 2s linear infinite;}.positive{fill:limegreen;}.negative{fill:#ff6384;}.neutral{fill:#ffce56;}@keyframes monitor{from{opacity:0.7;}to{opacity:1;}}@keyframes sentiment{from{transform:rotate(0deg);}to{transform:rotate(360deg);}}</style><text class="f" x="200" y="25" text-anchor="middle">Social Media Sentiment Monitoring System</text><g class="monitor"><rect x="20" y="60" width="60" height="40" fill="#36a2eb" rx="5"/><text class="f" x="50" y="80" text-anchor="middle" fill="white">Social</text><text class="f" x="50" y="93" text-anchor="middle" fill="white">Media</text></g><g class="monitor" style="animation-delay:0.5s"><rect x="20" y="110" width="60" height="40" fill="#4bc0c0" rx="5"/><text class="f" x="50" y="130" text-anchor="middle" fill="white">Reviews</text><text class="f" x="50" y="143" text-anchor="middle" fill="white">Forums</text></g><circle cx="150" cy="110" r="30" fill="var(--accent-color)"/><text class="f" x="150" y="105" text-anchor="middle" fill="white">NLP</text><text class="f" x="150" y="118" text-anchor="middle" fill="white">Engine</text><g class="sentiment" style="transform-origin:150px 110px"><path d="M115 110 L 95 110" stroke="white" stroke-width="2"/><path d="M185 110 L 205 110" stroke="white" stroke-width="2"/></g><g><circle class="positive" cx="250" cy="70" r="15"/><text class="f" x="250" y="55" text-anchor="middle" style="font-size:10px">Positive</text><circle class="negative" cx="280" cy="110" r="15"/><text class="f" x="280" y="130" text-anchor="middle" style="font-size:10px">Negative</text><circle class="neutral" cx="220" cy="140" r="15"/><text class="f" x="220" y="160" text-anchor="middle" style="font-size:10px">Neutral</text></g><g><rect x="320" y="80" width="60" height="30" fill="#ff9f40" rx="5"/><text class="f" x="350" y="95" text-anchor="middle" fill="white">Auto</text><text class="f" x="350" y="108" text-anchor="middle" fill="white">Escalation</text><path d="M300 100 L 315 95" stroke="#ff9f40" stroke-width="3"/></g><text class="f" x="200" y="185" text-anchor="middle">Real-time Brand Protection</text></svg>`; return c; },
            'sentiment_ingestion': (c) => { const co={type:'radar',data:{labels:['Twitter/X','Facebook','Instagram','App Store','Play Store','Forums'],datasets:[{label:'Mentions/Hour',data:[125,89,67,34,42,28],backgroundColor:'rgba(54,162,235,0.2)',borderColor:'rgba(54,162,235,1)',borderWidth:2}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Social Media Data Sources - Mention Volume'}},scales:{r:{beginAtZero:true}}}};return createChart(c,co)},
            'sentiment_analysis': (c) => { const co={type:'doughnut',data:{labels:['Network Issues','Billing Problems','Customer Service','Promotions','General Feedback'],datasets:[{data:[35,28,22,10,5],backgroundColor:['#ff6384','#36a2eb','#ffce56','#4bc0c0','#9966ff']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Topic Classification Distribution'}}}};return createChart(c,co)},
            'sentiment_triage': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.escalate{animation:escalate 2s ease-in-out infinite;}.priority{fill:#ff6384;}.medium{fill:#ffce56;}.low{fill:#4bc0c0;}@keyframes escalate{from{transform:scale(1);}to{transform:scale(1.1);}}</style><text class="f" x="200" y="25" text-anchor="middle">Intelligent Triage & Escalation</text><g><rect x="20" y="70" width="80" height="30" fill="#e0e0e0" rx="5"/><text class="f" x="60" y="90" text-anchor="middle">Negative</text><text class="f" x="60" y="102" text-anchor="middle">Mention</text></g><g><rect x="150" y="50" width="100" height="25" fill="var(--accent-color)" rx="5"/><text class="f" x="200" y="67" text-anchor="middle" fill="white">Classification Engine</text></g><g class="escalate"><rect class="priority" x="280" y="40" width="80" height="25" rx="5"/><text class="f" x="320" y="57" text-anchor="middle" fill="white">P1: NOC Alert</text><path d="M250 55 L 275 52" stroke="#ff6384" stroke-width="3"/></g><g><rect class="medium" x="280" y="80" width="80" height="25" rx="5"/><text class="f" x="320" y="97" text-anchor="middle" fill="white">P2: CRM Ticket</text><path d="M250 75 L 275 92" stroke="#ffce56" stroke-width="2"/></g><g><rect class="low" x="280" y="120" width="80" height="25" rx="5"/><text class="f" x="320" y="137" text-anchor="middle" fill="white">P3: Review</text><path d="M250 95 L 275 132" stroke="#4bc0c0" stroke-width="2"/></g><text class="f" x="60" y="130" text-anchor="middle" style="font-size:10px">Topic + Sentiment</text><text class="f" x="320" y="35" text-anchor="middle" style="font-size:10px">Network Outage</text><text class="f" x="320" y="75" text-anchor="middle" style="font-size:10px">Billing Issue</text><text class="f" x="320" y="115" text-anchor="middle" style="font-size:10px">General</text><text class="f" x="200" y="180" text-anchor="middle">Smart Priority Assignment</text></svg>`; return c; },
            'sentiment_response': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 10px var(--font-family);}.response{animation:response 3s ease-in-out infinite alternate;}.reply{fill:#e8f4f8;stroke:#333;stroke-width:1;}.auto{fill:#d4edda;}@keyframes response{from{opacity:0.6;}to{opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">Automated Response Generation</text><ellipse class="reply response" cx="100" cy="70" rx="60" ry="25"/><text class="f" x="100" y="67" text-anchor="middle">"T-Nor network is down</text><text class="f" x="100" y="78" text-anchor="middle">in my area again!"</text><ellipse class="auto response" style="animation-delay:1s" cx="300" cy="70" rx="70" ry="25"/><text class="f" x="300" y="64" text-anchor="middle">"We're sorry to hear about"</text><text class="f" x="300" y="75" text-anchor="middle">"this issue. Please DM us"</text><text class="f" x="300" y="86" text-anchor="middle">"your location for investigation."</text><ellipse class="reply response" style="animation-delay:2s" cx="100" cy="130" rx="50" ry="20"/><text class="f" x="100" y="127" text-anchor="middle">"Thanks for quick"</text><text class="f" x="100" y="138" text-anchor="middle">"response!"</text><g><rect x="180" y="100" width="40" height="20" fill="var(--accent-color)" rx="5"/><text class="f" x="200" y="113" text-anchor="middle" fill="white">AI Bot</text></g><path d="M170 80 L 230 80" stroke="var(--accent-color)" stroke-width="2"/><path d="M230 80 L 170 80" stroke="limegreen" stroke-width="2" stroke-dasharray="5 5"/><text class="f" x="200" y="180" text-anchor="middle">Contextual Brand Voice Responses</text></svg>`; return c; },
            'sentiment_insights': (c) => { const co={type:'line',data:{labels:['6AM','9AM','12PM','3PM','6PM','9PM','12AM','3AM'],datasets:[{label:'Positive Sentiment',data:[12,18,25,22,28,35,20,8],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true},{label:'Negative Sentiment',data:[8,15,22,18,25,30,15,5],borderColor:'#ff6384',backgroundColor:'rgba(255,99,132,0.2)',fill:true},{label:'Neutral Sentiment',data:[20,25,30,28,32,35,25,15],borderColor:'#ffce56',backgroundColor:'rgba(255,206,86,0.2)',fill:true}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Sentiment Trends Throughout Day'}}}};return createChart(c,co)},
            'sentiment_early_warning': (c) => { const co={type:'bar',data:{labels:['Network Issues','Billing Problems','Service Outages','App Crashes'],datasets:[{label:'Social Detection (mins)',data:[12,18,8,15],backgroundColor:'limegreen'},{label:'Internal Detection (mins)',data:[45,72,38,65],backgroundColor:'#ff6384'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Early Warning: Social vs Internal Detection Times'}}}};return createChart(c,co)},
            'sentiment_response_time': (c) => { const co={type:'bar',data:{labels:['Before AI','After AI'],datasets:[{label:'Mean Time to Resolution (hours)',data:[4.8,1.2],backgroundColor:['#ff6384','#4bc0c0']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Response Time Improvement (-75%)'}}}};return createChart(c,co)},
            'sentiment_brand_improvement': (c) => { const co={type:'bar',data:{labels:['Jan','Feb','Mar','Apr','May','Jun'],datasets:[{label:'Brand Sentiment (%)',data:[-12,-8,-2,5,12,18],backgroundColor:function(context){const value=context.parsed.y;return value<0?'#ff6384':'#4bc0c0';}}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Brand Sentiment Improvement (-12% to +18%)'}},scales:{y:{beginAtZero:true}}}};return createChart(c,co)},
            'sentiment_issue_detection': (c) => { const co={type:'doughnut',data:{labels:['Detected via Social (94%)','Missed by Social (6%)'],datasets:[{data:[94,6],backgroundColor:['limegreen','#ff6384']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Network Issue Detection Rate'}}}};return createChart(c,co)},
            // Network Optimization & Predictive Maintenance System Generators
            'network_overview': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.tower{animation:tower 3s ease-in-out infinite alternate;}.alert{animation:alert 2s ease-in-out infinite;}.optimize{animation:optimize 4s linear infinite;}@keyframes tower{from{opacity:0.7;}to{opacity:1;}}@keyframes alert{0%{transform:scale(1);fill:#ffce56;}50%{transform:scale(1.1);fill:#ff6384;}100%{transform:scale(1);fill:#ffce56;}}@keyframes optimize{from{stroke-dashoffset:300;}to{stroke-dashoffset:0;}}</style><text class="f" x="200" y="25" text-anchor="middle">AI-Powered Network Optimization System</text><g class="tower"><rect x="50" y="80" width="15" height="60" fill="#333"/><path d="M50 80 L 35 70 L 65 70 Z" fill="#ff6384"/><path d="M35 70 L 25 60 M 75 70 L 85 60" stroke="#333" stroke-width="2"/><text class="f" x="57" y="155" text-anchor="middle" style="font-size:10px">Cell Tower</text></g><g class="tower" style="animation-delay:0.5s"><rect x="150" y="90" width="15" height="50" fill="#333"/><path d="M150 90 L 135 80 L 165 80 Z" fill="#4bc0c0"/><path d="M135 80 L 125 70 M 175 80 L 185 70" stroke="#333" stroke-width="2"/><text class="f" x="157" y="155" text-anchor="middle" style="font-size:10px">Base Station</text></g><g class="tower" style="animation-delay:1s"><rect x="250" y="85" width="15" height="55" fill="#333"/><path d="M250 85 L 235 75 L 265 75 Z" fill="#36a2eb"/><path d="M235 75 L 225 65 M 275 75 L 285 65" stroke="#333" stroke-width="2"/><text class="f" x="257" y="155" text-anchor="middle" style="font-size:10px">Router</text></g><circle class="alert" cx="57" cy="65" r="8"/><circle cx="200" cy="50" r="30" fill="var(--accent-color)"/><text class="f" x="200" y="45" text-anchor="middle" fill="white">AI Brain</text><text class="f" x="200" y="58" text-anchor="middle" fill="white">99.99%</text><g class="optimize"><path d="M170 50 L 90 75" stroke="limegreen" stroke-width="3" stroke-dasharray="300"/><path d="M200 80 L 157 95" stroke="limegreen" stroke-width="3" stroke-dasharray="300"/><path d="M230 50 L 250 75" stroke="limegreen" stroke-width="3" stroke-dasharray="300"/></g><text class="f" x="350" y="100" text-anchor="middle">Predictive</text><text class="f" x="350" y="115" text-anchor="middle">Maintenance</text><text class="f" x="200" y="185" text-anchor="middle">Autonomous Network Intelligence</text></svg>`; return c; },
            'network_data_collection': (c) => { const co={type:'radar',data:{labels:['Cell Towers','Base Stations','Switches','Routers','Fiber Links','Core Network'],datasets:[{label:'Data Points/Minute',data:[450,380,290,320,180,240],backgroundColor:'rgba(54,162,235,0.2)',borderColor:'rgba(54,162,235,1)',borderWidth:2}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Network Infrastructure Monitoring'}},scales:{r:{beginAtZero:true}}}};return createChart(c,co)},
            'network_anomaly_detection': (c) => { const co={type:'line',data:{labels:['00:00','04:00','08:00','12:00','16:00','20:00','24:00'],datasets:[{label:'Normal Pattern',data:[20,15,45,75,85,60,35],borderColor:'#4bc0c0',backgroundColor:'rgba(75,192,192,0.2)',fill:true},{label:'Anomaly Detected',data:[22,18,48,92,88,65,38],borderColor:'#ff6384',backgroundColor:'rgba(255,99,132,0.2)',fill:false,borderDash:[5,5]}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Traffic Pattern Anomaly Detection'}}}};return createChart(c,co)},
            'network_predictive_maintenance': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.predict{animation:predict 3s ease-in-out infinite alternate;}.maintenance{animation:maintenance 2s ease-in-out infinite;}.schedule{fill:#4bc0c0;stroke:white;stroke-width:2;}@keyframes predict{from{opacity:0.6;}to{opacity:1;}}@keyframes maintenance{from{transform:scale(1);}to{transform:scale(1.1);}}</style><text class="f" x="200" y="25" text-anchor="middle">Predictive Maintenance Workflow</text><g class="predict"><rect x="30" y="70" width="80" height="40" fill="#ff9f40" rx="5"/><text class="f" x="70" y="85" text-anchor="middle" fill="white">Equipment</text><text class="f" x="70" y="98" text-anchor="middle" fill="white">Health Data</text></g><g class="predict" style="animation-delay:0.5s"><rect x="160" y="70" width="80" height="40" fill="var(--accent-color)" rx="5"/><text class="f" x="200" y="85" text-anchor="middle" fill="white">ML Prediction</text><text class="f" x="200" y="98" text-anchor="middle" fill="white">Engine</text></g><g class="maintenance"><rect x="290" y="50" width="80" height="25" fill="limegreen" rx="5"/><text class="f" x="330" y="67" text-anchor="middle" fill="white">Schedule Maintenance</text><path d="M250 80 L 285 62" stroke="limegreen" stroke-width="3"/></g><g><rect x="290" y="90" width="80" height="25" fill="#ffce56" rx="5"/><text class="f" x="330" y="107" text-anchor="middle" fill="white">Order Parts</text><path d="M250 90 L 285 102" stroke="#ffce56" stroke-width="2"/></g><g><rect x="290" y="130" width="80" height="25" fill="#ff6384" rx="5"/><text class="f" x="330" y="147" text-anchor="middle" fill="white">Alert Teams</text><path d="M250 100 L 285 142" stroke="#ff6384" stroke-width="2"/></g><text class="f" x="70" y="130" text-anchor="middle" style="font-size:10px">Performance Metrics</text><text class="f" x="200" y="130" text-anchor="middle" style="font-size:10px">Failure Prediction</text><text class="f" x="200" y="180" text-anchor="middle">Prevent Issues Before They Occur</text></svg>`; return c; },
            'network_capacity_optimization': (c) => { const co={type:'bar',data:{labels:['Peak Hours','Off-Peak','Weekend','Holiday'],datasets:[{label:'Before Optimization (%)',data:[95,45,70,55],backgroundColor:'rgba(255,99,132,0.8)'},{label:'After Optimization (%)',data:[78,48,65,52],backgroundColor:'rgba(75,192,192,0.8)'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Network Capacity Utilization Optimization'}},scales:{y:{beginAtZero:true,max:100}}}};return createChart(c,co)},
            'network_self_healing': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.heal{animation:heal 2s ease-in-out infinite;}.issue{fill:#ff6384;}.fix{fill:limegreen;}.reroute{animation:reroute 3s linear infinite;}@keyframes heal{from{transform:scale(1);}to{transform:scale(1.1);}}@keyframes reroute{from{stroke-dashoffset:200;}to{stroke-dashoffset:0;}}</style><text class="f" x="200" y="25" text-anchor="middle">Self-Healing Network Response</text><g><circle class="issue heal" cx="80" cy="100" r="20"/><text class="f" x="80" y="95" text-anchor="middle" fill="white">Network</text><text class="f" x="80" y="108" text-anchor="middle" fill="white">Issue</text></g><g><rect x="150" y="70" width="100" height="30" fill="var(--accent-color)" rx="5"/><text class="f" x="200" y="90" text-anchor="middle" fill="white">Auto-Detection</text><text class="f" x="200" y="102" text-anchor="middle" fill="white">& Response</text></g><g class="reroute"><path d="M260 85 L 320 65" stroke="limegreen" stroke-width="4" stroke-dasharray="200"/><text class="f" x="340" y="62" text-anchor="middle" style="font-size:10px">Reroute Traffic</text></g><g class="reroute" style="animation-delay:0.5s"><path d="M260 95 L 320 95" stroke="#36a2eb" stroke-width="4" stroke-dasharray="200"/><text class="f" x="340" y="92" text-anchor="middle" style="font-size:10px">Activate Backup</text></g><g class="reroute" style="animation-delay:1s"><path d="M260 105 L 320 125" stroke="#ffce56" stroke-width="4" stroke-dasharray="200"/><text class="f" x="340" y="128" text-anchor="middle" style="font-size:10px">Adjust Power</text></g><circle class="fix heal" style="animation-delay:1.5s" cx="350" cy="160" r="15"/><text class="f" x="350" y="167" text-anchor="middle" fill="white">Fixed</text><text class="f" x="200" y="180" text-anchor="middle">Automatic Issue Resolution</text></svg>`; return c; },
            'network_performance_monitoring': (c) => { const co={type:'line',data:{labels:['Jan','Feb','Mar','Apr','May','Jun'],datasets:[{label:'Network Uptime (%)',data:[99.85,99.89,99.92,99.94,99.96,99.97],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true},{label:'Customer Experience Score',data:[8.2,8.5,8.8,9.0,9.1,9.1],borderColor:'#36a2eb',backgroundColor:'rgba(54,162,235,0.2)',fill:true,yAxisID:'y1'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Network Performance & Customer Experience'}},scales:{y:{beginAtZero:true,max:100,position:'left'},y1:{type:'linear',display:true,position:'right',min:0,max:10}}}};return createChart(c,co)},
            'network_uptime_improvement': (c) => { const co={type:'bar',data:{labels:['Before AI','After AI'],datasets:[{label:'Network Uptime (%)',data:[99.82,99.97],backgroundColor:['#ff9f40','limegreen']},{label:'Unplanned Outages',data:[28,4],backgroundColor:['#ff6384','#4bc0c0']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Network Reliability Improvement'}}}};return createChart(c,co)},
            'network_maintenance_cost': (c) => { const co={type:'doughnut',data:{labels:['Cost Savings (42%)','Remaining Costs (58%)'],datasets:[{data:[42,58],backgroundColor:['limegreen','#e0e0e0']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Maintenance Cost Reduction'}}}};return createChart(c,co)},
            'network_customer_experience': (c) => { const co={type:'bar',data:{labels:['Network Quality','Issue Resolution','Service Reliability'],datasets:[{label:'Before (Score/10)',data:[7.8,6.5,8.0],backgroundColor:'rgba(255,99,132,0.8)'},{label:'After (Score/10)',data:[9.1,8.9,9.3],backgroundColor:'rgba(75,192,192,0.8)'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Customer Experience Improvements'}},scales:{y:{beginAtZero:true,max:10}}}};return createChart(c,co)},
            // Revenue Assurance & Fraud Detection System Generators
            'revenue_overview': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.monitor{animation:monitor 2s ease-in-out infinite alternate;}.fraud{animation:fraud 1.5s ease-in-out infinite;}.protect{fill:limegreen;stroke:white;stroke-width:2;}@keyframes monitor{from{opacity:0.7;}to{opacity:1;}}@keyframes fraud{0%{transform:scale(1);fill:#ff6384;}50%{transform:scale(1.2);fill:#ff9999;}100%{transform:scale(1);fill:#ff6384;}}</style><text class="f" x="200" y="25" text-anchor="middle">Revenue Protection & Fraud Detection System</text><g class="monitor"><rect x="30" y="70" width="70" height="40" fill="#36a2eb" rx="5"/><text class="f" x="65" y="85" text-anchor="middle" fill="white">Transaction</text><text class="f" x="65" y="98" text-anchor="middle" fill="white">Monitoring</text></g><circle class="fraud" cx="150" cy="90" r="20"/><text class="f" x="150" y="95" text-anchor="middle" fill="white">Fraud</text><text class="f" x="150" y="105" text-anchor="middle" fill="white">Alert</text><g><rect x="200" y="70" width="70" height="40" fill="var(--accent-color)" rx="5"/><text class="f" x="235" y="85" text-anchor="middle" fill="white">AI Analysis</text><text class="f" x="235" y="98" text-anchor="middle" fill="white">Engine</text></g><g><rect x="310" y="60" width="60" height="25" fill="limegreen" rx="5"/><text class="f" x="340" y="77" text-anchor="middle" fill="white">Block Fraud</text><path d="M275 80 L 305 72" stroke="limegreen" stroke-width="3"/></g><g><rect x="310" y="90" width="60" height="25" fill="#ffce56" rx="5"/><text class="f" x="340" y="107" text-anchor="middle" fill="white">Recover $$</text><path d="M275 90 L 305 102" stroke="#ffce56" stroke-width="3"/></g><g><rect x="310" y="120" width="60" height="25" fill="#4bc0c0" rx="5"/><text class="f" x="340" y="137" text-anchor="middle" fill="white">Report</text><path d="M275 100 L 305 132" stroke="#4bc0c0" stroke-width="3"/></g><text class="f" x="65" y="130" text-anchor="middle" style="font-size:10px">$2.3B Monthly</text><text class="f" x="235" y="130" text-anchor="middle" style="font-size:10px">96% Accuracy</text><text class="f" x="200" y="180" text-anchor="middle">Real-time Financial Protection</text></svg>`; return c; },
            'revenue_transaction_monitoring': (c) => { const co={type:'doughnut',data:{labels:['Legitimate (94.2%)','Suspicious (4.3%)','Fraudulent (1.5%)'],datasets:[{data:[94.2,4.3,1.5],backgroundColor:['#4bc0c0','#ffce56','#ff6384']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Daily Transaction Analysis'}}}};return createChart(c,co)},
            'revenue_fraud_detection': (c) => { const co={type:'radar',data:{labels:['SIM Box Fraud','Subscription Fraud','Premium Rate Abuse','Identity Theft','Payment Fraud','Roaming Fraud'],datasets:[{label:'Detection Rate (%)',data:[98,95,92,89,96,94],backgroundColor:'rgba(255,99,132,0.2)',borderColor:'rgba(255,99,132,1)',borderWidth:2}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Fraud Detection Capabilities'}},scales:{r:{beginAtZero:true,max:100}}}};return createChart(c,co)},
            'revenue_assurance': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.audit{animation:audit 3s linear infinite;}.check{fill:limegreen;stroke:white;stroke-width:2;}@keyframes audit{from{stroke-dashoffset:300;}to{stroke-dashoffset:0;}}</style><text class="f" x="200" y="25" text-anchor="middle">Revenue Assurance Process</text><g><rect x="30" y="70" width="70" height="30" fill="#36a2eb" rx="5"/><text class="f" x="65" y="90" text-anchor="middle" fill="white">Billing System</text></g><g class="audit"><path d="M110 85 L 160 85" stroke="var(--accent-color)" stroke-width="4" stroke-dasharray="300"/></g><g><rect x="170" y="70" width="70" height="30" fill="var(--accent-color)" rx="5"/><text class="f" x="205" y="90" text-anchor="middle" fill="white">AI Auditor</text></g><g class="audit" style="animation-delay:1s"><path d="M250 85 L 300 65" stroke="limegreen" stroke-width="3" stroke-dasharray="300"/><path d="M250 85 L 300 105" stroke="#ff6384" stroke-width="3" stroke-dasharray="300"/></g><g><circle class="check" cx="320" cy="65" r="15"/><text class="f" x="320" y="70" text-anchor="middle" fill="white">✓</text><text class="f" x="320" y="45" text-anchor="middle" style="font-size:10px">Accurate</text></g><g><circle cx="320" cy="105" r="15" fill="#ff6384"/><text class="f" x="320" y="110" text-anchor="middle" fill="white">✗</text><text class="f" x="320" y="125" text-anchor="middle" style="font-size:10px">Error Found</text></g><text class="f" x="65" y="120" text-anchor="middle" style="font-size:10px">$2.3B/Month</text><text class="f" x="205" y="120" text-anchor="middle" style="font-size:10px">99.7% Accuracy</text><text class="f" x="200" y="180" text-anchor="middle">Continuous Revenue Validation</text></svg>`; return c; },
            'revenue_risk_scoring': (c) => { const co={type:'scatter',data:{datasets:[{label:'High Risk',data:[{x:85,y:90},{x:78,y:88},{x:92,y:85}],backgroundColor:'#ff6384',borderColor:'#ff6384'},{label:'Medium Risk',data:[{x:65,y:45},{x:58,y:52},{x:72,y:38}],backgroundColor:'#ffce56',borderColor:'#ffce56'},{label:'Low Risk',data:[{x:25,y:15},{x:18,y:22},{x:32,y:8}],backgroundColor:'#4bc0c0',borderColor:'#4bc0c0'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Customer Risk Score Matrix'}},scales:{x:{title:{display:true,text:'Behavioral Anomaly Score'}},y:{title:{display:true,text:'Transaction Risk Score'}}}}};return createChart(c,co)},
            'revenue_automatic_actions': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.action{animation:action 2s ease-in-out infinite alternate;}.block{fill:#ff6384;}.alert{fill:#ffce56;}.investigate{fill:#36a2eb;}@keyframes action{from{opacity:0.7;}to{opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">Automated Response Actions</text><g><circle cx="80" cy="100" r="25" fill="#ff6384"/><text class="f" x="80" y="95" text-anchor="middle" fill="white">Fraud</text><text class="f" x="80" y="108" text-anchor="middle" fill="white">Detected</text></g><g class="action"><rect class="block" x="150" y="50" width="80" height="25" rx="5"/><text class="f" x="190" y="67" text-anchor="middle" fill="white">Block Account</text><path d="M110 85 L 145 62" stroke="#ff6384" stroke-width="3"/></g><g class="action" style="animation-delay:0.3s"><rect class="alert" x="150" y="85" width="80" height="25" rx="5"/><text class="f" x="190" y="102" text-anchor="middle" fill="white">Alert Security</text><path d="M110 100 L 145 97" stroke="#ffce56" stroke-width="3"/></g><g class="action" style="animation-delay:0.6s"><rect class="investigate" x="150" y="120" width="80" height="25" rx="5"/><text class="f" x="190" y="137" text-anchor="middle" fill="white">Start Investigation</text><path d="M110 115 L 145 132" stroke="#36a2eb" stroke-width="3"/></g><g><rect x="280" y="85" width="80" height="30" fill="limegreen" rx="5"/><text class="f" x="320" y="95" text-anchor="middle" fill="white">Revenue</text><text class="f" x="320" y="108" text-anchor="middle" fill="white">Protected</text><path d="M240 100 L 275 100" stroke="limegreen" stroke-width="4"/></g><text class="f" x="200" y="180" text-anchor="middle">Millisecond Response Time</text></svg>`; return c; },
            'revenue_recovery_tracking': (c) => { const co={type:'line',data:{labels:['Jan','Feb','Mar','Apr','May','Jun'],datasets:[{label:'Fraud Cases Resolved',data:[45,52,67,73,81,89],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true},{label:'Revenue Recovered ($K)',data:[1200,1400,1650,1850,2100,2380],borderColor:'#36a2eb',backgroundColor:'rgba(54,162,235,0.2)',fill:true,yAxisID:'y1'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Fraud Recovery Performance'}},scales:{y:{beginAtZero:true},y1:{type:'linear',display:true,position:'right',beginAtZero:true}}}};return createChart(c,co)},
            'revenue_fraud_prevention': (c) => { const co={type:'bar',data:{labels:['Q1','Q2','Q3','Q4'],datasets:[{label:'Fraud Prevented ($M)',data:[2.8,3.1,3.2,3.2],backgroundColor:'limegreen'},{label:'Detection Accuracy (%)',data:[94,95,96,96],backgroundColor:'#36a2eb',yAxisID:'y1'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Fraud Prevention Performance ($12.3M Total)'}},scales:{y:{beginAtZero:true},y1:{type:'linear',display:true,position:'right',min:90,max:100}}}};return createChart(c,co)},
            'revenue_recovery': (c) => { const co={type:'doughnut',data:{labels:['Revenue Recovered','Billing Accuracy Improvement','Remaining Leakage'],datasets:[{data:[3.8,2.1,0.3],backgroundColor:['limegreen','#36a2eb','#ffce56']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Revenue Recovery Impact ($3.8M)'}}}};return createChart(c,co)},
            'revenue_investigation_time': (c) => { const co={type:'bar',data:{labels:['Before AI','After AI'],datasets:[{label:'Investigation Time (hours)',data:[32,7],backgroundColor:['#ff6384','#4bc0c0']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Fraud Investigation Time Reduction (-78%)'}}}};return createChart(c,co)},
            // Dynamic Pricing & Promotion Optimization System Generators
            'pricing_overview': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.market{animation:market 3s ease-in-out infinite alternate;}.optimize{animation:optimize 2s ease-in-out infinite;}.profit{fill:limegreen;}@keyframes market{from{opacity:0.7;}to{opacity:1;}}@keyframes optimize{from{transform:scale(1);}to{transform:scale(1.1);}}</style><text class="f" x="200" y="25" text-anchor="middle">Dynamic Pricing & Promotion Optimization</text><g class="market"><rect x="30" y="70" width="70" height="40" fill="#36a2eb" rx="5"/><text class="f" x="65" y="85" text-anchor="middle" fill="white">Market</text><text class="f" x="65" y="98" text-anchor="middle" fill="white">Intelligence</text></g><g class="market" style="animation-delay:0.5s"><rect x="30" y="120" width="70" height="40" fill="#4bc0c0" rx="5"/><text class="f" x="65" y="135" text-anchor="middle" fill="white">Demand</text><text class="f" x="65" y="148" text-anchor="middle" fill="white">Forecast</text></g><circle class="optimize" cx="200" cy="120" r="35" fill="var(--accent-color)"/><text class="f" x="200" y="115" text-anchor="middle" fill="white">Price</text><text class="f" x="200" y="128" text-anchor="middle" fill="white">Optimizer</text><g><rect x="290" y="80" width="80" height="25" fill="limegreen" rx="5"/><text class="f" x="330" y="97" text-anchor="middle" fill="white">+18% Revenue</text><path d="M240 110 L 285 92" stroke="limegreen" stroke-width="3"/></g><g><rect x="290" y="120" width="80" height="25" fill="#ffce56" rx="5"/><text class="f" x="330" y="137" text-anchor="middle" fill="white">+12% Market Share</text><path d="M240 130 L 285 132" stroke="#ffce56" stroke-width="3"/></g><text class="f" x="65" y="185" text-anchor="middle" style="font-size:10px">Real-time Analysis</text><text class="f" x="200" y="180" text-anchor="middle">Maximize Profitability</text></svg>`; return c; },
            'pricing_market_analysis': (c) => { const co={type:'line',data:{labels:['Jazz','Zong','Ufone','SCO'],datasets:[{label:'Voice Plans (PKR)',data:[450,420,480,460],borderColor:'#36a2eb',backgroundColor:'rgba(54,162,235,0.2)',fill:true},{label:'Data Plans (PKR)',data:[890,850,920,880],borderColor:'#4bc0c0',backgroundColor:'rgba(75,192,192,0.2)',fill:true},{label:'T-Nor Optimal',data:[465,875,0,0],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Competitive Pricing Analysis'}}}};return createChart(c,co)},
            'pricing_demand_forecasting': (c) => { const co={type:'line',data:{labels:['Current Price','5% Increase','10% Increase','15% Increase','20% Increase'],datasets:[{label:'Demand Forecast (Subscribers)',data:[100000,92000,85000,76000,65000],borderColor:'#ff6384',backgroundColor:'rgba(255,99,132,0.2)',fill:true},{label:'Revenue Projection (PKR M)',data:[45,47.5,48.7,47.8,44.2],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true,yAxisID:'y1'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Price Elasticity & Revenue Optimization'}},scales:{y:{beginAtZero:true},y1:{type:'linear',display:true,position:'right',beginAtZero:true}}}};return createChart(c,co)},
            'pricing_optimization': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.calc{animation:calc 2s ease-in-out infinite alternate;}.factor{fill:#e0e0e0;stroke:#333;stroke-width:1;}@keyframes calc{from{opacity:0.7;}to{opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">Price Optimization Algorithm</text><g class="calc"><rect class="factor" x="50" y="60" width="80" height="25" rx="5"/><text class="f" x="90" y="77" text-anchor="middle">Cost Base</text></g><g class="calc" style="animation-delay:0.2s"><rect class="factor" x="50" y="90" width="80" height="25" rx="5"/><text class="f" x="90" y="107" text-anchor="middle">Competition</text></g><g class="calc" style="animation-delay:0.4s"><rect class="factor" x="50" y="120" width="80" height="25" rx="5"/><text class="f" x="90" y="137" text-anchor="middle">Demand</text></g><g class="calc" style="animation-delay:0.6s"><rect class="factor" x="50" y="150" width="80" height="25" rx="5"/><text class="f" x="90" y="167" text-anchor="middle">Elasticity</text></g><circle cx="200" cy="120" r="30" fill="var(--accent-color)"/><text class="f" x="200" y="115" text-anchor="middle" fill="white">Algorithm</text><text class="f" x="200" y="128" text-anchor="middle" fill="white">Engine</text><g><path d="M145 75 L 170 110" stroke="#333" stroke-width="2"/><path d="M145 105 L 170 115" stroke="#333" stroke-width="2"/><path d="M145 135 L 170 125" stroke="#333" stroke-width="2"/><path d="M145 165 L 170 140" stroke="#333" stroke-width="2"/></g><g><rect x="270" y="105" width="100" height="30" fill="limegreen" rx="5"/><text class="f" x="320" y="115" text-anchor="middle" fill="white">Optimal Price</text><text class="f" x="320" y="128" text-anchor="middle" fill="white">PKR 465</text><path d="M235 120 L 265 120" stroke="limegreen" stroke-width="4"/></g></svg>`; return c; },
            'pricing_promotion_engine': (c) => { const co={type:'doughnut',data:{labels:['Data Bonus (28%)','Discount Plans (35%)','Free Minutes (18%)','Bundle Offers (12%)','Cashback (7%)'],datasets:[{data:[28,35,18,12,7],backgroundColor:['#36a2eb','#4bc0c0','#ffce56','#ff9f40','#9966ff']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Promotion Type Distribution'}}}};return createChart(c,co)},
            'pricing_ab_testing': (c) => { const co={type:'bar',data:{labels:['Variant A','Variant B','Variant C','Control'],datasets:[{label:'Conversion Rate (%)',data:[18.5,22.3,19.8,15.2],backgroundColor:['#36a2eb','limegreen','#ffce56','#ff6384']},{label:'Revenue Impact (%)',data:[12,18,14,0],backgroundColor:['#4bc0c0','#ff9f40','#9966ff','#e0e0e0']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'A/B Testing Results for Pricing Strategies'}}}};return createChart(c,co)},
            'pricing_elasticity_analysis': (c) => { const co={type:'scatter',data:{datasets:[{label:'High Elasticity',data:[{x:-15,y:-25},{x:-10,y:-18},{x:-20,y:-32}],backgroundColor:'#ff6384',borderColor:'#ff6384'},{label:'Medium Elasticity',data:[{x:-15,y:-12},{x:-10,y:-8},{x:-20,y:-16}],backgroundColor:'#ffce56',borderColor:'#ffce56'},{label:'Low Elasticity',data:[{x:-15,y:-3},{x:-10,y:-2},{x:-20,y:-4}],backgroundColor:'#4bc0c0',borderColor:'#4bc0c0'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Price Elasticity by Customer Segment'}},scales:{x:{title:{display:true,text:'Price Change (%)'}},y:{title:{display:true,text:'Demand Change (%)'}}}}};return createChart(c,co)},
            'pricing_revenue_growth': (c) => { const co={type:'bar',data:{labels:['Q1','Q2','Q3','Q4'],datasets:[{label:'Revenue Growth (%)',data:[12,15,18,18],backgroundColor:['#36a2eb','#4bc0c0','#ffce56','limegreen']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Quarterly Revenue Growth (+18% Total)'}}}};return createChart(c,co)},
            'pricing_promotion_effectiveness': (c) => { const co={type:'bar',data:{labels:['Traditional','AI-Driven'],datasets:[{label:'Effectiveness (%)',data:[100,145],backgroundColor:['#ff6384','limegreen']},{label:'Conversion Rate (%)',data:[12.5,21.6],backgroundColor:['#ffce56','#36a2eb']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Promotion Performance Comparison'}}}};return createChart(c,co)},
            'pricing_competitive_position': (c) => { const co={type:'radar',data:{labels:['Market Share','Profit Margin','Customer Satisfaction','Price Competitiveness','Brand Value','Growth Rate'],datasets:[{label:'Before AI',data:[20,15,7.2,6.8,6.5,8],backgroundColor:'rgba(255,99,132,0.2)',borderColor:'rgba(255,99,132,1)',borderWidth:2},{label:'After AI',data:[32,18,8.9,8.2,7.8,12],backgroundColor:'rgba(75,192,192,0.2)',borderColor:'rgba(75,192,192,1)',borderWidth:2}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Competitive Position Improvement'}}}};return createChart(c,co)},
            // Voice of Customer (VoC) Intelligence System Generators
            'voc_overview': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 12px var(--font-family);}.voice{animation:voice 3s ease-in-out infinite alternate;}.insight{animation:insight 2s ease-in-out infinite;}@keyframes voice{from{opacity:0.6;}to{opacity:1;}}@keyframes insight{from{transform:scale(1);}to{transform:scale(1.1);}}</style><text class="f" x="200" y="25" text-anchor="middle">Voice of Customer Intelligence System</text><g class="voice"><rect x="20" y="60" width="60" height="30" fill="#36a2eb" rx="5"/><text class="f" x="50" y="80" text-anchor="middle" fill="white">Surveys</text></g><g class="voice" style="animation-delay:0.3s"><rect x="20" y="100" width="60" height="30" fill="#4bc0c0" rx="5"/><text class="f" x="50" y="120" text-anchor="middle" fill="white">Reviews</text></g><g class="voice" style="animation-delay:0.6s"><rect x="20" y="140" width="60" height="30" fill="#ffce56" rx="5"/><text class="f" x="50" y="160" text-anchor="middle" fill="white">Support</text></g><circle class="insight" cx="150" cy="120" r="35" fill="var(--accent-color)"/><text class="f" x="150" y="115" text-anchor="middle" fill="white">AI</text><text class="f" x="150" y="128" text-anchor="middle" fill="white">Analysis</text><g><path d="M90 75 L 115 110" stroke="#36a2eb" stroke-width="3"/><path d="M90 115 L 115 120" stroke="#4bc0c0" stroke-width="3"/><path d="M90 155 L 115 130" stroke="#ffce56" stroke-width="3"/></g><g><rect x="220" y="70" width="80" height="25" fill="limegreen" rx="5"/><text class="f" x="260" y="87" text-anchor="middle" fill="white">Insights</text><path d="M190 110 L 215 82" stroke="limegreen" stroke-width="3"/></g><g><rect x="220" y="110" width="80" height="25" fill="#ff9f40" rx="5"/><text class="f" x="260" y="127" text-anchor="middle" fill="white">Actions</text><path d="M190 120 L 215 122" stroke="#ff9f40" stroke-width="3"/></g><g><rect x="220" y="150" width="80" height="25" fill="#9966ff" rx="5"/><text class="f" x="260" y="167" text-anchor="middle" fill="white">Impact</text><path d="M190 130 L 215 162" stroke="#9966ff" stroke-width="3"/></g><text class="f" x="350" y="120" text-anchor="middle">+28%</text><text class="f" x="350" y="135" text-anchor="middle">Satisfaction</text></svg>`; return c; },
            'voc_feedback_aggregation': (c) => { const co={type:'radar',data:{labels:['Call Center','App Reviews','Social Media','Surveys','Support Tickets','Live Chat'],datasets:[{label:'Feedback Volume/Day',data:[1200,450,680,320,890,540],backgroundColor:'rgba(54,162,235,0.2)',borderColor:'rgba(54,162,235,1)',borderWidth:2}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Customer Feedback Sources'}},scales:{r:{beginAtZero:true}}}};return createChart(c,co)},
            'voc_sentiment_mining': (c) => { const co={type:'line',data:{labels:['Jan','Feb','Mar','Apr','May','Jun'],datasets:[{label:'Positive Sentiment (%)',data:[42,48,55,62,68,72],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true},{label:'Negative Sentiment (%)',data:[35,32,28,23,18,15],borderColor:'#ff6384',backgroundColor:'rgba(255,99,132,0.2)',fill:true},{label:'Neutral Sentiment (%)',data:[23,20,17,15,14,13],borderColor:'#ffce56',backgroundColor:'rgba(255,206,86,0.2)',fill:true}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Sentiment Trend Analysis'}}}};return createChart(c,co)},
            'voc_theme_extraction': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.theme{animation:theme 2s ease-in-out infinite alternate;}.bubble{fill:#e0e0e0;stroke:#333;stroke-width:1;}@keyframes theme{from{opacity:0.7;}to{opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">Theme Extraction from Customer Feedback</text><g class="theme"><ellipse class="bubble" cx="80" cy="70" rx="40" ry="20"/><text class="f" x="80" y="67" text-anchor="middle">Network</text><text class="f" x="80" y="78" text-anchor="middle">Quality</text></g><g class="theme" style="animation-delay:0.3s"><ellipse class="bubble" cx="200" cy="60" rx="35" ry="18"/><text class="f" x="200" y="57" text-anchor="middle">Billing</text><text class="f" x="200" y="68" text-anchor="middle">Issues</text></g><g class="theme" style="animation-delay:0.6s"><ellipse class="bubble" cx="320" cy="70" rx="45" ry="22"/><text class="f" x="320" y="67" text-anchor="middle">Customer</text><text class="f" x="320" y="78" text-anchor="middle">Service</text></g><g class="theme" style="animation-delay:0.9s"><ellipse class="bubble" cx="120" cy="130" rx="38" ry="20"/><text class="f" x="120" y="127" text-anchor="middle">App</text><text class="f" x="120" y="138" text-anchor="middle">Features</text></g><g class="theme" style="animation-delay:1.2s"><ellipse class="bubble" cx="280" cy="130" rx="42" ry="21"/><text class="f" x="280" y="127" text-anchor="middle">Pricing</text><text class="f" x="280" y="138" text-anchor="middle">Concerns</text></g><g><rect x="170" y="100" width="60" height="25" fill="var(--accent-color)" rx="5"/><text class="f" x="200" y="117" text-anchor="middle" fill="white">AI Engine</text></g><path d="M170 110 L 125 85" stroke="var(--accent-color)" stroke-width="2"/><path d="M170 110 L 165 78" stroke="var(--accent-color)" stroke-width="2"/><path d="M230 110 L 275 85" stroke="var(--accent-color)" stroke-width="2"/><path d="M200 130 L 155 135" stroke="var(--accent-color)" stroke-width="2"/><path d="M200 130 L 245 135" stroke="var(--accent-color)" stroke-width="2"/><text class="f" x="200" y="180" text-anchor="middle">Automated Topic Discovery</text></svg>`; return c; },
            'voc_impact_analysis': (c) => { const co={type:'scatter',data:{datasets:[{label:'High Impact',data:[{x:85,y:90},{x:78,y:88},{x:92,y:85}],backgroundColor:'#ff6384',borderColor:'#ff6384'},{label:'Medium Impact',data:[{x:65,y:45},{x:58,y:52},{x:72,y:38}],backgroundColor:'#ffce56',borderColor:'#ffce56'},{label:'Low Impact',data:[{x:25,y:15},{x:18,y:22},{x:32,y:8}],backgroundColor:'#4bc0c0',borderColor:'#4bc0c0'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Feedback Theme vs Business Impact'}},scales:{x:{title:{display:true,text:'Frequency of Mentions'}},y:{title:{display:true,text:'Business Impact Score'}}}}};return createChart(c,co)},
            'voc_action_recommendation': (c) => { c.innerHTML = `<svg viewBox="0 0 400 200"><style>.f{font:bold 11px var(--font-family);}.recommend{animation:recommend 3s ease-in-out infinite alternate;}.priority{fill:#ff6384;}.medium{fill:#ffce56;}.low{fill:#4bc0c0;}@keyframes recommend{from{opacity:0.7;}to{opacity:1;}}</style><text class="f" x="200" y="25" text-anchor="middle">AI-Generated Action Recommendations</text><g class="recommend"><rect class="priority" x="30" y="60" width="120" height="25" rx="5"/><text class="f" x="90" y="77" text-anchor="middle" fill="white">Improve Network Coverage</text></g><g class="recommend" style="animation-delay:0.3s"><rect class="medium" x="30" y="95" width="120" height="25" rx="5"/><text class="f" x="90" y="112" text-anchor="middle" fill="white">Simplify Billing Process</text></g><g class="recommend" style="animation-delay:0.6s"><rect class="low" x="30" y="130" width="120" height="25" rx="5"/><text class="f" x="90" y="147" text-anchor="middle" fill="white">Add App Features</text></g><g><rect x="200" y="80" width="80" height="40" fill="var(--accent-color)" rx="5"/><text class="f" x="240" y="95" text-anchor="middle" fill="white">Priority</text><text class="f" x="240" y="108" text-anchor="middle" fill="white">Engine</text></g><g><rect x="320" y="60" width="60" height="20" fill="#ff6384" rx="5"/><text class="f" x="350" y="75" text-anchor="middle" fill="white">P1</text><path d="M285 95 L 315 70" stroke="#ff6384" stroke-width="3"/></g><g><rect x="320" y="90" width="60" height="20" fill="#ffce56" rx="5"/><text class="f" x="350" y="105" text-anchor="middle" fill="white">P2</text><path d="M285 100 L 315 100" stroke="#ffce56" stroke-width="3"/></g><g><rect x="320" y="120" width="60" height="20" fill="#4bc0c0" rx="5"/><text class="f" x="350" y="135" text-anchor="middle" fill="white">P3</text><path d="M285 105 L 315 130" stroke="#4bc0c0" stroke-width="3"/></g><text class="f" x="90" y="175" text-anchor="middle" style="font-size:10px">Data-Driven Actions</text><text class="f" x="240" y="145" text-anchor="middle" style="font-size:10px">Impact Assessment</text><text class="f" x="350" y="155" text-anchor="middle" style="font-size:10px">Implementation</text></svg>`; return c; },
            'voc_closed_loop_feedback': (c) => { const co={type:'line',data:{labels:['Week 1','Week 2','Week 3','Week 4','Week 5','Week 6','Week 7','Week 8'],datasets:[{label:'Actions Implemented',data:[3,5,8,12,15,18,22,25],borderColor:'#36a2eb',backgroundColor:'rgba(54,162,235,0.2)',fill:true},{label:'Customer Satisfaction',data:[7.2,7.4,7.8,8.1,8.4,8.7,8.9,9.1],borderColor:'limegreen',backgroundColor:'rgba(50,205,50,0.2)',fill:true,yAxisID:'y1'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Closed-Loop Feedback: Actions vs Satisfaction'}},scales:{y:{beginAtZero:true},y1:{type:'linear',display:true,position:'right',min:0,max:10}}}};return createChart(c,co)},
            'voc_satisfaction_improvement': (c) => { const co={type:'bar',data:{labels:['Network','Billing','Support','App','Pricing'],datasets:[{label:'Before VoC',data:[6.8,6.2,7.1,6.9,6.5],backgroundColor:'rgba(255,99,132,0.8)'},{label:'After VoC',data:[8.7,8.9,9.2,8.8,8.4],backgroundColor:'rgba(75,192,192,0.8)'}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Customer Satisfaction by Category (+28% Average)'}},scales:{y:{beginAtZero:true,max:10}}}};return createChart(c,co)},
            'voc_issue_resolution': (c) => { const co={type:'bar',data:{labels:['Before VoC','After VoC'],datasets:[{label:'Issue Resolution Time (hours)',data:[48,17],backgroundColor:['#ff6384','limegreen']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Proactive Issue Resolution (-65%)'}}}};return createChart(c,co)},
            'voc_product_innovation': (c) => { const co={type:'doughnut',data:{labels:['Implemented (89%)','In Development (8%)','Declined (3%)'],datasets:[{data:[89,8,3],backgroundColor:['limegreen','#ffce56','#ff6384']}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:true,text:'Customer-Requested Features Implementation'}}}};return createChart(c,co)}
        };

        // --- Added: New p5.js background art from NodeBg.html ---
        const p5_sketch = (p) => {
            let nodes = [];
            const numNodes = 300;
            const cursorRadius = 300;
            const neighborRadius = 120;
            const collisionDistance = 10;
            const attractionStrength = 1.0 / 3.0; 
            const wanderStrength = 0.05;

            let blackColor, saturatedBlueColor, greenColor;

            class Node {
                constructor(x, y) {
                    this.position = p.createVector(x, y);
                    this.velocity = p.createVector(0, 0);
                    this.acceleration = p.createVector(0, 0);
                    this.damping = 0.96;
                    this.age = 0;
                    this.maxAge = p.random(500, 900);
                    this.color = p.color(255); 
                }
                applyForce(force) { this.acceleration.add(force); }
                update() {
                    this.velocity.add(this.acceleration);
                    this.position.add(this.velocity);
                    this.acceleration.mult(0);
                    this.velocity.mult(this.damping);
                    this.age++;
                }
                isOld() { return this.age > this.maxAge; }
            }

            p.setup = () => {
                p.createCanvas(p.windowWidth, p.windowHeight);
                blackColor = p.color(100, 100, 100);
                saturatedBlueColor = p.color(0, 170, 255);
                greenColor = p.color(100, 255, 100);

                for (let i = 0; i < numNodes; i++) {
                    nodes.push(new Node(p.random(p.width), p.random(p.height)));
                }
            };

            p.draw = () => {
                p.background(228); 
                let mouseSpeed = p.dist(p.mouseX, p.mouseY, p.pmouseX, p.pmouseY);

                for (let i = 0; i < nodes.length; i++) {
                    let node = nodes[i];
                    node.update();
                    
                    let died = false;
                    if (node.isOld()) {
                        died = true;
                    } else {
                        for (let j = i + 1; j < nodes.length; j++) {
                            if (p.dist(node.position.x, node.position.y, nodes[j].position.x, nodes[j].position.y) < collisionDistance) {
                                died = true;
                                break;
                            }
                        }
                    }
                    
                    if (died) {
                        nodes[i] = new Node(p.random(p.width), p.random(p.height));
                        continue;
                    }
                    
                    let wanderForce = p.constructor.Vector.random2D();
                    wanderForce.setMag(wanderStrength);
                    node.applyForce(wanderForce);

                    let cursorDist = p.dist(p.mouseX, p.mouseY, node.position.x, node.position.y);
                    if (cursorDist < cursorRadius && mouseSpeed > 0.5) {
                        let force = p.constructor.Vector.sub(p.createVector(p.mouseX, p.mouseY), node.position);
                        let magnitude = p.map(mouseSpeed, 1, 60, 0, attractionStrength); 
                        force.setMag(magnitude);
                        node.applyForce(force);
                    }
                    
                    let ageRatio = node.age / node.maxAge;
                    if (ageRatio < 0.5) {
                        let amount = p.map(ageRatio, 0, 0.5, 0, 1);
                        node.color = p.lerpColor(blackColor, saturatedBlueColor, amount);
                    } else {
                        let amount = p.map(ageRatio, 0.5, 1, 0, 1);
                        node.color = p.lerpColor(saturatedBlueColor, greenColor, amount);
                    }
                }

                for (let i = 0; i < nodes.length; i++) {
                    let nodeA = nodes[i];
                    let cursorDist = p.dist(p.mouseX, p.mouseY, nodeA.position.x, nodeA.position.y);

                    if (cursorDist < cursorRadius) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            let nodeB = nodes[j];
                            if (p.dist(nodeA.position.x, nodeA.position.y, nodeB.position.x, nodeB.position.y) < neighborRadius) {
                                let lineColor = p.lerpColor(nodeA.color, nodeB.color, 0.5);
                                let alpha = p.map(cursorDist, 0, cursorRadius, 255, 50);
                                lineColor.setAlpha(alpha);
                                let weight = p.map(p.dist(nodeA.position.x, nodeA.position.y, nodeB.position.x, nodeB.position.y), 0, neighborRadius, 1.5, 0.2);
                                p.stroke(lineColor);
                                p.strokeWeight(weight);
                                p.line(nodeA.position.x, nodeA.position.y, nodeB.position.x, nodeB.position.y);
                            }
                        }
                    }
                }
            };
            
            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                nodes = [];
                 for (let i = 0; i < numNodes; i++) {
                    nodes.push(new Node(p.random(p.width), p.random(p.height)));
                }
            };
        };

        function WaveArt(container) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            container.appendChild(canvas);

            let width, height, mouseX, mouseY, animationId, time = 0;
            const resizeCanvas = () => { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; };
            resizeCanvas();
            mouseX = width / 2; mouseY = height / 2;

            const createGradient = (colors, vertical = false) => {
                let gradient = vertical ? ctx.createLinearGradient(0, 0, 0, height) : ctx.createLinearGradient(0, 0, width, 0);
                colors.forEach((color, i) => gradient.addColorStop(i / (colors.length - 1), color));
                return gradient;
            };

            const drawWave = (offsetX, offsetY, phase, colors, amplitude, frequency, opacity, inverted = false) => {
                ctx.save(); ctx.globalAlpha = opacity;
                ctx.beginPath();
                const wavePoints = []; const resolution = 4;
                for (let x = -200; x <= width + 200; x += resolution) {
                    const mouseInfluence = Math.exp(-Math.pow(x - mouseX, 2) / 20000) * (inverted ? (height / 2 - mouseY) : (mouseY - height / 2)) * 0.3;
                    const sign = inverted ? -1 : 1;
                    const baseWave = sign * Math.sin((x + offsetX) * frequency + time * 0.01 + phase) * amplitude;
                    const secondaryWave = sign * Math.sin((x + offsetX) * frequency * 1.5 + time * 0.015 + phase) * amplitude * 0.3;
                    const y = height / 2 + baseWave + secondaryWave + offsetY + mouseInfluence;
                    wavePoints.push({x, y});
                }
                ctx.moveTo(wavePoints[0].x, wavePoints[0].y);
                for (let i = 1; i < wavePoints.length; i++) {
                    const cpx = (wavePoints[i-1].x + wavePoints[i].x) / 2;
                    const cpy = (wavePoints[i-1].y + wavePoints[i].y) / 2;
                    ctx.quadraticCurveTo(wavePoints[i-1].x, wavePoints[i-1].y, cpx, cpy);
                }
                ctx.lineTo(width + 200, inverted ? -200 : height + 200);
                ctx.lineTo(-200, inverted ? -200 : height + 200);
                ctx.closePath();
                ctx.fillStyle = createGradient(colors, inverted);
                ctx.fill(); ctx.restore();
            };

            const animate = () => {
                ctx.fillStyle = 'rgb(220, 220, 220)'; ctx.fillRect(0, 0, width, height);
                time += 1;
                drawWave(time * 0.5, 0, 0, ['rgba(255, 182, 193, 0.8)', 'rgba(255, 105, 180, 0.6)', 'rgba(144, 238, 144, 0.6)', 'rgba(60, 179, 113, 0.4)'], 80, 0.008, 0.7);
                drawWave(time * 0.3, 20, Math.PI, ['rgba(173, 216, 230, 0.8)', 'rgba(150, 209, 255, 0.7)', 'rgba(197, 162, 249, 0.6)', 'rgba(198, 83, 255, 0.4)'], 100, 0.006, 0.6, true);
                drawWave(time * 0.7, -30, Math.PI * 0.5, ['rgba(255, 228, 225, 0.3)', 'rgba(152, 251, 152, 0.3)', 'rgba(230, 230, 250, 0.2)', 'rgba(255, 182, 193, 0.1)'], 60, 0.01, 0.4);
                animationId = requestAnimationFrame(animate);
            };

            const mouseMoveHandler = (e) => { mouseX = e.clientX; mouseY = e.clientY; };
            const touchMoveHandler = (e) => { e.preventDefault(); mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY; };

            this.start = () => {
                window.addEventListener('resize', resizeCanvas);
                document.body.addEventListener('mousemove', mouseMoveHandler);
                document.body.addEventListener('touchmove', touchMoveHandler);
                animate();
            };

            this.stop = () => {
                if (animationId) cancelAnimationFrame(animationId);
                window.removeEventListener('resize', resizeCanvas);
                document.body.removeEventListener('mousemove', mouseMoveHandler);
                document.body.removeEventListener('touchmove', touchMoveHandler);
            };
        }
        
        // --- Modified function to handle all three background types ---
        function renderPage(index) {
    if (index < 0 || index >= presentationData.length) return;
    currentPageIndex = index;

    // 1. Update Titles and Backgrounds
    mainTitle.innerHTML = presentationData[index].title;
    
    // Background Logic (Preserving your template's style)
    if (bgContainer) { // Ensure container exists
         // [Insert your existing background switching logic here if customized]
    }

    // 2. Build the Left Sidebar List
    subheadingList.innerHTML = '';
    const subheadings = presentationData[index].subheadings;
    const subheadingKeys = Object.keys(subheadings);
    let firstValidKey = null;

    subheadingKeys.forEach((key, idx) => {
        const item = subheadings[key];
        const li = document.createElement('li');
        li.innerHTML = item.text;
        li.dataset.subheadingId = key;
        li.dataset.tooltip = item.tooltip || "";

        if (item.isCategory) {
            li.className = 'subheading-category';
        } else {
            if (item.isIndented) li.classList.add('indented-subheading');
            // Capture the first clickable item to auto-load it later
            if (!firstValidKey) firstValidKey = key;
        }
        subheadingList.appendChild(li);
    });

    // 3. Auto-Load the First Slide Content
    if (firstValidKey) {
        // Highlight the list item
        const activeLi = subheadingList.querySelector(`li[data-subheading-id="${firstValidKey}"]`);
        if (activeLi) activeLi.classList.add('active');
        
        // --- TRIGGER THE MEDIA ---
        renderMedia(firstValidKey, 0);
    } else {
        mediaContainer.innerHTML = ''; // Clear if page has no content
    }

    renderPageSwitcher();


            // Activate the correct background for the new page
            if (currentPageIndex === 3 || currentPageIndex === 4|| currentPageIndex === 6|| currentPageIndex === 7) { // Pages 4 and 5 get Node Art
    p5Sketch = new p5(p5_sketch, bgContainer);
} else if (currentPageIndex === 5 || (currentPageIndex >= 9 && currentPageIndex <= 17) || currentPageIndex === 22) { // Pages 6 and 7 get Wave Art
    vanillaWaveArt = new WaveArt(bgContainer);
    vanillaWaveArt.start();
            } else { // All other pages
                const bgCanvas = document.createElement('canvas');
                const bgCtx = bgCanvas.getContext('2d');
                bgContainer.appendChild(bgCanvas);
                bgCanvas.width = window.innerWidth;
                bgCanvas.height = window.innerHeight;
                window.addEventListener('resize', () => {
                    if (!vanillaWaveArt && !p5Sketch) { // Only resize if it's the original canvas
                        bgCanvas.width = window.innerWidth;
                        bgCanvas.height = window.innerHeight;
                    }
                });
                animateBg(bgCtx, bgCanvas);
            }
        }

        function renderPageSwitcher() {
    pageSwitcher.innerHTML = '';
    presentationData.forEach((page, index) => {
        const dot = document.createElement('div');
        dot.className = 'dot page-dot';
        dot.dataset.pageIndex = index;

        if (index === currentPageIndex) {
            dot.classList.add('active');
        } else if (page.dotColor) {
            // This is the new part: apply the custom color if the dot is not active
            dot.style.backgroundColor = page.dotColor;
        }

        pageSwitcher.appendChild(dot);
    });
}
        
    function renderMedia(subheadingId, contentIndex = 0) {
    // 1. Cleanup: Destroy existing charts and P5 instances
    currentCharts.forEach(c => c.destroy());
    currentCharts = [];
    
    if (contentP5) {
        contentP5.remove(); 
        contentP5 = null;
    }

    mediaContainer.innerHTML = ''; // Clear container
    mediaContainer.style.flexDirection = 'row';

    // 2. Get Data
    const page = presentationData[currentPageIndex];
    const subheading = page.subheadings[subheadingId];
    if (!subheading || !subheading.content) return;

    const selectedContent = subheading.content[contentIndex];

    if (!selectedContent || selectedContent.type === 'empty') {
        return;
    } 

    // --- VIDEO HANDLER (NEW) ---
    else if (selectedContent.type === 'video') {
        const iframe = document.createElement('iframe');
        iframe.style.width = "100%";
        iframe.style.height = "100%"; // Fills the pane
        iframe.style.border = "none";
        iframe.src = selectedContent.url;
        iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
        iframe.allowFullscreen = true;
        mediaContainer.appendChild(iframe);
    }
    // ---------------------------

    else if (selectedContent.type === 'p5') {
        const generator = mediaGenerators[selectedContent.generator];
        if (generator) {
            contentP5 = new p5(generator, 'media-container');
        }
    } 
    else if (selectedContent.type === 'chart') {
        const generator = mediaGenerators[selectedContent.generator];
        if (generator) generator(mediaContainer);
    } 
    else if (['svg', 'multi-chart', 'info-graphic'].includes(selectedContent.type)) {
        const generator = mediaGenerators[selectedContent.generator];
        if (generator) generator(mediaContainer);
    }

    updateMediaSwitcher(subheadingId, contentIndex);
}
        
        function updateMediaSwitcher(subheadingId, activeIndex) {
            mediaSwitcher.innerHTML = '';
            const subheading = presentationData[currentPageIndex].subheadings[subheadingId];
            if (!subheading || !subheading.content || subheading.content[0].type === 'empty' || subheading.content.length <= 1) return;
            subheading.content.forEach((item, index) => { const dot = document.createElement('div'); dot.className = 'dot'; if (index === activeIndex) { dot.classList.add('active'); } dot.dataset.mediaIndex = index; dot.dataset.subheadingId = subheadingId; mediaSwitcher.appendChild(dot); });
        }
        
        subheadingList.addEventListener('click', (e) => { const targetLi = e.target.closest('li'); if (!targetLi || targetLi.classList.contains('subheading-category')) return; document.querySelectorAll('#left-pane li').forEach(li => li.classList.remove('active')); targetLi.classList.add('active'); const subheadingId = targetLi.dataset.subheadingId; renderMedia(subheadingId, 0); });
        pageSwitcher.addEventListener('click', (e) => { const targetDot = e.target.closest('.page-dot'); if (targetDot) { renderPage(parseInt(targetDot.dataset.pageIndex)); } });
        mediaSwitcher.addEventListener('click', (e) => { const targetDot = e.target.closest('.dot'); if (targetDot) { const subheadingId = targetDot.dataset.subheadingId; const mediaIndex = parseInt(targetDot.dataset.mediaIndex); renderMedia(subheadingId, mediaIndex); } });
        subheadingList.addEventListener('mouseover', (e) => { const targetLi = e.target.closest('li'); if(targetLi && !targetLi.classList.contains('subheading-category')) { tooltip.innerHTML = targetLi.getAttribute('data-tooltip'); tooltip.style.display = 'block'; } });
        subheadingList.addEventListener('mousemove', (e) => { const targetLi = e.target.closest('li'); if(targetLi && !targetLi.classList.contains('subheading-category')){ const tooltipHeight = tooltip.offsetHeight; const viewportHeight = window.innerHeight; let topPosition = e.clientY + 15; if (topPosition + tooltipHeight > viewportHeight) { topPosition = e.clientY - tooltipHeight - 15; } tooltip.style.left = `${e.clientX + 15}px`; tooltip.style.top = `${topPosition}px`; } });
        subheadingList.addEventListener('mouseout', (e) => { const targetLi = e.target.closest('li'); if(targetLi){ tooltip.style.display = 'none'; } });
        // --- ADD THIS CODE FOR ARROW KEY NAVIGATION ---
        document.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowRight') {
        const nextPageIndex = (currentPageIndex + 1) % presentationData.length;
        renderPage(nextPageIndex);
         } else if (e.key === 'ArrowLeft') {
        const prevPageIndex = (currentPageIndex - 1 + presentationData.length) % presentationData.length;
        renderPage(prevPageIndex);
         }
});
        // --- Modified function ---
        function init() {
            bgContainer = document.getElementById('background-container'); // Get container
            let _recordedPath = [];
            const recordFn = (e) => _recordedPath.push({x:e.clientX, y:e.clientY});
            window.addEventListener('mousemove', recordFn);
            setInterval(() => processBranchers(), 1000 / 20); 
            setInterval(() => triggerPlayback(_recordedPath), 5000); 
            renderPage(0); // Initial page render
        }
        
        let strokes = []; let branches = []; let brancherPool = [];
        const MARK_LIFETIME = 10000; const BIFURCATION_STEPS = 20;
        function triggerPlayback(path) { if (path.length < 2) { path.length=0; return; } const newStroke = path.map(p => ({ x: p.x, y: p.y, time: Date.now() })); strokes.push(newStroke); path.length = 0; const p1 = newStroke[0]; const p2 = newStroke[1]; let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x); let oppositeAngle = angle + Math.PI; brancherPool.push({ queue: [{ x: p2.x, y: p2.y, angle: oppositeAngle - 0.3, width: 7 * 0.8, step: 0 }, { x: p2.x, y: p2.y, angle: oppositeAngle + 0.3, width: 7 * 0.8, step: 0 }] }); const lastPoint = newStroke[newStroke.length - 1]; const secondLastPoint = newStroke[newStroke.length - 2]; angle = Math.atan2(lastPoint.y - secondLastPoint.y, lastPoint.x - secondLastPoint.x); brancherPool.push({ queue: [{ x: lastPoint.x, y: lastPoint.y, angle: angle - 0.3, width: 7 * 0.8, step: 0 }, { x: lastPoint.x, y: lastPoint.y, angle: angle + 0.3, width: 7 * 0.8, step: 0 }] }); }
        function getDecayColor(creationTime) { const age = Date.now() - creationTime; const life = Math.min(age / MARK_LIFETIME, 1); const startColor = { r: 173, g: 216, b: 230 }; const endColor = { r: 220, g: 205, b: 190 }; const t = life; const r = startColor.r + t * (endColor.r - startColor.r); const g = startColor.g + t * (endColor.g - startColor.g); const b = startColor.b + t * (endColor.b - startColor.b); const alpha = 1 - Math.pow(t, 2); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }
        function processBranchers() { for (let i = brancherPool.length - 1; i >= 0; i--) { const brancher = brancherPool[i]; for (let j = 0; j < 50 && brancher.queue.length > 0; j++) { const task = brancher.queue.shift(); if (task.step >= BIFURCATION_STEPS || task.width < 0.5) continue; const length = Math.random() * 20 + 10; const endX = task.x + Math.cos(task.angle) * length; const endY = task.y + Math.sin(task.angle) * length; branches.push({ x1: task.x, y1: task.y, x2: endX, y2: endY, width: task.width, time: Date.now() }); const nextWidth = task.width * 0.8; brancher.queue.push({ x: endX, y: endY, angle: task.angle - (Math.random() * 0.4 + 0.15), width: nextWidth, step: task.step + 1 }); brancher.queue.push({ x: endX, y: endY, angle: task.angle + (Math.random() * 0.4 + 0.15), width: nextWidth, step: task.step + 1 }); } if (brancher.queue.length === 0) { brancherPool.splice(i, 1); } } }
        
        // --- Modified function ---
        function animateBg(ctx, canvas) { 
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            const now = Date.now(); 
            for (const stroke of strokes) { for (let i = 1; i < stroke.length; i++) { ctx.beginPath(); ctx.moveTo(stroke[i - 1].x, stroke[i - 1].y); ctx.lineTo(stroke[i].x, stroke[i].y); ctx.lineWidth = 7; ctx.lineCap = 'round'; ctx.strokeStyle = getDecayColor(stroke[i].time); ctx.stroke(); } } for (const branch of branches) { ctx.beginPath(); ctx.moveTo(branch.x1, branch.y1); ctx.lineTo(branch.x2, branch.y2); ctx.lineWidth = branch.width; ctx.lineCap = 'round'; ctx.strokeStyle = getDecayColor(branch.time); ctx.stroke(); } 
            strokes = strokes.map(stroke => stroke.filter(p => now - p.time < MARK_LIFETIME)).filter(stroke => stroke.length > 0); 
            branches = branches.filter(branch => now - branch.time < MARK_LIFETIME); 
            originalAnimationId = requestAnimationFrame(() => animateBg(ctx, canvas)); // Store animation ID
        }
        
        init();
        renderPage(0);
    });
    </script>
</body>
</html>
